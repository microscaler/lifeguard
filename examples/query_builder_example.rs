//! Query Builder Examples - Epic 02 Story 04
//!
//! Demonstrates various query patterns using the SeaQuery-based query builder.
//! Shows filtering, pagination, counting, and other query operations.

use lifeguard::{FromRow, LifeEntityName, LifeModelTrait, MayPostgresExecutor};
use may_postgres::Row;
use sea_query::{Expr, ExprTrait, Order};

// Example Entity for demonstration
// In a real application, this would be generated by the LifeModel derive macro
#[derive(Copy, Clone, Default, Debug)]
struct User;

impl LifeEntityName for User {
    fn table_name(&self) -> &'static str {
        "users"
    }
}

// Example model for demonstration
// In a real application, this would be generated by the LifeModel derive macro
#[derive(Debug)]
#[allow(dead_code)]
struct UserModel {
    id: i32,
    name: String,
    email: String,
    age: i32,
}

impl FromRow for UserModel {
    fn from_row(row: &Row) -> Result<Self, may_postgres::Error> {
        Ok(UserModel {
            id: row.get("id"),
            name: row.get("name"),
            email: row.get("email"),
            age: row.get("age"),
        })
    }
}

impl LifeModelTrait for User {
    type Model = UserModel;
    type Column = UserColumn;
}

// Example Column enum for demonstration
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum UserColumn {
    Id,
    Name,
    Email,
    Age,
}

impl sea_query::Iden for UserColumn {
    fn unquoted(&self) -> &str {
        match self {
            UserColumn::Id => "id",
            UserColumn::Name => "name",
            UserColumn::Email => "email",
            UserColumn::Age => "age",
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to database (replace with your connection string)
    let connection_string = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://postgres:postgres@localhost:5432/mydb".to_string());

    let client =
        lifeguard::connect(&connection_string).map_err(|e| format!("Connection error: {}", e))?;
    let executor = MayPostgresExecutor::new(client);

    // Example 1: Basic query with filter
    println!("Example 1: Basic query with filter");
    let users = User::find()
        .filter(Expr::col("age").gte(18))
        .all(&executor)?;
    println!("  Found {} users with age >= 18", users.len());

    // Example 2: Query with ordering
    println!("\nExample 2: Query with ordering");
    let users = User::find()
        .filter(Expr::col("age").gte(18))
        .order_by("name", Order::Asc)
        .all(&executor)?;
    println!("  Found {} users ordered by name", users.len());

    // Example 3: Efficient COUNT query (NEW - Epic 02 Story 05)
    println!("\nExample 3: Efficient COUNT query");
    let count = User::find()
        .filter(Expr::col("age").gte(18))
        .filter(Expr::col("age").lte(65))
        .count(&executor)?;
    println!("  Count of users aged 18-65: {}", count);
    // This uses COUNT(*) query - much more efficient than loading all rows!

    // Example 4: Pagination with count
    println!("\nExample 4: Pagination with count");
    let mut paginator = User::find()
        .filter(Expr::col("age").gte(18))
        .order_by("id", Order::Asc)
        .paginate_and_count(&executor, 10);

    let total = paginator.num_items()?;
    println!("  Total users: {}", total);

    let page_1 = paginator.fetch_page(1)?;
    println!("  Page 1: {} users", page_1.len());

    if total > 10 {
        let page_2 = paginator.fetch_page(2)?;
        println!("  Page 2: {} users", page_2.len());
    }

    // Example 5: Query with pagination (simple)
    println!("\nExample 5: Simple pagination");
    let users = User::find()
        .filter(Expr::col("age").gte(18))
        .order_by("id", Order::Asc)
        .limit(10)
        .offset(20)
        .all(&executor)?;
    println!("  Fetched {} users (page 3, 10 per page)", users.len());

    // Example 6: Query with multiple filters
    println!("\nExample 6: Multiple filters");
    let users = User::find()
        .filter(Expr::col("age").gte(18))
        .filter(Expr::col("age").lte(65))
        .filter(Expr::col("email").like("%@example.com"))
        .all(&executor)?;
    println!("  Found {} users matching all criteria", users.len());

    // Example 7: Single result query
    println!("\nExample 7: Single result query");
    match User::find()
        .filter(Expr::col("id").eq(1))
        .find_one(&executor)?
    {
        Some(user) => println!("  Found user with id=1: {:?}", user.id),
        None => println!("  No user found with id=1"),
    }

    // Example 8: Query with IN clause
    println!("\nExample 8: IN clause");
    let users = User::find()
        .filter(Expr::col("id").is_in(vec![1, 2, 3, 4, 5]))
        .all(&executor)?;
    println!("  Found {} users with id in [1,2,3,4,5]", users.len());

    // Example 9: Query with BETWEEN
    println!("\nExample 9: BETWEEN clause");
    let users = User::find()
        .filter(Expr::col("age").between(25, 35))
        .all(&executor)?;
    println!("  Found {} users aged 25-35", users.len());

    // Example 10: Complex query with multiple ordering
    println!("\nExample 10: Complex query");
    let users = User::find()
        .filter(Expr::col("age").gte(18))
        .filter(Expr::col("name").like("John%"))
        .order_by("age", Order::Desc)
        .order_by("name", Order::Asc)
        .limit(5)
        .all(&executor)?;
    println!("  Found {} users named 'John*' (top 5 by age)", users.len());

    // Example 11: Query with NULL checks
    println!("\nExample 11: NULL checks");
    let users_with_email = User::find()
        .filter(Expr::col("email").is_not_null())
        .all(&executor)?;
    println!(
        "  Found {} users with email addresses",
        users_with_email.len()
    );

    println!("\nâœ… All query examples completed successfully!");
    Ok(())
}

// Note: This example requires a database connection to run.
// To test the query building (without execution), you can use the unit tests in src/query.rs
