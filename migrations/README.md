# Lifeguard Migrations

This directory contains database migrations for Lifeguard ORM, including example migrations generated from entity definitions.

## Directory Structure

```
migrations/
├── generated/                   # Generated SQL migrations (from Lifeguard entities)
│   └── inventory/              # Example inventory service migrations
│       └── YYYYMMDDHHMMSS_generated_from_entities.sql
│
├── README.md                    # This file
├── SCHEMA_DESIGN.md             # Schema design documentation (if exists)
└── SCHEMA_ERD.md                # Entity Relationship Diagram (if exists)
```

## Migration Overview

This directory contains example migrations demonstrating Lifeguard's entity-driven migration generation:

### Example Entities

**Inventory Service** (`generated/inventory/`) - Example service demonstrating migration generation:
- **Categories** - Product categories with hierarchical structure (self-referencing foreign keys)
- **Products** - Products with category relationships, pricing, and stock tracking
- **Inventory Items** - Individual inventory items with location tracking and batch management

**Note**: Production accounting entities have been moved to `rerp/entities/`.

## Schema Design Principles

Common patterns used across migrations:

- **Audit Trail**: `created_at`, `updated_at` fields for tracking changes
- **Soft Deletes**: `is_active` flags instead of hard deletes where appropriate
- **Foreign Keys**: Proper referential integrity with ON DELETE actions
- **Indexes**: Strategic indexes on foreign keys and frequently queried columns
- **Unique Constraints**: Single and composite unique constraints for data integrity
- **Table Comments**: Documentation via PostgreSQL COMMENT ON TABLE statements

## Migration Strategy

### Entity-Driven Migration Generation

Lifeguard supports **entity-driven migration generation** where SQL migrations are automatically generated from Rust entity definitions. This ensures migrations stay in sync with your code.

#### Current Setup

1. **Example Entities** (`examples/entities/src/inventory/`): Example Lifeguard entities demonstrating migration generation
   - Located in `examples/entities/src/inventory/`
   - Includes: Category, Product, InventoryItem
   - Used for testing and documentation

2. **Generated SQL** (`generated/inventory/`): SQL migrations automatically generated from entities
   - Generated by running `cargo run --bin generate-migrations` from `examples/entities/`
   - SQL files are automatically organized by service based on entity location
   - Includes index validation to prevent invalid indexes on non-existent columns

### Generating Migrations

#### Using the Example Entities

```bash
# From the examples/entities directory
cd examples/entities
cargo run --bin generate-migrations
```

This generates SQL migrations in `migrations/generated/inventory/` from the entities in `src/inventory/`.

#### Using lifeguard-migrate CLI

```bash
# From the project root
lifeguard-migrate generate-from-entities \
    --entities-dir examples/entities/src \
    --output-dir migrations/generated
```

**Note**: The CLI tool uses file-based discovery which finds entity files but requires a registry for full SQL generation. The `generate-migrations` binary uses compiled entities directly.

### Index Validation

The SQL generator validates indexes before generating them:
- **Validates** that all columns in an index exist in the table
- **Skips** invalid indexes with a warning message
- **Prevents** runtime errors from indexes on non-existent columns

This prevents issues where child entities try to index columns from parent tables (e.g., `customer_invoices` trying to index `invoice_number` from the parent `invoices` table).

### File Naming Convention

Migrations follow the pattern: `YYYYMMDDHHMMSS_generated_from_entities.sql`

- `YYYYMMDDHHMMSS`: Timestamp (year, month, day, hour, minute, second)
- Generated migrations use the `_generated_from_entities` suffix

Example: `20260127141142_generated_from_entities.sql`

### Migration Execution

Migrations are executed in order by timestamp. The migration system:
- Discovers all `.sql` files in the migrations directory
- Sorts them by version (timestamp)
- Executes pending migrations that haven't been applied
- Tracks applied migrations in the `lifeguard_tracking.lifeguard_migrations` table

## Running Migrations

These migrations are designed to be run using Lifeguard's migration system:

```bash
# Using the CLI tool
lifeguard-migrate up --migrations-dir ./migrations

# Or programmatically
use lifeguard::migration::startup_migrations;
startup_migrations(&executor, "./migrations", None)?;
```

## Example Entity Structure

The example inventory entities demonstrate:

```rust
// examples/entities/src/inventory/category.rs
#[derive(LifeModel)]
#[table_name = "categories"]
#[table_comment = "Product categories for inventory organization"]
#[index = "idx_categories_code(code)"]
#[index = "idx_categories_name(name)"]
pub struct Category {
    #[primary_key]
    pub id: uuid::Uuid,
    
    #[unique]
    #[indexed]
    pub code: String,
    
    // Self-referencing foreign key
    #[foreign_key = "categories(id) ON DELETE SET NULL"]
    pub parent_id: Option<uuid::Uuid>,
    
    // ... other fields
}
```

Key features demonstrated:
- Primary keys with UUID defaults
- Foreign key constraints with ON DELETE actions
- Indexes on columns (validated at generation time)
- Composite unique constraints
- Table comments
- Default values and expressions

## Next Steps

1. **For Your Project**: Create Lifeguard entities using `LifeModel` and `LifeRecord` derives
2. **Generate Migrations**: Use `cargo run --bin generate-migrations` or the CLI tool
3. **Validate**: Review generated SQL to ensure it matches your requirements
4. **Apply**: Run migrations using `lifeguard-migrate up`
5. **Iterate**: Update entities and regenerate migrations as your schema evolves

## Notes

- **No Rust wrapper files**: We use SQL-only migrations (no `.rs` files wrapping SQL)
- **Entity-driven**: Migrations are generated from entity definitions using `#[derive(LifeModel)]`
- **SQL is source of truth**: Migrations are readable SQL files that can be executed with `psql`
- **Index validation**: The generator validates indexes and skips invalid ones to prevent runtime errors
- **Service organization**: Migrations are organized by service (e.g., `inventory/`) matching entity structure
- **UUID primary keys**: All UUIDs use PostgreSQL's `gen_random_uuid()` for primary keys
- **Timestamps**: Use `TIMESTAMP` (not `TIMESTAMPTZ`) for simplicity
- **Numeric precision**: `NUMERIC(19, 4)` for monetary amounts (supports up to 15 digits before decimal, 4 after)
- **Example entities**: Located in `examples/entities/src/` for testing and documentation
- **RERP entities**: Production accounting entities are in `rerp/entities/` (separate repository)

## Related Documentation

- `SCHEMA_DESIGN.md`: Detailed schema design documentation
- `SCHEMA_ERD.md`: Entity Relationship Diagram
- `../docs/MIGRATION_PROCESS_DIAGRAMS.md`: Migration process diagrams and architecture
