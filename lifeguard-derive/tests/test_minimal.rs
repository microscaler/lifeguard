//! Minimal test for LifeModel derive macro
//!
//! This test verifies the basic flow:
//! 1. LifeModel generates Entity, Model, Column, PrimaryKey, FromRow
//! 2. DeriveEntity (nested) generates LifeModelTrait
//! 3. All generated code compiles and works together

use lifeguard_derive::{LifeModel, LifeRecord};

// Simple user entity for testing
#[derive(LifeModel, LifeRecord)]
#[table_name = "users"]
pub struct User {
    #[primary_key]
    pub id: i32,
    pub name: String,
    pub email: String,
}

// Entity with Option fields for testing Option<T> edge cases
// Using a module to avoid name conflicts
mod option_tests {
    use super::*;
    
    #[derive(LifeModel)]
    #[table_name = "users_with_options"]
    pub struct UserWithOptions {
        #[primary_key]
        pub id: i32,
        pub name: Option<String>,
        pub age: Option<i32>,
        pub active: Option<bool>,
    }
}

// Entity with numeric fields for testing all numeric types
// Using a module to avoid name conflicts
// NOTE: may_postgres doesn't support u8, u16, u64 in FromSql, so we manually implement ModelTrait
// This allows us to test get() and set() operations without needing FromRow
mod numeric_tests {
    
    // Manual model for numeric testing (bypasses FromRow requirement)
    #[derive(Debug, Clone)]
    pub struct NumericFieldsModel {
        pub id: i32,
        pub u8_field: u8,
        pub u16_field: u16,
        pub u32_field: u32,
        pub u64_field: u64,
        pub f32_field: f32,
        pub f64_field: f64,
    }
    
    // Manual Column enum for numeric testing
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum Column {
        Id,
        U8Field,
        U16Field,
        U32Field,
        U64Field,
        F32Field,
        F64Field,
    }
    
    impl sea_query::Iden for Column {
        fn unquoted(&self) -> &str {
            match self {
                Column::Id => "id",
                Column::U8Field => "u8_field",
                Column::U16Field => "u16_field",
                Column::U32Field => "u32_field",
                Column::U64Field => "u64_field",
                Column::F32Field => "f32_field",
                Column::F64Field => "f64_field",
            }
        }
    }
    
    impl sea_query::IdenStatic for Column {
        fn as_str(&self) -> &'static str {
            match self {
                Column::Id => "id",
                Column::U8Field => "u8_field",
                Column::U16Field => "u16_field",
                Column::U32Field => "u32_field",
                Column::U64Field => "u64_field",
                Column::F32Field => "f32_field",
                Column::F64Field => "f64_field",
            }
        }
    }
    
    // Manual Entity for numeric testing
    #[derive(Copy, Clone, Debug, Default)]
    pub struct Entity;
    
    impl lifeguard::LifeEntityName for Entity {
        fn table_name(&self) -> &'static str {
            "numeric_fields"
        }
    }
    
    impl lifeguard::LifeModelTrait for Entity {
        type Model = NumericFieldsModel;
        type Column = Column;
    }
    
    // Manual ModelTrait implementation for numeric testing
    // This uses the same logic that would be generated by the macro
    impl lifeguard::ModelTrait for NumericFieldsModel {
        type Entity = Entity;
        
        fn get(&self, column: Column) -> sea_query::Value {
            match column {
                Column::Id => sea_query::Value::Int(Some(self.id)),
                Column::U8Field => sea_query::Value::SmallInt(Some(self.u8_field as i16)),
                Column::U16Field => sea_query::Value::Int(Some(self.u16_field as i32)),
                Column::U32Field => sea_query::Value::BigInt(Some(self.u32_field as i64)),
                Column::U64Field => sea_query::Value::BigInt(Some(self.u64_field as i64)),
                Column::F32Field => sea_query::Value::Float(Some(self.f32_field)),
                Column::F64Field => sea_query::Value::Double(Some(self.f64_field)),
            }
        }
        
        fn set(
            &mut self,
            column: Column,
            value: sea_query::Value,
        ) -> Result<(), lifeguard::ModelError> {
            match column {
                Column::Id => match value {
                    sea_query::Value::Int(Some(v)) => {
                        self.id = v;
                        Ok(())
                    }
                    sea_query::Value::Int(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int(Some(_))".to_string(),
                        actual: "Int(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U8Field => match value {
                    sea_query::Value::SmallInt(Some(v)) => {
                        self.u8_field = v as u8;
                        Ok(())
                    }
                    sea_query::Value::SmallInt(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U8Field".to_string(),
                        expected: "SmallInt(Some(_))".to_string(),
                        actual: "SmallInt(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U8Field".to_string(),
                        expected: "SmallInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U16Field => match value {
                    sea_query::Value::Int(Some(v)) => {
                        self.u16_field = v as u16;
                        Ok(())
                    }
                    sea_query::Value::Int(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U16Field".to_string(),
                        expected: "Int(Some(_))".to_string(),
                        actual: "Int(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U16Field".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U32Field => match value {
                    sea_query::Value::BigInt(Some(v)) => {
                        self.u32_field = v as u32;
                        Ok(())
                    }
                    sea_query::Value::BigInt(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U32Field".to_string(),
                        expected: "BigInt(Some(_))".to_string(),
                        actual: "BigInt(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U32Field".to_string(),
                        expected: "BigInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U64Field => match value {
                    sea_query::Value::BigInt(Some(v)) => {
                        self.u64_field = v as u64;
                        Ok(())
                    }
                    sea_query::Value::BigInt(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U64Field".to_string(),
                        expected: "BigInt(Some(_))".to_string(),
                        actual: "BigInt(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U64Field".to_string(),
                        expected: "BigInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::F32Field => match value {
                    sea_query::Value::Float(Some(v)) => {
                        self.f32_field = v;
                        Ok(())
                    }
                    sea_query::Value::Float(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F32Field".to_string(),
                        expected: "Float(Some(_))".to_string(),
                        actual: "Float(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F32Field".to_string(),
                        expected: "Float".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::F64Field => match value {
                    sea_query::Value::Double(Some(v)) => {
                        self.f64_field = v;
                        Ok(())
                    }
                    sea_query::Value::Double(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F64Field".to_string(),
                        expected: "Double(Some(_))".to_string(),
                        actual: "Double(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F64Field".to_string(),
                        expected: "Double".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
            }
        }
        
        fn get_primary_key_value(&self) -> sea_query::Value {
            sea_query::Value::Int(Some(self.id))
        }
    }
}

// Entity with Option numeric fields for testing Option<T> numeric types
mod option_numeric_tests {
    
    // Manual model for Option numeric testing (bypasses FromRow requirement)
    #[derive(Debug, Clone)]
    pub struct OptionNumericFieldsModel {
        pub id: i32,
        pub u8_field: Option<u8>,
        pub u16_field: Option<u16>,
        pub u32_field: Option<u32>,
        pub u64_field: Option<u64>,
        pub f32_field: Option<f32>,
        pub f64_field: Option<f64>,
    }
    
    // Manual Column enum for Option numeric testing
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum Column {
        Id,
        U8Field,
        U16Field,
        U32Field,
        U64Field,
        F32Field,
        F64Field,
    }
    
    impl sea_query::Iden for Column {
        fn unquoted(&self) -> &str {
            match self {
                Column::Id => "id",
                Column::U8Field => "u8_field",
                Column::U16Field => "u16_field",
                Column::U32Field => "u32_field",
                Column::U64Field => "u64_field",
                Column::F32Field => "f32_field",
                Column::F64Field => "f64_field",
            }
        }
    }
    
    impl sea_query::IdenStatic for Column {
        fn as_str(&self) -> &'static str {
            match self {
                Column::Id => "id",
                Column::U8Field => "u8_field",
                Column::U16Field => "u16_field",
                Column::U32Field => "u32_field",
                Column::U64Field => "u64_field",
                Column::F32Field => "f32_field",
                Column::F64Field => "f64_field",
            }
        }
    }
    
    // Manual Entity for Option numeric testing
    #[derive(Copy, Clone, Debug, Default)]
    pub struct Entity;
    
    impl lifeguard::LifeEntityName for Entity {
        fn table_name(&self) -> &'static str {
            "option_numeric_fields"
        }
    }
    
    impl lifeguard::LifeModelTrait for Entity {
        type Model = OptionNumericFieldsModel;
        type Column = Column;
    }
    
    // Manual ModelTrait implementation for Option numeric testing
    // This uses the same logic that would be generated by the macro
    impl lifeguard::ModelTrait for OptionNumericFieldsModel {
        type Entity = Entity;
        
        fn get(&self, column: Column) -> sea_query::Value {
            match column {
                Column::Id => sea_query::Value::Int(Some(self.id)),
                Column::U8Field => self.u8_field.map(|v| sea_query::Value::SmallInt(Some(v as i16))).unwrap_or(sea_query::Value::SmallInt(None)),
                Column::U16Field => self.u16_field.map(|v| sea_query::Value::Int(Some(v as i32))).unwrap_or(sea_query::Value::Int(None)),
                Column::U32Field => self.u32_field.map(|v| sea_query::Value::BigInt(Some(v as i64))).unwrap_or(sea_query::Value::BigInt(None)),
                Column::U64Field => self.u64_field.map(|v| sea_query::Value::BigInt(Some(v as i64))).unwrap_or(sea_query::Value::BigInt(None)),
                Column::F32Field => self.f32_field.map(|v| sea_query::Value::Float(Some(v))).unwrap_or(sea_query::Value::Float(None)),
                Column::F64Field => self.f64_field.map(|v| sea_query::Value::Double(Some(v))).unwrap_or(sea_query::Value::Double(None)),
            }
        }
        
        fn set(
            &mut self,
            column: Column,
            value: sea_query::Value,
        ) -> Result<(), lifeguard::ModelError> {
            match column {
                Column::Id => match value {
                    sea_query::Value::Int(Some(v)) => {
                        self.id = v;
                        Ok(())
                    }
                    sea_query::Value::Int(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int(Some(_))".to_string(),
                        actual: "Int(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U8Field => match value {
                    sea_query::Value::SmallInt(Some(v)) => {
                        self.u8_field = Some(v as u8);
                        Ok(())
                    }
                    sea_query::Value::SmallInt(None) => {
                        self.u8_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U8Field".to_string(),
                        expected: "SmallInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U16Field => match value {
                    sea_query::Value::Int(Some(v)) => {
                        self.u16_field = Some(v as u16);
                        Ok(())
                    }
                    sea_query::Value::Int(None) => {
                        self.u16_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U16Field".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U32Field => match value {
                    sea_query::Value::BigInt(Some(v)) => {
                        self.u32_field = Some(v as u32);
                        Ok(())
                    }
                    sea_query::Value::BigInt(None) => {
                        self.u32_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U32Field".to_string(),
                        expected: "BigInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U64Field => match value {
                    sea_query::Value::BigInt(Some(v)) => {
                        self.u64_field = Some(v as u64);
                        Ok(())
                    }
                    sea_query::Value::BigInt(None) => {
                        self.u64_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U64Field".to_string(),
                        expected: "BigInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::F32Field => match value {
                    sea_query::Value::Float(Some(v)) => {
                        self.f32_field = Some(v);
                        Ok(())
                    }
                    sea_query::Value::Float(None) => {
                        self.f32_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F32Field".to_string(),
                        expected: "Float".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::F64Field => match value {
                    sea_query::Value::Double(Some(v)) => {
                        self.f64_field = Some(v);
                        Ok(())
                    }
                    sea_query::Value::Double(None) => {
                        self.f64_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F64Field".to_string(),
                        expected: "Double".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
            }
        }
        
        fn get_primary_key_value(&self) -> sea_query::Value {
            sea_query::Value::Int(Some(self.id))
        }
    }
}

// Entity with JSON field for testing JSON edge cases
// Using a module to avoid name conflicts
// NOTE: JSON fields require special FromRow handling (deserialize from text/JSONB)
// For now, we'll test JSON in get/set operations using manual model construction
mod json_tests {
    use super::*;
    
    // Note: We can't use LifeModel derive for JSON fields yet because FromRow needs
    // special handling to deserialize JSON from database text/JSONB columns.
    // For testing get/set operations, we'll manually construct the model.
    
    // Manual model for JSON testing (bypasses FromRow requirement)
    #[derive(Debug, Clone)]
    pub struct UserWithJsonModel {
        pub id: i32,
        pub name: String,
        pub metadata: serde_json::Value,
        pub preferences: Option<serde_json::Value>,
    }
    
    // Manual Column enum for JSON testing
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum Column {
        Id,
        Name,
        Metadata,
        Preferences,
    }
    
    impl sea_query::Iden for Column {
        fn unquoted(&self) -> &str {
            match self {
                Column::Id => "id",
                Column::Name => "name",
                Column::Metadata => "metadata",
                Column::Preferences => "preferences",
            }
        }
    }
    
    impl sea_query::IdenStatic for Column {
        fn as_str(&self) -> &'static str {
            match self {
                Column::Id => "id",
                Column::Name => "name",
                Column::Metadata => "metadata",
                Column::Preferences => "preferences",
            }
        }
    }
    
    // Manual Entity for JSON testing
    #[derive(Copy, Clone, Debug, Default)]
    pub struct Entity;
    
    impl lifeguard::LifeEntityName for Entity {
        fn table_name(&self) -> &'static str {
            "users_with_json"
        }
    }
    
    impl lifeguard::LifeModelTrait for Entity {
        type Model = UserWithJsonModel;
        type Column = Column;
    }
    
    // Manual ModelTrait implementation for JSON testing
    impl lifeguard::ModelTrait for UserWithJsonModel {
        type Entity = Entity;
        
        fn get(&self, column: Column) -> sea_query::Value {
            match column {
                Column::Id => sea_query::Value::Int(Some(self.id)),
                Column::Name => sea_query::Value::String(Some(self.name.clone())),
                Column::Metadata => sea_query::Value::Json(Some(Box::new(self.metadata.clone()))),
                Column::Preferences => match &self.preferences {
                    Some(v) => sea_query::Value::Json(Some(Box::new(v.clone()))),
                    None => sea_query::Value::Json(None),
                },
            }
        }
        
        fn set(
            &mut self,
            column: Column,
            value: sea_query::Value,
        ) -> Result<(), lifeguard::ModelError> {
            match column {
                Column::Id => match value {
                    sea_query::Value::Int(Some(v)) => {
                        self.id = v;
                        Ok(())
                    }
                    sea_query::Value::Int(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int(Some(_))".to_string(),
                        actual: "Int(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::Name => match value {
                    sea_query::Value::String(Some(v)) => {
                        self.name = v;
                        Ok(())
                    }
                    sea_query::Value::String(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Name".to_string(),
                        expected: "String(Some(_))".to_string(),
                        actual: "String(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Name".to_string(),
                        expected: "String".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::Metadata => match value {
                    sea_query::Value::Json(Some(v)) => {
                        self.metadata = *v;
                        Ok(())
                    }
                    sea_query::Value::Json(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Metadata".to_string(),
                        expected: "Json(Some(_))".to_string(),
                        actual: "Json(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Metadata".to_string(),
                        expected: "Json".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::Preferences => match value {
                    sea_query::Value::Json(Some(v)) => {
                        self.preferences = Some(*v);
                        Ok(())
                    }
                    sea_query::Value::Json(None) => {
                        self.preferences = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Preferences".to_string(),
                        expected: "Json".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
            }
        }
        
        fn get_primary_key_value(&self) -> sea_query::Value {
            sea_query::Value::Int(Some(self.id))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use lifeguard::{FromRow, LifeEntityName, LifeModelTrait, ModelTrait};
    use sea_query::Value;

    #[test]
    fn test_entity_exists() {
        // Verify Entity unit struct exists and implements required traits
        let entity = Entity;
        
        // Test LifeEntityName
        assert_eq!(entity.table_name(), "users");
        assert_eq!(Entity::default().table_name(), "users");
        
        // Test Default
        let _default_entity = Entity::default();
    }

    #[test]
    fn test_column_enum_exists() {
        // Verify Column enum exists and implements Iden
        use sea_query::Iden;
        
        assert_eq!(Column::Id.unquoted(), "id");
        assert_eq!(Column::Name.unquoted(), "name");
        assert_eq!(Column::Email.unquoted(), "email");
    }

    #[test]
    fn test_primary_key_enum_exists() {
        // Verify PrimaryKey enum exists
        let _pk = PrimaryKey::Id;
    }

    #[test]
    fn test_primary_key_trait_value_type() {
        // Verify PrimaryKeyTrait is implemented and ValueType is correct
        use lifeguard::PrimaryKeyTrait;
        
        // ValueType should be i32 for User entity
        let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i32;
    }

    #[test]
    fn test_primary_key_trait_auto_increment() {
        // Verify auto_increment() method works
        use lifeguard::PrimaryKeyTrait;
        
        let pk = PrimaryKey::Id;
        // User entity doesn't have #[auto_increment], so should return false
        assert_eq!(pk.auto_increment(), false);
    }

    #[test]
    fn test_primary_key_to_column() {
        // Verify PrimaryKeyToColumn is implemented and works correctly
        use lifeguard::PrimaryKeyToColumn;
        
        let pk = PrimaryKey::Id;
        let col = pk.to_column();
        
        // Should convert to Column::Id
        assert_eq!(col, Column::Id);
    }

    // ============================================================================
    // PRIMARY KEY TRAIT EDGE CASE TESTS
    // ============================================================================

    #[test]
    fn test_primary_key_trait_value_type_non_option() {
        // Test ValueType for non-Option primary key (i32)
        use lifeguard::PrimaryKeyTrait;
        
        // User entity has i32 primary key (non-Option)
        let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i32;
        // Should compile - ValueType should be i32, not Option<i32>
    }

    #[test]
    fn test_primary_key_trait_auto_increment_false() {
        // Test auto_increment() returns false when #[auto_increment] is not present
        use lifeguard::PrimaryKeyTrait;
        
        let pk = PrimaryKey::Id;
        // User entity doesn't have #[auto_increment] attribute
        assert_eq!(pk.auto_increment(), false, "Primary key without #[auto_increment] should return false");
    }

    #[test]
    fn test_primary_key_to_column_all_variants() {
        // Test that to_column() works for all PrimaryKey variants
        use lifeguard::PrimaryKeyToColumn;
        
        // User entity only has one primary key variant
        let pk = PrimaryKey::Id;
        let col = pk.to_column();
        assert_eq!(col, Column::Id, "PrimaryKey::Id should map to Column::Id");
    }

    #[test]
    fn test_primary_key_arity_single() {
        // Test that PrimaryKeyArityTrait is implemented and returns Single for single primary key
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};
        
        let arity = PrimaryKey::arity();
        assert_eq!(arity, PrimaryKeyArity::Single, "Single primary key should return Single arity");
    }

    #[test]
    fn test_primary_key_arity_granular_variants() {
        // Test that granular arity variants exist and can be used
        use lifeguard::PrimaryKeyArity;
        
        // Verify all variants exist
        let _single = PrimaryKeyArity::Single;
        let _tuple2 = PrimaryKeyArity::Tuple2;
        let _tuple3 = PrimaryKeyArity::Tuple3;
        let _tuple4 = PrimaryKeyArity::Tuple4;
        let _tuple5 = PrimaryKeyArity::Tuple5;
        let _tuple6plus = PrimaryKeyArity::Tuple6Plus;
    }

    // ============================================================================
    // PRIMARY KEY EDGE CASE TESTS
    // ============================================================================

    // Each entity is in its own module to avoid name conflicts with generated types
    mod option_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};

        #[derive(LifeModel)]
        #[table_name = "test_option_pk"]
        pub struct OptionPrimaryKeyEntity {
            #[primary_key]
            pub id: Option<i32>,
            pub name: String,
        }

        #[test]
        fn test_option_primary_key_value_type() {
            // Test that Option<i32> primary key extracts inner type (i32) for ValueType
            // This is a critical edge case - ValueType should be i32, not Option<i32>
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i32;
            // Should compile - ValueType should be i32 (inner type), not Option<i32>
        }

        #[test]
        fn test_option_primary_key_auto_increment() {
            let pk = PrimaryKey::Id;
            assert_eq!(pk.auto_increment(), false);
        }

        #[test]
        fn test_option_primary_key_to_column() {
            let pk = PrimaryKey::Id;
            let col = pk.to_column();
            assert_eq!(col, Column::Id);
        }
    }

    mod i64_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};

        #[derive(LifeModel)]
        #[table_name = "test_i64_pk"]
        pub struct I64PrimaryKeyEntity {
            #[primary_key]
            pub id: i64,
            pub name: String,
        }

        #[test]
        fn test_i64_primary_key_value_type() {
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i64;
        }

        #[test]
        fn test_i64_primary_key_auto_increment() {
            let pk = PrimaryKey::Id;
            assert_eq!(pk.auto_increment(), false);
        }
    }

    mod string_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};

        #[derive(LifeModel)]
        #[table_name = "test_string_pk"]
        pub struct StringPrimaryKeyEntity {
            #[primary_key]
            pub id: String,
            pub name: String,
        }

        #[test]
        fn test_string_primary_key_value_type() {
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = "test".to_string();
        }

        #[test]
        fn test_string_primary_key_auto_increment() {
            let pk = PrimaryKey::Id;
            assert_eq!(pk.auto_increment(), false);
        }

        #[test]
        fn test_string_primary_key_to_column() {
            let pk = PrimaryKey::Id;
            let col = pk.to_column();
            assert_eq!(col, Column::Id);
        }
    }

    mod auto_inc_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};

        #[derive(LifeModel)]
        #[table_name = "test_auto_inc_pk"]
        pub struct AutoIncrementPrimaryKeyEntity {
            #[primary_key]
            #[auto_increment]
            pub id: i32,
            pub name: String,
        }

        #[test]
        fn test_auto_increment_primary_key_true() {
            let pk = PrimaryKey::Id;
            assert_eq!(pk.auto_increment(), true, "Primary key with #[auto_increment] should return true");
        }

        #[test]
        fn test_auto_increment_primary_key_value_type() {
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i32;
        }

        #[test]
        fn test_auto_increment_primary_key_to_column() {
            let pk = PrimaryKey::Id;
            let col = pk.to_column();
            assert_eq!(col, Column::Id);
        }
    }

    mod composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};

        #[derive(LifeModel)]
        #[table_name = "test_composite_pk"]
        pub struct CompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id2: i32,
            pub name: String,
        }

        #[test]
        fn test_composite_primary_key_value_type_tuple() {
            // ValueType should be a tuple for composite keys
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = (42i32, 43i32);
        }

        #[test]
        fn test_composite_primary_key_auto_increment() {
            // Both variants return their own auto_increment value (fixed!)
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.auto_increment(), false);
            assert_eq!(pk2.auto_increment(), false);
        }

        #[test]
        fn test_composite_primary_key_to_column() {
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.to_column(), Column::Id1);
            assert_eq!(pk2.to_column(), Column::Id2);
        }

        #[test]
        fn test_composite_primary_key_all_variants() {
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            let _col1 = pk1.to_column();
            let _col2 = pk2.to_column();
        }

        #[test]
        fn test_composite_primary_key_arity() {
            // Verify PrimaryKeyArityTrait is implemented and returns Tuple2 for 2-column composite keys
            use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};
            
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple2, "2-column composite primary key should return Tuple2 arity");
        }
    }

    mod mixed_auto_inc_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};

        #[derive(LifeModel)]
        #[table_name = "test_mixed_auto_inc_pk"]
        pub struct MixedAutoIncrementCompositePrimaryKeyEntity {
            #[primary_key]
            #[auto_increment]
            pub id1: i32,
            #[primary_key]
            pub id2: i32, // No auto_increment
            pub name: String,
        }

        #[test]
        fn test_mixed_auto_increment_composite_primary_key() {
            // This test verifies the fix: each variant returns its own auto_increment value
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.auto_increment(), true, "Primary key with #[auto_increment] should return true");
            assert_eq!(pk2.auto_increment(), false, "Primary key without #[auto_increment] should return false");
        }

        #[test]
        fn test_mixed_auto_increment_composite_primary_key_to_column() {
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.to_column(), Column::Id1);
            assert_eq!(pk2.to_column(), Column::Id2);
        }

        #[test]
        fn test_mixed_auto_increment_composite_primary_key_arity() {
            // Verify PrimaryKeyArityTrait returns Tuple2 for 2-column composite keys
            use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};
            
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple2, "2-column composite primary key should return Tuple2 arity");
        }

        #[test]
        fn test_mixed_auto_increment_composite_primary_key_arity_with_auto_inc() {
            // EDGE CASE: Verify that PrimaryKeyArity works correctly with mixed auto_increment
            // This tests that arity is independent of auto_increment settings
            use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait, PrimaryKeyTrait};
            
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple2, "Arity should be Tuple2 regardless of auto_increment settings");
            
            // Verify auto_increment still works correctly per variant
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.auto_increment(), true, "First key has auto_increment");
            assert_eq!(pk2.auto_increment(), false, "Second key does not have auto_increment");
        }
    }

    // ============================================================================
    // PRIMARY KEY ARITY EDGE CASE TESTS
    // ============================================================================

    mod tuple3_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_tuple3_composite_pk"]
        pub struct Tuple3CompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id2: i32,
            #[primary_key]
            pub id3: i32,
            pub name: String,
        }

        #[test]
        fn test_tuple3_composite_primary_key_arity() {
            // Test that 3 primary keys return Tuple3
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple3, "3-column composite primary key should return Tuple3 arity");
        }
    }

    mod tuple4_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_tuple4_composite_pk"]
        pub struct Tuple4CompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id2: i32,
            #[primary_key]
            pub id3: i32,
            #[primary_key]
            pub id4: i32,
            pub name: String,
        }

        #[test]
        fn test_tuple4_composite_primary_key_arity() {
            // Test that 4 primary keys return Tuple4
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple4, "4-column composite primary key should return Tuple4 arity");
        }
    }

    mod tuple5_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_tuple5_composite_pk"]
        pub struct Tuple5CompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id2: i32,
            #[primary_key]
            pub id3: i32,
            #[primary_key]
            pub id4: i32,
            #[primary_key]
            pub id5: i32,
            pub name: String,
        }

        #[test]
        fn test_tuple5_composite_primary_key_arity() {
            // Test that 5 primary keys return Tuple5
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple5, "5-column composite primary key should return Tuple5 arity");
        }
    }

    mod tuple6plus_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_tuple6plus_composite_pk"]
        pub struct Tuple6PlusCompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id2: i32,
            #[primary_key]
            pub id3: i32,
            #[primary_key]
            pub id4: i32,
            #[primary_key]
            pub id5: i32,
            #[primary_key]
            pub id6: i32,
            #[primary_key]
            pub id7: i32,
            pub name: String,
        }

        #[test]
        fn test_tuple6plus_composite_primary_key_arity() {
            // Test that 6+ primary keys return Tuple6Plus
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple6Plus, "6+ column composite primary key should return Tuple6Plus arity");
        }
    }

    mod large_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_large_composite_pk"]
        pub struct LargeCompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id2: i32,
            #[primary_key]
            pub id3: i32,
            #[primary_key]
            pub id4: i32,
            pub name: String,
        }

        #[test]
        fn test_large_composite_primary_key_arity() {
            // Test that 4 primary keys return Tuple4
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple4, "4-column composite primary key should return Tuple4 arity");
        }

        #[test]
        fn test_large_composite_primary_key_all_variants() {
            // Verify all primary key variants work
            use lifeguard::PrimaryKeyToColumn;
            
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            let pk3 = PrimaryKey::Id3;
            let pk4 = PrimaryKey::Id4;
            
            assert_eq!(pk1.to_column(), Column::Id1);
            assert_eq!(pk2.to_column(), Column::Id2);
            assert_eq!(pk3.to_column(), Column::Id3);
            assert_eq!(pk4.to_column(), Column::Id4);
        }

        #[test]
        fn test_large_composite_primary_key_value_type_tuple() {
            // Verify ValueType is a tuple for large composite keys (3+ columns)
            use lifeguard::PrimaryKeyTrait;
            
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = (1i32, 2i32, 3i32, 4i32);
        }
    }

    mod mixed_type_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait, PrimaryKeyTrait};

        #[derive(LifeModel)]
        #[table_name = "test_mixed_type_composite_pk"]
        pub struct MixedTypeCompositePrimaryKeyEntity {
            #[primary_key]
            pub id: i32,
            #[primary_key]
            pub code: String,
            pub name: String,
        }

        #[test]
        fn test_mixed_type_composite_primary_key_arity() {
            // Test composite key with different types (i32 + String)
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple2, "2-column mixed type composite primary key should return Tuple2 arity");
        }

        #[test]
        fn test_mixed_type_composite_primary_key_value_type_tuple() {
            // EDGE CASE: ValueType is now a tuple for composite keys
            // This verifies that ValueType is (i32, String) for composite keys with mixed types
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = (42i32, "test".to_string());
            // Note: This compiles because ValueType is (i32, String) - full tuple support!
        }

        #[test]
        fn test_mixed_type_composite_primary_key_to_column() {
            use lifeguard::PrimaryKeyToColumn;
            
            let pk1 = PrimaryKey::Id;
            let pk2 = PrimaryKey::Code;
            
            assert_eq!(pk1.to_column(), Column::Id);
            assert_eq!(pk2.to_column(), Column::Code);
        }
    }

    mod option_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::PrimaryKeyTrait;

        #[derive(LifeModel)]
        #[table_name = "test_option_composite_pk"]
        pub struct OptionCompositePrimaryKeyEntity {
            #[primary_key]
            pub id: Option<i32>,
            #[primary_key]
            pub code: Option<String>,
            pub name: String,
        }

        #[test]
        fn test_option_composite_primary_key_value_type() {
            // EDGE CASE: Composite key with Option types - Option should be unwrapped in ValueType tuple
            // ValueType should be (i32, String), not (Option<i32>, Option<String>)
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = (42i32, "test".to_string());
        }
    }

    mod no_primary_key_entity {
        use super::*;
        use lifeguard_derive::LifeModel;

        #[derive(LifeModel)]
        #[table_name = "test_no_pk"]
        pub struct NoPrimaryKeyEntity {
            pub name: String,
            pub email: String,
        }

        #[test]
        fn test_no_primary_key_enum_is_empty() {
            // EDGE CASE: Entity with no primary key
            // PrimaryKey enum is generated but empty (no variants)
            // This is a compile-time construct, so we can't easily test it at runtime
            // But we can verify that PrimaryKeyArityTrait is NOT implemented
            // (trying to call PrimaryKey::arity() would be a compile error)
            
            // The PrimaryKey enum exists but has no variants
            // PrimaryKeyArityTrait is not implemented (by design)
            // This is correct behavior - entities without primary keys don't need arity
        }

        #[test]
        fn test_no_primary_key_get_primary_key_value() {
            // EDGE CASE: get_primary_key_value() returns String(None) when no primary key exists
            use lifeguard::ModelTrait;
            
            let model = NoPrimaryKeyEntityModel {
                name: "Test".to_string(),
                email: "test@example.com".to_string(),
            };
            
            let pk_value = model.get_primary_key_value();
            // Should return Value::String(None) as documented
            assert_eq!(pk_value, sea_query::Value::String(None));
        }
    }

    #[test]
    fn test_model_struct_exists() {
        // Verify Model struct exists and can be instantiated
        let model = UserModel {
            id: 1,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        assert_eq!(model.id, 1);
        assert_eq!(model.name, "Test User");
        assert_eq!(model.email, "test@example.com");
    }

    #[test]
    fn test_from_row_trait_implemented() {
        // Verify FromRow trait is implemented for UserModel
        // We can't easily test the actual implementation without a real Row,
        // but we can verify the trait is implemented by checking it compiles
        fn _verify_from_row<T: FromRow>() {}
        _verify_from_row::<UserModel>();
    }

    #[test]
    fn test_life_model_trait_implemented() {
        // Verify LifeModelTrait is implemented for Entity
        // This is generated by DeriveEntity (nested expansion)
        fn _verify_life_model_trait<E: LifeModelTrait>() {}
        _verify_life_model_trait::<Entity>();
        
        // Verify the associated type Model is correct
        fn _verify_model_type<E: LifeModelTrait<Model = UserModel>>() {}
        _verify_model_type::<Entity>();
    }

    #[test]
    fn test_find_method_works() {
        // Verify Entity::find() returns SelectQuery
        // This tests the LifeModelTrait::find() method
        let _query = Entity::find();
        // Just verify it compiles - actual execution requires an executor
    }

    #[test]
    fn test_entity_table_name_constant() {
        // Verify Entity::TABLE_NAME constant exists
        assert_eq!(Entity::TABLE_NAME, "users");
    }

    #[test]
    fn test_model_trait_implemented() {
        // Verify ModelTrait is implemented for UserModel
        fn _verify_model_trait<M: ModelTrait>() {}
        _verify_model_trait::<UserModel>();
        
        // Verify the associated type Entity is correct
        fn _verify_entity_type<M: ModelTrait<Entity = Entity>>() {}
        _verify_entity_type::<UserModel>();
    }

    #[test]
    fn test_model_trait_get() {
        // Test ModelTrait::get() method
        let model = UserModel {
            id: 1,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Test getting id column
        let id_value = model.get(Column::Id);
        match id_value {
            Value::Int(Some(v)) => assert_eq!(v, 1),
            _ => panic!("Expected Int(Some(1)), got {:?}", id_value),
        }
        
        // Test getting name column
        let name_value = model.get(Column::Name);
        match name_value {
            Value::String(Some(v)) => assert_eq!(v, "Test User"),
            _ => panic!("Expected String(Some(\"Test User\")), got {:?}", name_value),
        }
        
        // Test getting email column
        let email_value = model.get(Column::Email);
        match email_value {
            Value::String(Some(v)) => assert_eq!(v, "test@example.com"),
            _ => panic!("Expected String(Some(\"test@example.com\")), got {:?}", email_value),
        }
    }

    #[test]
    fn test_model_trait_set() {
        // Test ModelTrait::set() method
        let mut model = UserModel {
            id: 1,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Test setting name column
        let result = model.set(Column::Name, Value::String(Some("Updated Name".to_string())));
        assert!(result.is_ok());
        assert_eq!(model.name, "Updated Name");
        
        // Test setting id column
        let result = model.set(Column::Id, Value::Int(Some(42)));
        assert!(result.is_ok());
        assert_eq!(model.id, 42);
        
        // Test setting email column
        let result = model.set(Column::Email, Value::String(Some("updated@example.com".to_string())));
        assert!(result.is_ok());
        assert_eq!(model.email, "updated@example.com");
        
        // Test invalid value type
        let result = model.set(Column::Id, Value::String(Some("invalid".to_string())));
        assert!(result.is_err());
    }

    #[test]
    fn test_model_trait_get_primary_key_value() {
        // Test ModelTrait::get_primary_key_value() method
        let model = UserModel {
            id: 123,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        let pk_value = model.get_primary_key_value();
        match pk_value {
            Value::Int(Some(v)) => assert_eq!(v, 123),
            _ => panic!("Expected Int(Some(123)), got {:?}", pk_value),
        }
    }

    #[test]
    fn test_model_trait_set_null_for_non_option() {
        // Test that setting None value for non-Option field returns error
        let mut model = UserModel {
            id: 1,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Attempting to set None for non-Option field should error
        let result = model.set(Column::Id, Value::Int(None));
        assert!(result.is_err(), "Setting None for non-Option field should error");
        
        // Verify error type
        match result {
            Err(lifeguard::ModelError::InvalidValueType { .. }) => (),
            _ => panic!("Expected InvalidValueType error"),
        }
    }

    #[test]
    fn test_model_trait_set_type_mismatch() {
        // Test various type mismatches
        let mut model = UserModel {
            id: 1,
            name: "Test".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Test i64 to i32 (should error)
        let result = model.set(Column::Id, Value::BigInt(Some(200)));
        assert!(result.is_err(), "Setting i64 value to i32 field should error");
        
        // Test String to i32 (should error)
        let result = model.set(Column::Id, Value::String(Some("invalid".to_string())));
        assert!(result.is_err(), "Setting String value to i32 field should error");
        
        // Test Bool to String (should error)
        let result = model.set(Column::Name, Value::Bool(Some(true)));
        assert!(result.is_err(), "Setting Bool value to String field should error");
    }

    #[test]
    fn test_model_trait_get_boolean() {
        // Test boolean type handling (if we had a bool field)
        // Note: User model doesn't have bool field, but this documents expected behavior
        let _model = UserModel {
            id: 1,
            name: "Test".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Boolean get() would return Value::Bool(Some(true/false))
        // This is handled in the macro generation
    }

    // ===== Option<T> Field Tests =====
    
    #[test]
    fn test_model_trait_option_get_none() {
        use option_tests::*;
        
        // Test getting None value from Option<T> field
        let model = UserWithOptionsModel {
            id: 1,
            name: None,
            age: None,
            active: None,
        };
        
        // Test Option<String> with None
        let name_value = model.get(Column::Name);
        match name_value {
            Value::String(None) => (),
            _ => panic!("Expected String(None) for None Option<String>, got {:?}", name_value),
        }
        
        // Test Option<i32> with None
        let age_value = model.get(Column::Age);
        match age_value {
            Value::Int(None) => (),
            _ => panic!("Expected Int(None) for None Option<i32>, got {:?}", age_value),
        }
        
        // Test Option<bool> with None
        let active_value = model.get(Column::Active);
        match active_value {
            Value::Bool(None) => (),
            _ => panic!("Expected Bool(None) for None Option<bool>, got {:?}", active_value),
        }
    }

    #[test]
    fn test_model_trait_option_get_some() {
        use option_tests::*;
        
        // Test getting Some value from Option<T> field
        let model = UserWithOptionsModel {
            id: 1,
            name: Some("Test User".to_string()),
            age: Some(30),
            active: Some(true),
        };
        
        // Test Option<String> with Some
        let name_value = model.get(Column::Name);
        match name_value {
            Value::String(Some(v)) => assert_eq!(v, "Test User"),
            _ => panic!("Expected String(Some(\"Test User\")), got {:?}", name_value),
        }
        
        // Test Option<i32> with Some
        let age_value = model.get(Column::Age);
        match age_value {
            Value::Int(Some(v)) => assert_eq!(v, 30),
            _ => panic!("Expected Int(Some(30)), got {:?}", age_value),
        }
        
        // Test Option<bool> with Some
        let active_value = model.get(Column::Active);
        match active_value {
            Value::Bool(Some(v)) => assert_eq!(v, true),
            _ => panic!("Expected Bool(Some(true)), got {:?}", active_value),
        }
    }

    #[test]
    fn test_model_trait_option_set_none() {
        use option_tests::*;
        
        // Test setting None value to Option<T> field
        let mut model = UserWithOptionsModel {
            id: 1,
            name: Some("Test User".to_string()),
            age: Some(30),
            active: Some(true),
        };
        
        // Set Option<String> to None
        let result = model.set(Column::Name, Value::String(None));
        assert!(result.is_ok());
        assert_eq!(model.name, None);
        
        // Set Option<i32> to None
        let result = model.set(Column::Age, Value::Int(None));
        assert!(result.is_ok());
        assert_eq!(model.age, None);
        
        // Set Option<bool> to None
        let result = model.set(Column::Active, Value::Bool(None));
        assert!(result.is_ok());
        assert_eq!(model.active, None);
    }

    #[test]
    fn test_model_trait_option_set_some() {
        use option_tests::*;
        
        // Test setting Some value to Option<T> field
        let mut model = UserWithOptionsModel {
            id: 1,
            name: None,
            age: None,
            active: None,
        };
        
        // Set Option<String> to Some
        let result = model.set(Column::Name, Value::String(Some("New Name".to_string())));
        assert!(result.is_ok());
        assert_eq!(model.name, Some("New Name".to_string()));
        
        // Set Option<i32> to Some
        let result = model.set(Column::Age, Value::Int(Some(25)));
        assert!(result.is_ok());
        assert_eq!(model.age, Some(25));
        
        // Set Option<bool> to Some
        let result = model.set(Column::Active, Value::Bool(Some(false)));
        assert!(result.is_ok());
        assert_eq!(model.active, Some(false));
    }

    // ===== JSON Field Tests =====
    
    #[test]
    fn test_model_trait_json_get() {
        use json_tests::*;
        
        // Test getting JSON value from serde_json::Value field
        let metadata = serde_json::json!({"key": "value", "number": 42});
        let model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: metadata.clone(),
            preferences: None,
        };
        
        // Test non-Option JSON field
        let metadata_value = model.get(Column::Metadata);
        match metadata_value {
            Value::Json(Some(v)) => {
                assert_eq!(*v, metadata);
            },
            _ => panic!("Expected Json(Some(_)), got {:?}", metadata_value),
        }
        
        // Test Option<JSON> with None
        let preferences_value = model.get(Column::Preferences);
        match preferences_value {
            Value::Json(None) => (),
            _ => panic!("Expected Json(None) for None Option<serde_json::Value>, got {:?}", preferences_value),
        }
    }

    #[test]
    fn test_model_trait_json_get_with_some() {
        use json_tests::*;
        
        // Test getting Some JSON value from Option<serde_json::Value> field
        let preferences = serde_json::json!({"theme": "dark", "notifications": true});
        let model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: Some(preferences.clone()),
        };
        
        let preferences_value = model.get(Column::Preferences);
        match preferences_value {
            Value::Json(Some(v)) => {
                assert_eq!(*v, preferences);
            },
            _ => panic!("Expected Json(Some(_)), got {:?}", preferences_value),
        }
    }

    #[test]
    fn test_model_trait_json_set() {
        use json_tests::*;
        
        // Test setting JSON value to serde_json::Value field
        let mut model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: None,
        };
        
        let new_metadata = serde_json::json!({"updated": true, "version": 2});
        
        // Set non-Option JSON field
        let result = model.set(
            Column::Metadata,
            Value::Json(Some(Box::new(new_metadata.clone())))
        );
        assert!(result.is_ok());
        assert_eq!(model.metadata, new_metadata);
    }

    #[test]
    fn test_model_trait_json_set_option_none() {
        use json_tests::*;
        
        // Test setting None to Option<serde_json::Value> field
        let mut model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: Some(serde_json::json!({"existing": true})),
        };
        
        let result = model.set(Column::Preferences, Value::Json(None));
        assert!(result.is_ok());
        assert_eq!(model.preferences, None);
    }

    #[test]
    fn test_model_trait_json_set_option_some() {
        use json_tests::*;
        
        // Test setting Some JSON to Option<serde_json::Value> field
        let mut model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: None,
        };
        
        let new_preferences = serde_json::json!({"theme": "light"});
        let result = model.set(
            Column::Preferences,
            Value::Json(Some(Box::new(new_preferences.clone())))
        );
        assert!(result.is_ok());
        assert_eq!(model.preferences, Some(new_preferences));
    }

    #[test]
    fn test_model_trait_json_set_invalid_type() {
        use json_tests::*;
        
        // Test that setting non-JSON value to JSON field returns error
        let mut model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: None,
        };
        
        // Attempting to set String to JSON field should error
        let result = model.set(
            Column::Metadata,
            Value::String(Some("invalid".to_string()))
        );
        assert!(result.is_err(), "Setting non-JSON value to JSON field should error");
    }

    // ===== Numeric Type Tests (Non-Option) =====
    
    #[test]
    fn test_model_trait_numeric_get() {
        use numeric_tests::*;
        
        // Test getting all numeric types from non-Option fields
        let model = NumericFieldsModel {
            id: 1,
            u8_field: 42,
            u16_field: 1000,
            u32_field: 100000,
            u64_field: 10000000000,
            f32_field: 3.14,
            f64_field: 2.71828,
        };
        
        // Test u8
        let u8_value = model.get(Column::U8Field);
        match u8_value {
            Value::SmallInt(Some(v)) => assert_eq!(v, 42i16),
            _ => panic!("Expected SmallInt(Some(42)), got {:?}", u8_value),
        }
        
        // Test u16
        let u16_value = model.get(Column::U16Field);
        match u16_value {
            Value::Int(Some(v)) => assert_eq!(v, 1000i32),
            _ => panic!("Expected Int(Some(1000)), got {:?}", u16_value),
        }
        
        // Test u32
        let u32_value = model.get(Column::U32Field);
        match u32_value {
            Value::BigInt(Some(v)) => assert_eq!(v, 100000i64),
            _ => panic!("Expected BigInt(Some(100000)), got {:?}", u32_value),
        }
        
        // Test u64
        let u64_value = model.get(Column::U64Field);
        match u64_value {
            Value::BigInt(Some(v)) => assert_eq!(v, 10000000000i64),
            _ => panic!("Expected BigInt(Some(10000000000)), got {:?}", u64_value),
        }
        
        // Test f32
        let f32_value = model.get(Column::F32Field);
        match f32_value {
            Value::Float(Some(v)) => assert!((v - 3.14).abs() < 0.001),
            _ => panic!("Expected Float(Some(3.14)), got {:?}", f32_value),
        }
        
        // Test f64
        let f64_value = model.get(Column::F64Field);
        match f64_value {
            Value::Double(Some(v)) => assert!((v - 2.71828).abs() < 0.00001),
            _ => panic!("Expected Double(Some(2.71828)), got {:?}", f64_value),
        }
    }

    #[test]
    fn test_model_trait_numeric_set() {
        use numeric_tests::*;
        
        // Test setting all numeric types to non-Option fields
        let mut model = NumericFieldsModel {
            id: 1,
            u8_field: 0,
            u16_field: 0,
            u32_field: 0,
            u64_field: 0,
            f32_field: 0.0,
            f64_field: 0.0,
        };
        
        // Test u8
        let result = model.set(Column::U8Field, Value::SmallInt(Some(42)));
        assert!(result.is_ok());
        assert_eq!(model.u8_field, 42);
        
        // Test u16
        let result = model.set(Column::U16Field, Value::Int(Some(1000)));
        assert!(result.is_ok());
        assert_eq!(model.u16_field, 1000);
        
        // Test u32
        let result = model.set(Column::U32Field, Value::BigInt(Some(100000)));
        assert!(result.is_ok());
        assert_eq!(model.u32_field, 100000);
        
        // Test u64
        let result = model.set(Column::U64Field, Value::BigInt(Some(10000000000)));
        assert!(result.is_ok());
        assert_eq!(model.u64_field, 10000000000);
        
        // Test f32
        let result = model.set(Column::F32Field, Value::Float(Some(3.14)));
        assert!(result.is_ok());
        assert!((model.f32_field - 3.14).abs() < 0.001);
        
        // Test f64
        let result = model.set(Column::F64Field, Value::Double(Some(2.71828)));
        assert!(result.is_ok());
        assert!((model.f64_field - 2.71828).abs() < 0.00001);
    }

    #[test]
    fn test_model_trait_numeric_set_null_error() {
        use numeric_tests::*;
        
        // Test that setting None value to non-Option numeric fields returns error
        let mut model = NumericFieldsModel {
            id: 1,
            u8_field: 42,
            u16_field: 1000,
            u32_field: 100000,
            u64_field: 10000000000,
            f32_field: 3.14,
            f64_field: 2.71828,
        };
        
        // All numeric types should error when setting None
        assert!(model.set(Column::U8Field, Value::SmallInt(None)).is_err());
        assert!(model.set(Column::U16Field, Value::Int(None)).is_err());
        assert!(model.set(Column::U32Field, Value::BigInt(None)).is_err());
        assert!(model.set(Column::U64Field, Value::BigInt(None)).is_err());
        assert!(model.set(Column::F32Field, Value::Float(None)).is_err());
        assert!(model.set(Column::F64Field, Value::Double(None)).is_err());
    }

    #[test]
    fn test_model_trait_numeric_set_type_mismatch() {
        use numeric_tests::*;
        
        // Test type mismatches for numeric fields
        let mut model = NumericFieldsModel {
            id: 1,
            u8_field: 0,
            u16_field: 0,
            u32_field: 0,
            u64_field: 0,
            f32_field: 0.0,
            f64_field: 0.0,
        };
        
        // Wrong type for u8 (should be SmallInt, not Int)
        assert!(model.set(Column::U8Field, Value::Int(Some(42))).is_err());
        
        // Wrong type for u16 (should be Int, not BigInt)
        assert!(model.set(Column::U16Field, Value::BigInt(Some(1000))).is_err());
        
        // Wrong type for f32 (should be Float, not Double)
        assert!(model.set(Column::F32Field, Value::Double(Some(3.14))).is_err());
        
        // Wrong type for f64 (should be Double, not Float)
        assert!(model.set(Column::F64Field, Value::Float(Some(2.71828))).is_err());
        
        // String to numeric (should error)
        assert!(model.set(Column::U8Field, Value::String(Some("invalid".to_string()))).is_err());
    }

    // ===== Numeric Type Tests (Option<T>) =====
    
    #[test]
    fn test_model_trait_option_numeric_get_none() {
        use option_numeric_tests::*;
        
        // Test getting None values from Option<T> numeric fields
        let model = OptionNumericFieldsModel {
            id: 1,
            u8_field: None,
            u16_field: None,
            u32_field: None,
            u64_field: None,
            f32_field: None,
            f64_field: None,
        };
        
        // All should return None variants
        match model.get(Column::U8Field) {
            Value::SmallInt(None) => (),
            _ => panic!("Expected SmallInt(None) for None Option<u8>"),
        }
        
        match model.get(Column::U16Field) {
            Value::Int(None) => (),
            _ => panic!("Expected Int(None) for None Option<u16>"),
        }
        
        match model.get(Column::U32Field) {
            Value::BigInt(None) => (),
            _ => panic!("Expected BigInt(None) for None Option<u32>"),
        }
        
        match model.get(Column::U64Field) {
            Value::BigInt(None) => (),
            _ => panic!("Expected BigInt(None) for None Option<u64>"),
        }
        
        match model.get(Column::F32Field) {
            Value::Float(None) => (),
            _ => panic!("Expected Float(None) for None Option<f32>"),
        }
        
        match model.get(Column::F64Field) {
            Value::Double(None) => (),
            _ => panic!("Expected Double(None) for None Option<f64>"),
        }
    }

    #[test]
    fn test_model_trait_option_numeric_get_some() {
        use option_numeric_tests::*;
        
        // Test getting Some values from Option<T> numeric fields
        let model = OptionNumericFieldsModel {
            id: 1,
            u8_field: Some(42),
            u16_field: Some(1000),
            u32_field: Some(100000),
            u64_field: Some(10000000000),
            f32_field: Some(3.14),
            f64_field: Some(2.71828),
        };
        
        // Test u8
        match model.get(Column::U8Field) {
            Value::SmallInt(Some(v)) => assert_eq!(v, 42i16),
            _ => panic!("Expected SmallInt(Some(42)) for Some(42) Option<u8>"),
        }
        
        // Test u16
        match model.get(Column::U16Field) {
            Value::Int(Some(v)) => assert_eq!(v, 1000i32),
            _ => panic!("Expected Int(Some(1000)) for Some(1000) Option<u16>"),
        }
        
        // Test u32
        match model.get(Column::U32Field) {
            Value::BigInt(Some(v)) => assert_eq!(v, 100000i64),
            _ => panic!("Expected BigInt(Some(100000)) for Some(100000) Option<u32>"),
        }
        
        // Test u64
        match model.get(Column::U64Field) {
            Value::BigInt(Some(v)) => assert_eq!(v, 10000000000i64),
            _ => panic!("Expected BigInt(Some(10000000000)) for Some(10000000000) Option<u64>"),
        }
        
        // Test f32
        match model.get(Column::F32Field) {
            Value::Float(Some(v)) => assert!((v - 3.14).abs() < 0.001),
            _ => panic!("Expected Float(Some(3.14)) for Some(3.14) Option<f32>"),
        }
        
        // Test f64
        match model.get(Column::F64Field) {
            Value::Double(Some(v)) => assert!((v - 2.71828).abs() < 0.00001),
            _ => panic!("Expected Double(Some(2.71828)) for Some(2.71828) Option<f64>"),
        }
    }

    #[test]
    fn test_model_trait_option_numeric_set_none() {
        use option_numeric_tests::*;
        
        // Test setting None values to Option<T> numeric fields
        let mut model = OptionNumericFieldsModel {
            id: 1,
            u8_field: Some(42),
            u16_field: Some(1000),
            u32_field: Some(100000),
            u64_field: Some(10000000000),
            f32_field: Some(3.14),
            f64_field: Some(2.71828),
        };
        
        // All should accept None and set field to None
        assert!(model.set(Column::U8Field, Value::SmallInt(None)).is_ok());
        assert_eq!(model.u8_field, None);
        
        assert!(model.set(Column::U16Field, Value::Int(None)).is_ok());
        assert_eq!(model.u16_field, None);
        
        assert!(model.set(Column::U32Field, Value::BigInt(None)).is_ok());
        assert_eq!(model.u32_field, None);
        
        assert!(model.set(Column::U64Field, Value::BigInt(None)).is_ok());
        assert_eq!(model.u64_field, None);
        
        assert!(model.set(Column::F32Field, Value::Float(None)).is_ok());
        assert_eq!(model.f32_field, None);
        
        assert!(model.set(Column::F64Field, Value::Double(None)).is_ok());
        assert_eq!(model.f64_field, None);
    }

    #[test]
    fn test_model_trait_option_numeric_set_some() {
        use option_numeric_tests::*;
        
        // Test setting Some values to Option<T> numeric fields
        let mut model = OptionNumericFieldsModel {
            id: 1,
            u8_field: None,
            u16_field: None,
            u32_field: None,
            u64_field: None,
            f32_field: None,
            f64_field: None,
        };
        
        // Test u8
        assert!(model.set(Column::U8Field, Value::SmallInt(Some(42))).is_ok());
        assert_eq!(model.u8_field, Some(42));
        
        // Test u16
        assert!(model.set(Column::U16Field, Value::Int(Some(1000))).is_ok());
        assert_eq!(model.u16_field, Some(1000));
        
        // Test u32
        assert!(model.set(Column::U32Field, Value::BigInt(Some(100000))).is_ok());
        assert_eq!(model.u32_field, Some(100000));
        
        // Test u64
        assert!(model.set(Column::U64Field, Value::BigInt(Some(10000000000))).is_ok());
        assert_eq!(model.u64_field, Some(10000000000));
        
        // Test f32
        assert!(model.set(Column::F32Field, Value::Float(Some(3.14))).is_ok());
        assert!(model.f32_field.map(|v| (v - 3.14).abs() < 0.001).unwrap_or(false));
        
        // Test f64
        assert!(model.set(Column::F64Field, Value::Double(Some(2.71828))).is_ok());
        assert!(model.f64_field.map(|v| (v - 2.71828).abs() < 0.00001).unwrap_or(false));
    }

    #[test]
    fn test_model_trait_option_numeric_set_type_mismatch() {
        use option_numeric_tests::*;
        
        // Test type mismatches for Option<T> numeric fields
        let mut model = OptionNumericFieldsModel {
            id: 1,
            u8_field: None,
            u16_field: None,
            u32_field: None,
            u64_field: None,
            f32_field: None,
            f64_field: None,
        };
        
        // Wrong type for u8 (should be SmallInt, not Int)
        assert!(model.set(Column::U8Field, Value::Int(Some(42))).is_err());
        
        // Wrong type for u16 (should be Int, not BigInt)
        assert!(model.set(Column::U16Field, Value::BigInt(Some(1000))).is_err());
        
        // Wrong type for f32 (should be Float, not Double)
        assert!(model.set(Column::F32Field, Value::Double(Some(3.14))).is_err());
        
        // Wrong type for f64 (should be Double, not Float)
        assert!(model.set(Column::F64Field, Value::Float(Some(2.71828))).is_err());
        
        // String to numeric (should error)
        assert!(model.set(Column::U8Field, Value::String(Some("invalid".to_string()))).is_err());
    }
}

// ============================================================================
// ACTIVEMODEL TRAIT TESTS
// ============================================================================

#[cfg(test)]
mod active_model_trait_tests {
    use super::*;
    use lifeguard::{ActiveModelTrait, LifeModelTrait};

    #[test]
    fn test_active_model_trait_get() {
        // Test that ActiveModelTrait::get() works
        // Note: get() uses to_model() internally, which requires all non-nullable fields to be set
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Get values using ActiveModelTrait
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some(), "Name should be set");
        
        let email_value = record.get(<Entity as LifeModelTrait>::Column::Email);
        assert!(email_value.is_some(), "Email should be set");
        
        let id_value = record.get(<Entity as LifeModelTrait>::Column::Id);
        assert!(id_value.is_some(), "Id should be set");
    }

    #[test]
    fn test_active_model_trait_take() {
        // Test that ActiveModelTrait::take() works
        // Note: take() uses to_model() internally, which requires all non-nullable fields to be set
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Take the value
        let name_value = record.take(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some(), "Name should be returned");
        
        // After take, the field should be None (but get() will still work with remaining fields)
        // Note: get() will fail if we try to get the taken field because to_model() requires all fields
        // This is a limitation of the current implementation
    }

    #[test]
    fn test_active_model_trait_reset() {
        // Test that ActiveModelTrait::reset() works
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Verify fields are set using dirty_fields() (get() requires all fields to be set)
        assert!(record.dirty_fields().contains(&"id".to_string()));
        assert!(record.dirty_fields().contains(&"name".to_string()));
        assert!(record.dirty_fields().contains(&"email".to_string()));
        
        // Reset all fields
        record.reset();
        
        // Verify all fields are now None using dirty_fields()
        assert!(record.dirty_fields().is_empty(), "All fields should be reset");
    }

    #[test]
    fn test_active_model_trait_set_placeholder() {
        // Test that ActiveModelTrait::set() returns an error (not yet implemented)
        let mut record = UserRecord::new();
        let result = record.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(Some("John".to_string())));
        assert!(result.is_err(), "set() should return an error (not yet fully implemented)");
    }
}
