//! Minimal test for LifeModel derive macro
//!
//! This test verifies the basic flow:
//! 1. LifeModel generates Entity, Model, Column, PrimaryKey, FromRow
//! 2. DeriveEntity (nested) generates LifeModelTrait
//! 3. All generated code compiles and works together

use lifeguard_derive::{LifeModel, LifeRecord};

// Simple user entity for testing
#[derive(LifeModel, LifeRecord)]
#[table_name = "users"]
pub struct User {
    #[primary_key]
    pub id: i32,
    pub name: String,
    pub email: String,
}

// Entity with Option fields for testing Option<T> edge cases
// Using a module to avoid name conflicts
mod option_tests {
    
    #[derive(LifeModel, LifeRecord)]
    #[table_name = "users_with_options"]
    pub struct UserWithOptions {
        #[primary_key]
        pub id: i32,
        pub name: Option<String>,
        pub age: Option<i32>,
        pub active: Option<bool>,
    }
}

// Entity with column_name attributes to test JSON roundtrip with renamed columns
// This verifies that to_json() and from_json() use the same key names
mod column_name_tests {
    
    #[derive(LifeModel, LifeRecord)]
    #[table_name = "users_with_renamed_columns"]
    pub struct UserWithRenamedColumns {
        #[primary_key]
        pub id: i32,
        #[column_name = "user_name"]
        pub firstName: String,  // Field name is camelCase, column is snake_case
        #[column_name = "email_address"]
        pub email: String,  // Field name matches column name pattern but column is explicitly renamed
    }
}

// Entity with numeric fields for testing all numeric types
// Using a module to avoid name conflicts
// NOTE: may_postgres doesn't support u8, u16, u64 in FromSql, so we manually implement ModelTrait
// This allows us to test get() and set() operations without needing FromRow
mod numeric_tests {
    
    // Manual model for numeric testing (bypasses FromRow requirement)
    #[derive(Debug, Clone)]
    pub struct NumericFieldsModel {
        pub id: i32,
        pub u8_field: u8,
        pub u16_field: u16,
        pub u32_field: u32,
        pub u64_field: u64,
        pub f32_field: f32,
        pub f64_field: f64,
    }
    
    // Manual Column enum for numeric testing
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum Column {
        Id,
        U8Field,
        U16Field,
        U32Field,
        U64Field,
        F32Field,
        F64Field,
    }
    
    impl sea_query::Iden for Column {
        fn unquoted(&self) -> &str {
            match self {
                Column::Id => "id",
                Column::U8Field => "u8_field",
                Column::U16Field => "u16_field",
                Column::U32Field => "u32_field",
                Column::U64Field => "u64_field",
                Column::F32Field => "f32_field",
                Column::F64Field => "f64_field",
            }
        }
    }
    
    impl sea_query::IdenStatic for Column {
        fn as_str(&self) -> &'static str {
            match self {
                Column::Id => "id",
                Column::U8Field => "u8_field",
                Column::U16Field => "u16_field",
                Column::U32Field => "u32_field",
                Column::U64Field => "u64_field",
                Column::F32Field => "f32_field",
                Column::F64Field => "f64_field",
            }
        }
    }
    
    // Manual Entity for numeric testing
    #[derive(Copy, Clone, Debug, Default)]
    pub struct Entity;
    
    impl lifeguard::LifeEntityName for Entity {
        fn table_name(&self) -> &'static str {
            "numeric_fields"
        }
    }
    
    impl lifeguard::LifeModelTrait for Entity {
        type Model = NumericFieldsModel;
        type Column = Column;
    }
    
    // Manual ModelTrait implementation for numeric testing
    // This uses the same logic that would be generated by the macro
    impl lifeguard::ModelTrait for NumericFieldsModel {
        type Entity = Entity;
        
        fn get(&self, column: Column) -> sea_query::Value {
            match column {
                Column::Id => sea_query::Value::Int(Some(self.id)),
                Column::U8Field => sea_query::Value::SmallInt(Some(self.u8_field as i16)),
                Column::U16Field => sea_query::Value::Int(Some(self.u16_field as i32)),
                Column::U32Field => sea_query::Value::BigInt(Some(self.u32_field as i64)),
                Column::U64Field => sea_query::Value::BigInt(Some(self.u64_field as i64)),
                Column::F32Field => sea_query::Value::Float(Some(self.f32_field)),
                Column::F64Field => sea_query::Value::Double(Some(self.f64_field)),
            }
        }
        
        fn set(
            &mut self,
            column: Column,
            value: sea_query::Value,
        ) -> Result<(), lifeguard::ModelError> {
            match column {
                Column::Id => match value {
                    sea_query::Value::Int(Some(v)) => {
                        self.id = v;
                        Ok(())
                    }
                    sea_query::Value::Int(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int(Some(_))".to_string(),
                        actual: "Int(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U8Field => match value {
                    sea_query::Value::SmallInt(Some(v)) => {
                        if v < 0 || v > 255 {
                            return Err(lifeguard::ModelError::InvalidValueType {
                                column: "U8Field".to_string(),
                                expected: "SmallInt in range 0..=255".to_string(),
                                actual: format!("SmallInt({})", v),
                            });
                        }
                        self.u8_field = v as u8;
                        Ok(())
                    }
                    sea_query::Value::SmallInt(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U8Field".to_string(),
                        expected: "SmallInt(Some(_))".to_string(),
                        actual: "SmallInt(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U8Field".to_string(),
                        expected: "SmallInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U16Field => match value {
                    sea_query::Value::Int(Some(v)) => {
                        if v < 0 || v > 65535 {
                            return Err(lifeguard::ModelError::InvalidValueType {
                                column: "U16Field".to_string(),
                                expected: "Int in range 0..=65535".to_string(),
                                actual: format!("Int({})", v),
                            });
                        }
                        self.u16_field = v as u16;
                        Ok(())
                    }
                    sea_query::Value::Int(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U16Field".to_string(),
                        expected: "Int(Some(_))".to_string(),
                        actual: "Int(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U16Field".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U32Field => match value {
                    sea_query::Value::BigInt(Some(v)) => {
                        if v < 0 || v > 4294967295 {
                            return Err(lifeguard::ModelError::InvalidValueType {
                                column: "U32Field".to_string(),
                                expected: "BigInt in range 0..=4294967295".to_string(),
                                actual: format!("BigInt({})", v),
                            });
                        }
                        self.u32_field = v as u32;
                        Ok(())
                    }
                    sea_query::Value::BigInt(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U32Field".to_string(),
                        expected: "BigInt(Some(_))".to_string(),
                        actual: "BigInt(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U32Field".to_string(),
                        expected: "BigInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U64Field => match value {
                    sea_query::Value::BigInt(Some(v)) => {
                        self.u64_field = v as u64;
                        Ok(())
                    }
                    sea_query::Value::BigInt(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U64Field".to_string(),
                        expected: "BigInt(Some(_))".to_string(),
                        actual: "BigInt(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U64Field".to_string(),
                        expected: "BigInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::F32Field => match value {
                    sea_query::Value::Float(Some(v)) => {
                        self.f32_field = v;
                        Ok(())
                    }
                    sea_query::Value::Float(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F32Field".to_string(),
                        expected: "Float(Some(_))".to_string(),
                        actual: "Float(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F32Field".to_string(),
                        expected: "Float".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::F64Field => match value {
                    sea_query::Value::Double(Some(v)) => {
                        self.f64_field = v;
                        Ok(())
                    }
                    sea_query::Value::Double(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F64Field".to_string(),
                        expected: "Double(Some(_))".to_string(),
                        actual: "Double(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F64Field".to_string(),
                        expected: "Double".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
            }
        }
        
        fn get_primary_key_value(&self) -> sea_query::Value {
            sea_query::Value::Int(Some(self.id))
        }
        
        fn get_primary_key_identity(&self) -> lifeguard::Identity {
            use sea_query::IdenStatic;
            lifeguard::Identity::Unary(sea_query::DynIden::from(Column::Id.as_str()))
        }
        
        fn get_primary_key_values(&self) -> Vec<sea_query::Value> {
            vec![sea_query::Value::Int(Some(self.id))]
        }
    }
}

// Entity with Option numeric fields for testing Option<T> numeric types
mod option_numeric_tests {
    
    // Manual model for Option numeric testing (bypasses FromRow requirement)
    #[derive(Debug, Clone)]
    pub struct OptionNumericFieldsModel {
        pub id: i32,
        pub u8_field: Option<u8>,
        pub u16_field: Option<u16>,
        pub u32_field: Option<u32>,
        pub u64_field: Option<u64>,
        pub f32_field: Option<f32>,
        pub f64_field: Option<f64>,
    }
    
    // Manual Column enum for Option numeric testing
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum Column {
        Id,
        U8Field,
        U16Field,
        U32Field,
        U64Field,
        F32Field,
        F64Field,
    }
    
    impl sea_query::Iden for Column {
        fn unquoted(&self) -> &str {
            match self {
                Column::Id => "id",
                Column::U8Field => "u8_field",
                Column::U16Field => "u16_field",
                Column::U32Field => "u32_field",
                Column::U64Field => "u64_field",
                Column::F32Field => "f32_field",
                Column::F64Field => "f64_field",
            }
        }
    }
    
    impl sea_query::IdenStatic for Column {
        fn as_str(&self) -> &'static str {
            match self {
                Column::Id => "id",
                Column::U8Field => "u8_field",
                Column::U16Field => "u16_field",
                Column::U32Field => "u32_field",
                Column::U64Field => "u64_field",
                Column::F32Field => "f32_field",
                Column::F64Field => "f64_field",
            }
        }
    }
    
    // Manual Entity for Option numeric testing
    #[derive(Copy, Clone, Debug, Default)]
    pub struct Entity;
    
    impl lifeguard::LifeEntityName for Entity {
        fn table_name(&self) -> &'static str {
            "option_numeric_fields"
        }
    }
    
    impl lifeguard::LifeModelTrait for Entity {
        type Model = OptionNumericFieldsModel;
        type Column = Column;
    }
    
    // Manual ModelTrait implementation for Option numeric testing
    // This uses the same logic that would be generated by the macro
    impl lifeguard::ModelTrait for OptionNumericFieldsModel {
        type Entity = Entity;
        
        fn get(&self, column: Column) -> sea_query::Value {
            match column {
                Column::Id => sea_query::Value::Int(Some(self.id)),
                Column::U8Field => self.u8_field.map(|v| sea_query::Value::SmallInt(Some(v as i16))).unwrap_or(sea_query::Value::SmallInt(None)),
                Column::U16Field => self.u16_field.map(|v| sea_query::Value::Int(Some(v as i32))).unwrap_or(sea_query::Value::Int(None)),
                Column::U32Field => self.u32_field.map(|v| sea_query::Value::BigInt(Some(v as i64))).unwrap_or(sea_query::Value::BigInt(None)),
                Column::U64Field => self.u64_field.map(|v| sea_query::Value::BigInt(Some(v as i64))).unwrap_or(sea_query::Value::BigInt(None)),
                Column::F32Field => self.f32_field.map(|v| sea_query::Value::Float(Some(v))).unwrap_or(sea_query::Value::Float(None)),
                Column::F64Field => self.f64_field.map(|v| sea_query::Value::Double(Some(v))).unwrap_or(sea_query::Value::Double(None)),
            }
        }
        
        fn set(
            &mut self,
            column: Column,
            value: sea_query::Value,
        ) -> Result<(), lifeguard::ModelError> {
            match column {
                Column::Id => match value {
                    sea_query::Value::Int(Some(v)) => {
                        self.id = v;
                        Ok(())
                    }
                    sea_query::Value::Int(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int(Some(_))".to_string(),
                        actual: "Int(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U8Field => match value {
                    sea_query::Value::SmallInt(Some(v)) => {
                        if v < 0 || v > 255 {
                            return Err(lifeguard::ModelError::InvalidValueType {
                                column: "U8Field".to_string(),
                                expected: "SmallInt in range 0..=255".to_string(),
                                actual: format!("SmallInt({})", v),
                            });
                        }
                        self.u8_field = Some(v as u8);
                        Ok(())
                    }
                    sea_query::Value::SmallInt(None) => {
                        self.u8_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U8Field".to_string(),
                        expected: "SmallInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U16Field => match value {
                    sea_query::Value::Int(Some(v)) => {
                        if v < 0 || v > 65535 {
                            return Err(lifeguard::ModelError::InvalidValueType {
                                column: "U16Field".to_string(),
                                expected: "Int in range 0..=65535".to_string(),
                                actual: format!("Int({})", v),
                            });
                        }
                        self.u16_field = Some(v as u16);
                        Ok(())
                    }
                    sea_query::Value::Int(None) => {
                        self.u16_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U16Field".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U32Field => match value {
                    sea_query::Value::BigInt(Some(v)) => {
                        if v < 0 || v > 4294967295 {
                            return Err(lifeguard::ModelError::InvalidValueType {
                                column: "U32Field".to_string(),
                                expected: "BigInt in range 0..=4294967295".to_string(),
                                actual: format!("BigInt({})", v),
                            });
                        }
                        self.u32_field = Some(v as u32);
                        Ok(())
                    }
                    sea_query::Value::BigInt(None) => {
                        self.u32_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U32Field".to_string(),
                        expected: "BigInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::U64Field => match value {
                    sea_query::Value::BigInt(Some(v)) => {
                        self.u64_field = Some(v as u64);
                        Ok(())
                    }
                    sea_query::Value::BigInt(None) => {
                        self.u64_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "U64Field".to_string(),
                        expected: "BigInt".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::F32Field => match value {
                    sea_query::Value::Float(Some(v)) => {
                        self.f32_field = Some(v);
                        Ok(())
                    }
                    sea_query::Value::Float(None) => {
                        self.f32_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F32Field".to_string(),
                        expected: "Float".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::F64Field => match value {
                    sea_query::Value::Double(Some(v)) => {
                        self.f64_field = Some(v);
                        Ok(())
                    }
                    sea_query::Value::Double(None) => {
                        self.f64_field = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "F64Field".to_string(),
                        expected: "Double".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
            }
        }
        
        fn get_primary_key_value(&self) -> sea_query::Value {
            sea_query::Value::Int(Some(self.id))
        }
        
        fn get_primary_key_identity(&self) -> lifeguard::Identity {
            use sea_query::IdenStatic;
            lifeguard::Identity::Unary(sea_query::DynIden::from(Column::Id.as_str()))
        }
        
        fn get_primary_key_values(&self) -> Vec<sea_query::Value> {
            vec![sea_query::Value::Int(Some(self.id))]
        }
    }
}

// Entity with JSON field for testing JSON edge cases
// Using a module to avoid name conflicts
// NOTE: JSON fields require special FromRow handling (deserialize from text/JSONB)
// For now, we'll test JSON in get/set operations using manual model construction
mod json_tests {
    
    // Note: We can't use LifeModel derive for JSON fields yet because FromRow needs
    // special handling to deserialize JSON from database text/JSONB columns.
    // For testing get/set operations, we'll manually construct the model.
    
    // Manual model for JSON testing (bypasses FromRow requirement)
    #[derive(Debug, Clone)]
    pub struct UserWithJsonModel {
        pub id: i32,
        pub name: String,
        pub metadata: serde_json::Value,
        pub preferences: Option<serde_json::Value>,
    }
    
    // Manual Column enum for JSON testing
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum Column {
        Id,
        Name,
        Metadata,
        Preferences,
    }
    
    impl sea_query::Iden for Column {
        fn unquoted(&self) -> &str {
            match self {
                Column::Id => "id",
                Column::Name => "name",
                Column::Metadata => "metadata",
                Column::Preferences => "preferences",
            }
        }
    }
    
    impl sea_query::IdenStatic for Column {
        fn as_str(&self) -> &'static str {
            match self {
                Column::Id => "id",
                Column::Name => "name",
                Column::Metadata => "metadata",
                Column::Preferences => "preferences",
            }
        }
    }
    
    // Manual Entity for JSON testing
    #[derive(Copy, Clone, Debug, Default)]
    pub struct Entity;
    
    impl lifeguard::LifeEntityName for Entity {
        fn table_name(&self) -> &'static str {
            "users_with_json"
        }
    }
    
    impl lifeguard::LifeModelTrait for Entity {
        type Model = UserWithJsonModel;
        type Column = Column;
    }
    
    // Manual ModelTrait implementation for JSON testing
    impl lifeguard::ModelTrait for UserWithJsonModel {
        type Entity = Entity;
        
        fn get(&self, column: Column) -> sea_query::Value {
            match column {
                Column::Id => sea_query::Value::Int(Some(self.id)),
                Column::Name => sea_query::Value::String(Some(self.name.clone())),
                Column::Metadata => sea_query::Value::Json(Some(Box::new(self.metadata.clone()))),
                Column::Preferences => match &self.preferences {
                    Some(v) => sea_query::Value::Json(Some(Box::new(v.clone()))),
                    None => sea_query::Value::Json(None),
                },
            }
        }
        
        fn set(
            &mut self,
            column: Column,
            value: sea_query::Value,
        ) -> Result<(), lifeguard::ModelError> {
            match column {
                Column::Id => match value {
                    sea_query::Value::Int(Some(v)) => {
                        self.id = v;
                        Ok(())
                    }
                    sea_query::Value::Int(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int(Some(_))".to_string(),
                        actual: "Int(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Id".to_string(),
                        expected: "Int".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::Name => match value {
                    sea_query::Value::String(Some(v)) => {
                        self.name = v;
                        Ok(())
                    }
                    sea_query::Value::String(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Name".to_string(),
                        expected: "String(Some(_))".to_string(),
                        actual: "String(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Name".to_string(),
                        expected: "String".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::Metadata => match value {
                    sea_query::Value::Json(Some(v)) => {
                        self.metadata = *v;
                        Ok(())
                    }
                    sea_query::Value::Json(None) => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Metadata".to_string(),
                        expected: "Json(Some(_))".to_string(),
                        actual: "Json(None)".to_string(),
                    }),
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Metadata".to_string(),
                        expected: "Json".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
                Column::Preferences => match value {
                    sea_query::Value::Json(Some(v)) => {
                        self.preferences = Some(*v);
                        Ok(())
                    }
                    sea_query::Value::Json(None) => {
                        self.preferences = None;
                        Ok(())
                    }
                    _ => Err(lifeguard::ModelError::InvalidValueType {
                        column: "Preferences".to_string(),
                        expected: "Json".to_string(),
                        actual: format!("{:?}", value),
                    }),
                },
            }
        }
        
        fn get_primary_key_value(&self) -> sea_query::Value {
            sea_query::Value::Int(Some(self.id))
        }
        
        fn get_primary_key_identity(&self) -> lifeguard::Identity {
            use sea_query::IdenStatic;
            lifeguard::Identity::Unary(sea_query::DynIden::from(Column::Id.as_str()))
        }
        
        fn get_primary_key_values(&self) -> Vec<sea_query::Value> {
            vec![sea_query::Value::Int(Some(self.id))]
        }
    }
}

#[cfg(test)]
mod tests {
    use sea_query::Value;

    #[test]
    fn test_entity_exists() {
        // Verify Entity unit struct exists and implements required traits
        let entity = Entity;
        
        // Test LifeEntityName
        assert_eq!(entity.table_name(), "users");
        assert_eq!(Entity::default().table_name(), "users");
        
        // Test Default
        let _default_entity = Entity::default();
    }

    #[test]
    fn test_column_enum_exists() {
        // Verify Column enum exists and implements Iden
        use sea_query::Iden;
        
        assert_eq!(Column::Id.unquoted(), "id");
        assert_eq!(Column::Name.unquoted(), "name");
        assert_eq!(Column::Email.unquoted(), "email");
    }

    #[test]
    fn test_primary_key_enum_exists() {
        // Verify PrimaryKey enum exists
        let _pk = PrimaryKey::Id;
    }

    #[test]
    fn test_primary_key_trait_value_type() {
        // Verify PrimaryKeyTrait is implemented and ValueType is correct
        use lifeguard::PrimaryKeyTrait;
        
        // ValueType should be i32 for User entity
        let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i32;
    }

    #[test]
    fn test_primary_key_trait_auto_increment() {
        // Verify auto_increment() method works
        use lifeguard::PrimaryKeyTrait;
        
        let pk = PrimaryKey::Id;
        // User entity doesn't have #[auto_increment], so should return false
        assert_eq!(pk.auto_increment(), false);
    }

    #[test]
    fn test_primary_key_to_column() {
        // Verify PrimaryKeyToColumn is implemented and works correctly
        use lifeguard::PrimaryKeyToColumn;
        
        let pk = PrimaryKey::Id;
        let col = pk.to_column();
        
        // Should convert to Column::Id
        assert_eq!(col, Column::Id);
    }

    // ============================================================================
    // PRIMARY KEY TRAIT EDGE CASE TESTS
    // ============================================================================

    #[test]
    fn test_primary_key_trait_value_type_non_option() {
        // Test ValueType for non-Option primary key (i32)
        use lifeguard::PrimaryKeyTrait;
        
        // User entity has i32 primary key (non-Option)
        let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i32;
        // Should compile - ValueType should be i32, not Option<i32>
    }

    #[test]
    fn test_primary_key_trait_auto_increment_false() {
        // Test auto_increment() returns false when #[auto_increment] is not present
        use lifeguard::PrimaryKeyTrait;
        
        let pk = PrimaryKey::Id;
        // User entity doesn't have #[auto_increment] attribute
        assert_eq!(pk.auto_increment(), false, "Primary key without #[auto_increment] should return false");
    }

    #[test]
    fn test_primary_key_to_column_all_variants() {
        // Test that to_column() works for all PrimaryKey variants
        use lifeguard::PrimaryKeyToColumn;
        
        // User entity only has one primary key variant
        let pk = PrimaryKey::Id;
        let col = pk.to_column();
        assert_eq!(col, Column::Id, "PrimaryKey::Id should map to Column::Id");
    }

    #[test]
    fn test_primary_key_arity_single() {
        // Test that PrimaryKeyArityTrait is implemented and returns Single for single primary key
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};
        
        let arity = PrimaryKey::arity();
        assert_eq!(arity, PrimaryKeyArity::Single, "Single primary key should return Single arity");
    }

    #[test]
    fn test_primary_key_arity_granular_variants() {
        // Test that granular arity variants exist and can be used
        use lifeguard::PrimaryKeyArity;
        
        // Verify all variants exist
        let _single = PrimaryKeyArity::Single;
        let _tuple2 = PrimaryKeyArity::Tuple2;
        let _tuple3 = PrimaryKeyArity::Tuple3;
        let _tuple4 = PrimaryKeyArity::Tuple4;
        let _tuple5 = PrimaryKeyArity::Tuple5;
        let _tuple6plus = PrimaryKeyArity::Tuple6Plus;
    }

    // ============================================================================
    // PRIMARY KEY EDGE CASE TESTS
    // ============================================================================

    // Each entity is in its own module to avoid name conflicts with generated types
    mod option_pk_entity {
        use super::*;

        #[derive(LifeModel)]
        #[table_name = "test_option_pk"]
        pub struct OptionPrimaryKeyEntity {
            #[primary_key]
            pub id: Option<i32>,
            pub name: String,
        }

        #[test]
        fn test_option_primary_key_value_type() {
            // Test that Option<i32> primary key extracts inner type (i32) for ValueType
            // This is a critical edge case - ValueType should be i32, not Option<i32>
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i32;
            // Should compile - ValueType should be i32 (inner type), not Option<i32>
        }

        #[test]
        fn test_option_primary_key_auto_increment() {
            let pk = PrimaryKey::Id;
            assert_eq!(pk.auto_increment(), false);
        }

        #[test]
        fn test_option_primary_key_to_column() {
            let pk = PrimaryKey::Id;
            let col = pk.to_column();
            assert_eq!(col, Column::Id);
        }
    }

    mod i64_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        #[derive(LifeModel)]
        #[table_name = "test_i64_pk"]
        pub struct I64PrimaryKeyEntity {
            #[primary_key]
            pub id: i64,
            pub name: String,
        }

        #[test]
        fn test_i64_primary_key_value_type() {
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i64;
        }

        #[test]
        fn test_i64_primary_key_auto_increment() {
            let pk = PrimaryKey::Id;
            assert_eq!(pk.auto_increment(), false);
        }
    }

    mod string_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};
        #[table_name = "test_string_pk"]
        pub struct StringPrimaryKeyEntity {
            #[primary_key]
            pub id: String,
            pub name: String,
        }

        #[test]
        fn test_string_primary_key_value_type() {
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = "test".to_string();
        }

        #[test]
        fn test_string_primary_key_auto_increment() {
            let pk = PrimaryKey::Id;
            assert_eq!(pk.auto_increment(), false);
        }

        #[test]
        fn test_string_primary_key_to_column() {
            let pk = PrimaryKey::Id;
            let col = pk.to_column();
            assert_eq!(col, Column::Id);
        }
    }

    mod auto_inc_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};

        pub struct AutoIncrementPrimaryKeyEntity {
            #[primary_key]
            #[auto_increment]
            pub id: i32,
            pub name: String,
        }

        #[test]
        fn test_auto_increment_primary_key_true() {
            let pk = PrimaryKey::Id;
            assert_eq!(pk.auto_increment(), true, "Primary key with #[auto_increment] should return true");
        }

        #[test]
        fn test_auto_increment_primary_key_value_type() {
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = 42i32;
        }

        #[test]
        fn test_auto_increment_primary_key_to_column() {
            let pk = PrimaryKey::Id;
            let col = pk.to_column();
            assert_eq!(col, Column::Id);
        }
    }

    mod composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};

        #[derive(LifeModel)]
        #[table_name = "test_composite_pk"]
        pub struct CompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id2: i32,
            pub name: String,
        }

        #[test]
        fn test_composite_primary_key_value_type_tuple() {
            // ValueType should be a tuple for composite keys
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = (42i32, 43i32);
        }

        #[test]
        fn test_composite_primary_key_auto_increment() {
            // Both variants return their own auto_increment value (fixed!)
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.auto_increment(), false);
            assert_eq!(pk2.auto_increment(), false);
        }

        #[test]
        fn test_composite_primary_key_to_column() {
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.to_column(), Column::Id1);
            assert_eq!(pk2.to_column(), Column::Id2);
        }

        #[test]
        fn test_composite_primary_key_all_variants() {
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            let _col1 = pk1.to_column();
            let _col2 = pk2.to_column();
        }

        #[test]
        fn test_composite_primary_key_arity() {
            // Verify PrimaryKeyArityTrait is implemented and returns Tuple2 for 2-column composite keys
            use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};
            
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple2, "2-column composite primary key should return Tuple2 arity");
        }
    }

    mod mixed_auto_inc_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyTrait, PrimaryKeyToColumn};

        #[derive(LifeModel)]
        #[table_name = "test_mixed_auto_inc_pk"]
        pub struct MixedAutoIncrementCompositePrimaryKeyEntity {
            #[primary_key]
            #[auto_increment]
            pub id1: i32,
            #[primary_key]
            pub id2: i32, // No auto_increment
            pub name: String,
        }

        #[test]
        fn test_mixed_auto_increment_composite_primary_key() {
            // This test verifies the fix: each variant returns its own auto_increment value
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.auto_increment(), true, "Primary key with #[auto_increment] should return true");
            assert_eq!(pk2.auto_increment(), false, "Primary key without #[auto_increment] should return false");
        }

        #[test]
        fn test_mixed_auto_increment_composite_primary_key_to_column() {
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.to_column(), Column::Id1);
            assert_eq!(pk2.to_column(), Column::Id2);
        }

        #[test]
        fn test_mixed_auto_increment_composite_primary_key_arity() {
            // Verify PrimaryKeyArityTrait returns Tuple2 for 2-column composite keys
            use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};
            
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple2, "2-column composite primary key should return Tuple2 arity");
        }

        #[test]
        fn test_mixed_auto_increment_composite_primary_key_arity_with_auto_inc() {
            // EDGE CASE: Verify that PrimaryKeyArity works correctly with mixed auto_increment
            // This tests that arity is independent of auto_increment settings
            use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait, PrimaryKeyTrait};
            
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple2, "Arity should be Tuple2 regardless of auto_increment settings");
            
            // Verify auto_increment still works correctly per variant
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            assert_eq!(pk1.auto_increment(), true, "First key has auto_increment");
            assert_eq!(pk2.auto_increment(), false, "Second key does not have auto_increment");
        }
    }

    // ============================================================================
    // PRIMARY KEY ARITY EDGE CASE TESTS
    // ============================================================================

    mod tuple3_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_tuple3_composite_pk"]
        pub struct Tuple3CompositePrimaryKeyEntity {
            #[primary_key]
            pub id2: i32,
            #[primary_key]
            pub id3: i32,
            pub name: String,
        }

        #[test]
        fn test_tuple3_composite_primary_key_arity() {
            // Test that 3 primary keys return Tuple3
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple3, "3-column composite primary key should return Tuple3 arity");
        }
    }

    mod tuple4_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_tuple4_composite_pk"]
        pub struct Tuple4CompositePrimaryKeyEntity {
            #[primary_key]
            pub id2: i32,
            #[primary_key]
            pub id3: i32,
            #[primary_key]
            pub id4: i32,
            pub name: String,
        }

        #[test]
        fn test_tuple4_composite_primary_key_arity() {
            // Test that 4 primary keys return Tuple4
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple4, "4-column composite primary key should return Tuple4 arity");
        }
    }

    mod tuple5_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_tuple5_composite_pk"]
        pub struct Tuple5CompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id3: i32,
            #[primary_key]
            pub id4: i32,
            #[primary_key]
            pub id5: i32,
            pub name: String,
        }

        #[test]
        fn test_tuple5_composite_primary_key_arity() {
            // Test that 5 primary keys return Tuple5
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple5, "5-column composite primary key should return Tuple5 arity");
        }
    }

    mod tuple6plus_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_tuple6plus_composite_pk"]
        pub struct Tuple6PlusCompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id3: i32,
            #[primary_key]
            pub id4: i32,
            #[primary_key]
            pub id5: i32,
            #[primary_key]
            pub id6: i32,
            #[primary_key]
            pub id7: i32,
            pub name: String,
        }

        #[test]
        fn test_tuple6plus_composite_primary_key_arity() {
            // Test that 6+ primary keys return Tuple6Plus
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple6Plus, "6+ column composite primary key should return Tuple6Plus arity");
        }
    }

    mod large_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait};

        #[derive(LifeModel)]
        #[table_name = "test_large_composite_pk"]
        pub struct LargeCompositePrimaryKeyEntity {
            #[primary_key]
            pub id1: i32,
            #[primary_key]
            pub id2: i32,
            #[primary_key]
            pub id4: i32,
            pub name: String,
        }

        #[test]
        fn test_large_composite_primary_key_arity() {
            // Test that 4 primary keys return Tuple4
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple4, "4-column composite primary key should return Tuple4 arity");
        }

        #[test]
        fn test_large_composite_primary_key_all_variants() {
            // Verify all primary key variants work
            use lifeguard::PrimaryKeyToColumn;
            
            let pk1 = PrimaryKey::Id1;
            let pk2 = PrimaryKey::Id2;
            let pk3 = PrimaryKey::Id3;
            let pk4 = PrimaryKey::Id4;
            
            assert_eq!(pk1.to_column(), Column::Id1);
            assert_eq!(pk2.to_column(), Column::Id2);
            assert_eq!(pk3.to_column(), Column::Id3);
            assert_eq!(pk4.to_column(), Column::Id4);
        }

        #[test]
        fn test_large_composite_primary_key_value_type_tuple() {
            // Verify ValueType is a tuple for large composite keys (3+ columns)
            use lifeguard::PrimaryKeyTrait;
            
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = (1i32, 2i32, 3i32, 4i32);
        }
    }

    mod mixed_type_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::{PrimaryKeyArity, PrimaryKeyArityTrait, PrimaryKeyTrait};

        #[derive(LifeModel)]
        #[table_name = "test_mixed_type_composite_pk"]
        pub struct MixedTypeCompositePrimaryKeyEntity {
            #[primary_key]
            pub id: i32,
            #[primary_key]
            pub code: String,
            pub name: String,
        }

        #[test]
        fn test_mixed_type_composite_primary_key_arity() {
            // Test composite key with different types (i32 + String)
            let arity = PrimaryKey::arity();
            assert_eq!(arity, PrimaryKeyArity::Tuple2, "2-column mixed type composite primary key should return Tuple2 arity");
        }

        #[test]
        fn test_mixed_type_composite_primary_key_value_type_tuple() {
            // EDGE CASE: ValueType is now a tuple for composite keys
            // This verifies that ValueType is (i32, String) for composite keys with mixed types
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = (42i32, "test".to_string());
            // Note: This compiles because ValueType is (i32, String) - full tuple support!
        }

        #[test]
        fn test_mixed_type_composite_primary_key_to_column() {
            use lifeguard::PrimaryKeyToColumn;
            
            let pk1 = PrimaryKey::Id;
            let pk2 = PrimaryKey::Code;
            
            assert_eq!(pk1.to_column(), Column::Id);
            assert_eq!(pk2.to_column(), Column::Code);
        }
    }

    mod option_composite_pk_entity {
        use super::*;
        use lifeguard_derive::LifeModel;
        use lifeguard::PrimaryKeyTrait;

        #[derive(LifeModel)]
        #[table_name = "test_option_composite_pk"]
        pub struct OptionCompositePrimaryKeyEntity {
            #[primary_key]
            pub id: Option<i32>,
            #[primary_key]
            pub code: Option<String>,
            pub name: String,
        }
        fn test_option_composite_primary_key_value_type() {
            // EDGE CASE: Composite key with Option types - Option should be unwrapped in ValueType tuple
            // ValueType should be (i32, String), not (Option<i32>, Option<String>)
            let _value: <PrimaryKey as PrimaryKeyTrait>::ValueType = (42i32, "test".to_string());
        }
    }

    mod no_primary_key_entity {
        use lifeguard_derive::LifeModel;

        #[derive(LifeModel)]
        #[table_name = "test_no_pk"]
        pub struct NoPrimaryKeyEntity {
            pub name: String,
            pub email: String,
        }

        #[test]
        fn test_no_primary_key_enum_is_empty() {
            // EDGE CASE: Entity with no primary key
            // PrimaryKey enum is generated but empty (no variants)
            // This is a compile-time construct, so we can't easily test it at runtime
            // But we can verify that PrimaryKeyArityTrait is NOT implemented
            // (trying to call PrimaryKey::arity() would be a compile error)
            
            // The PrimaryKey enum exists but has no variants
            // PrimaryKeyArityTrait is not implemented (by design)
            // This is correct behavior - entities without primary keys don't need arity
        }

        #[test]
        fn test_no_primary_key_get_primary_key_value() {
            // EDGE CASE: get_primary_key_value() returns String(None) when no primary key exists
            use lifeguard::ModelTrait;
            
            let model = NoPrimaryKeyEntityModel {
                name: "Test".to_string(),
                email: "test@example.com".to_string(),
            };
            
            let pk_value = model.get_primary_key_value();
            // Should return Value::String(None) as documented
            assert_eq!(pk_value, sea_query::Value::String(None));
        }
    }

    #[test]
    fn test_model_struct_exists() {
        // Verify Model struct exists and can be instantiated
        let model = UserModel {
            id: 1,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        assert_eq!(model.id, 1);
        assert_eq!(model.name, "Test User");
        assert_eq!(model.email, "test@example.com");
    }

    #[test]
    fn test_from_row_trait_implemented() {
        // Verify FromRow trait is implemented for UserModel
        // We can't easily test the actual implementation without a real Row,
        // but we can verify the trait is implemented by checking it compiles
        fn _verify_from_row<T: FromRow>() {}
        _verify_from_row::<UserModel>();
    }

    #[test]
    fn test_life_model_trait_implemented() {
        // Verify LifeModelTrait is implemented for Entity
        // This is generated by DeriveEntity (nested expansion)
        fn _verify_life_model_trait<E: LifeModelTrait>() {}
        _verify_life_model_trait::<Entity>();
        
        // Verify the associated type Model is correct
        fn _verify_model_type<E: LifeModelTrait<Model = UserModel>>() {}
        _verify_model_type::<Entity>();
    }

    #[test]
    fn test_find_method_works() {
        // Verify Entity::find() returns SelectQuery
        // This tests the LifeModelTrait::find() method
        let _query = Entity::find();
        // Just verify it compiles - actual execution requires an executor
    }

    #[test]
    fn test_entity_table_name_constant() {
        // Verify Entity::TABLE_NAME constant exists
        assert_eq!(Entity::TABLE_NAME, "users");
    }

    #[test]
    fn test_model_trait_implemented() {
        // Verify ModelTrait is implemented for UserModel
        fn _verify_model_trait<M: ModelTrait>() {}
        _verify_model_trait::<UserModel>();
        
        // Verify the associated type Entity is correct
        fn _verify_entity_type<M: ModelTrait<Entity = Entity>>() {}
        _verify_entity_type::<UserModel>();
    }

    #[test]
    fn test_model_trait_get() {
        // Test ModelTrait::get() method
        let model = UserModel {
            id: 1,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Test getting id column
        let id_value = model.get(Column::Id);
        match id_value {
            Value::Int(Some(v)) => assert_eq!(v, 1),
            _ => panic!("Expected Int(Some(1)), got {:?}", id_value),
        }
        
        // Test getting name column
        let name_value = model.get(Column::Name);
        match name_value {
            Value::String(Some(v)) => assert_eq!(v, "Test User"),
            _ => panic!("Expected String(Some(\"Test User\")), got {:?}", name_value),
        }
        
        // Test getting email column
        let email_value = model.get(Column::Email);
        match email_value {
            Value::String(Some(v)) => assert_eq!(v, "test@example.com"),
            _ => panic!("Expected String(Some(\"test@example.com\")), got {:?}", email_value),
        }
    }

    #[test]
    fn test_model_trait_set() {
        // Test ModelTrait::set() method
        let mut model = UserModel {
            id: 1,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Test setting name column
        let result = model.set(Column::Name, Value::String(Some("Updated Name".to_string())));
        assert!(result.is_ok());
        assert_eq!(model.name, "Updated Name");
        
        // Test setting id column
        let result = model.set(Column::Id, Value::Int(Some(42)));
        assert!(result.is_ok());
        assert_eq!(model.id, 42);
        
        // Test setting email column
        let result = model.set(Column::Email, Value::String(Some("updated@example.com".to_string())));
        assert!(result.is_ok());
        assert_eq!(model.email, "updated@example.com");
        
        // Test invalid value type
        let result = model.set(Column::Id, Value::String(Some("invalid".to_string())));
        assert!(result.is_err());
    }

    #[test]
    fn test_model_trait_get_primary_key_value() {
        // Test ModelTrait::get_primary_key_value() method
        let model = UserModel {
            id: 123,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        let pk_value = model.get_primary_key_value();
        match pk_value {
            Value::Int(Some(v)) => assert_eq!(v, 123),
            _ => panic!("Expected Int(Some(123)), got {:?}", pk_value),
        }
    }

    #[test]
    fn test_model_trait_set_null_for_non_option() {
        // Test that setting None value for non-Option field returns error
        let mut model = UserModel {
            id: 1,
            name: "Test User".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Attempting to set None for non-Option field should error
        let result = model.set(Column::Id, Value::Int(None));
        assert!(result.is_err(), "Setting None for non-Option field should error");
        
        // Verify error type
        match result {
            Err(lifeguard::ModelError::InvalidValueType { .. }) => (),
            _ => panic!("Expected InvalidValueType error"),
        }
    }

    #[test]
    fn test_model_trait_set_type_mismatch() {
        // Test various type mismatches
        let mut model = UserModel {
            id: 1,
            name: "Test".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Test i64 to i32 (should error)
        let result = model.set(Column::Id, Value::BigInt(Some(200)));
        assert!(result.is_err(), "Setting i64 value to i32 field should error");
        
        // Test String to i32 (should error)
        let result = model.set(Column::Id, Value::String(Some("invalid".to_string())));
        assert!(result.is_err(), "Setting String value to i32 field should error");
        
        // Test Bool to String (should error)
        let result = model.set(Column::Name, Value::Bool(Some(true)));
        assert!(result.is_err(), "Setting Bool value to String field should error");
    }

    #[test]
    fn test_model_trait_get_boolean() {
        // Test boolean type handling (if we had a bool field)
        // Note: User model doesn't have bool field, but this documents expected behavior
        let _model = UserModel {
            id: 1,
            name: "Test".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // Boolean get() would return Value::Bool(Some(true/false))
        // This is handled in the macro generation
    }

    // ===== Option<T> Field Tests =====
    
    #[test]
    fn test_model_trait_option_get_none() {
        use super::option_tests::*;
        
        // Test getting None value from Option<T> field
        let model = UserWithOptionsModel {
            id: 1,
            name: None,
            age: None,
            active: None,
        };
        
        // Test Option<String> with None
        let name_value = model.get(Column::Name);
        match name_value {
            Value::String(None) => (),
            _ => panic!("Expected String(None) for None Option<String>, got {:?}", name_value),
        }
        
        // Test Option<i32> with None
        let age_value = model.get(Column::Age);
        match age_value {
            Value::Int(None) => (),
            _ => panic!("Expected Int(None) for None Option<i32>, got {:?}", age_value),
        }
        
        // Test Option<bool> with None
        let active_value = model.get(Column::Active);
        match active_value {
            Value::Bool(None) => (),
            _ => panic!("Expected Bool(None) for None Option<bool>, got {:?}", active_value),
        }
    }

    #[test]
    fn test_model_trait_option_get_some() {
        use super::option_tests::*;
        
        // Test getting Some value from Option<T> field
        let model = UserWithOptionsModel {
            id: 1,
            name: Some("Test User".to_string()),
            age: Some(30),
            active: Some(true),
        };
        
        // Test Option<String> with Some
        let name_value = model.get(Column::Name);
        match name_value {
            Value::String(Some(v)) => assert_eq!(v, "Test User"),
            _ => panic!("Expected String(Some(\"Test User\")), got {:?}", name_value),
        }
        
        // Test Option<i32> with Some
        let age_value = model.get(Column::Age);
        match age_value {
            Value::Int(Some(v)) => assert_eq!(v, 30),
            _ => panic!("Expected Int(Some(30)), got {:?}", age_value),
        }
        
        // Test Option<bool> with Some
        let active_value = model.get(Column::Active);
        match active_value {
            Value::Bool(Some(v)) => assert_eq!(v, true),
            _ => panic!("Expected Bool(Some(true)), got {:?}", active_value),
        }
    }

    #[test]
    fn test_model_trait_option_set_none() {
        use super::option_tests::*;
        
        // Test setting None value to Option<T> field
        let mut model = UserWithOptionsModel {
            id: 1,
            name: Some("Test User".to_string()),
            age: Some(30),
            active: Some(true),
        };
        
        // Set Option<String> to None
        let result = model.set(Column::Name, Value::String(None));
        assert!(result.is_ok());
        assert_eq!(model.name, None);
        
        // Set Option<i32> to None
        let result = model.set(Column::Age, Value::Int(None));
        assert!(result.is_ok());
        assert_eq!(model.age, None);
        
        // Set Option<bool> to None
        let result = model.set(Column::Active, Value::Bool(None));
        assert!(result.is_ok());
        assert_eq!(model.active, None);
    }

    #[test]
    fn test_model_trait_option_set_some() {
        use super::option_tests::*;
        
        // Test setting Some value to Option<T> field
        let mut model = UserWithOptionsModel {
            id: 1,
            name: None,
            age: None,
            active: None,
        };
        
        // Set Option<String> to Some
        let result = model.set(Column::Name, Value::String(Some("New Name".to_string())));
        assert!(result.is_ok());
        assert_eq!(model.name, Some("New Name".to_string()));
        
        // Set Option<i32> to Some
        let result = model.set(Column::Age, Value::Int(Some(25)));
        assert!(result.is_ok());
        assert_eq!(model.age, Some(25));
        
        // Set Option<bool> to Some
        let result = model.set(Column::Active, Value::Bool(Some(false)));
        assert!(result.is_ok());
        assert_eq!(model.active, Some(false));
    }

    // ===== JSON Field Tests =====
    
    #[test]
    fn test_model_trait_json_get() {
        use super::json_tests::*;
        
        // Test getting JSON value from serde_json::Value field
        let metadata = serde_json::json!({"key": "value", "number": 42});
        let model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: metadata.clone(),
            preferences: None,
        };
        
        // Test non-Option JSON field
        let metadata_value = model.get(Column::Metadata);
        match metadata_value {
            Value::Json(Some(v)) => {
                assert_eq!(*v, metadata);
            },
            _ => panic!("Expected Json(Some(_)), got {:?}", metadata_value),
        }
        
        // Test Option<JSON> with None
        let preferences_value = model.get(Column::Preferences);
        match preferences_value {
            Value::Json(None) => (),
            _ => panic!("Expected Json(None) for None Option<serde_json::Value>, got {:?}", preferences_value),
        }
    }

    #[test]
    fn test_model_trait_json_get_with_some() {
        use super::json_tests::*;
        
        // Test getting Some JSON value from Option<serde_json::Value> field
        let preferences = serde_json::json!({"theme": "dark", "notifications": true});
        let model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: Some(preferences.clone()),
        };
        
        let preferences_value = model.get(Column::Preferences);
        match preferences_value {
            Value::Json(Some(v)) => {
                assert_eq!(*v, preferences);
            },
            _ => panic!("Expected Json(Some(_)), got {:?}", preferences_value),
        }
    }

    #[test]
    fn test_model_trait_json_set() {
        use super::json_tests::*;
        
        // Test setting JSON value to serde_json::Value field
        let mut model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: None,
        };
        
        let new_metadata = serde_json::json!({"updated": true, "version": 2});
        
        // Set non-Option JSON field
        let result = model.set(
            Column::Metadata,
            Value::Json(Some(Box::new(new_metadata.clone())))
        );
        assert!(result.is_ok());
        assert_eq!(model.metadata, new_metadata);
    }

    #[test]
    fn test_model_trait_json_set_option_none() {
        use super::json_tests::*;
        
        // Test setting None to Option<serde_json::Value> field
        let mut model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: Some(serde_json::json!({"existing": true})),
        };
        
        let result = model.set(Column::Preferences, Value::Json(None));
        assert!(result.is_ok());
        assert_eq!(model.preferences, None);
    }

    #[test]
    fn test_model_trait_json_set_option_some() {
        use super::json_tests::*;
        
        // Test setting Some JSON to Option<serde_json::Value> field
        let mut model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: None,
        };
        
        let new_preferences = serde_json::json!({"theme": "light"});
        let result = model.set(
            Column::Preferences,
            Value::Json(Some(Box::new(new_preferences.clone())))
        );
        assert!(result.is_ok());
        assert_eq!(model.preferences, Some(new_preferences));
    }

    #[test]
    fn test_model_trait_json_set_invalid_type() {
        use super::json_tests::*;
        
        // Test that setting non-JSON value to JSON field returns error
        let mut model = UserWithJsonModel {
            id: 1,
            name: "Test User".to_string(),
            metadata: serde_json::json!({}),
            preferences: None,
        };
        
        // Attempting to set String to JSON field should error
        let result = model.set(
            Column::Metadata,
            Value::String(Some("invalid".to_string()))
        );
        assert!(result.is_err(), "Setting non-JSON value to JSON field should error");
    }

    // ===== Numeric Type Tests (Non-Option) =====
    
    #[test]
    fn test_model_trait_numeric_get() {
        use numeric_tests::*;
        
        // Test getting all numeric types from non-Option fields
        let model = NumericFieldsModel {
            id: 1,
            u8_field: 42,
            u16_field: 1000,
            u32_field: 100000,
            u64_field: 10000000000,
            f32_field: 3.14,
            f64_field: 2.71828,
        };
        
        // Test u8
        let u8_value = model.get(Column::U8Field);
        match u8_value {
            Value::SmallInt(Some(v)) => assert_eq!(v, 42i16),
            _ => panic!("Expected SmallInt(Some(42)), got {:?}", u8_value),
        }
        
        // Test u16
        let u16_value = model.get(Column::U16Field);
        match u16_value {
            Value::Int(Some(v)) => assert_eq!(v, 1000i32),
            _ => panic!("Expected Int(Some(1000)), got {:?}", u16_value),
        }
        
        // Test u32
        let u32_value = model.get(Column::U32Field);
        match u32_value {
            Value::BigInt(Some(v)) => assert_eq!(v, 100000i64),
            _ => panic!("Expected BigInt(Some(100000)), got {:?}", u32_value),
        }
        
        // Test u64
        let u64_value = model.get(Column::U64Field);
        match u64_value {
            Value::BigInt(Some(v)) => assert_eq!(v, 10000000000i64),
            _ => panic!("Expected BigInt(Some(10000000000)), got {:?}", u64_value),
        }
        
        // Test f32
        let f32_value = model.get(Column::F32Field);
        match f32_value {
            Value::Float(Some(v)) => assert!((v - 3.14).abs() < 0.001),
            _ => panic!("Expected Float(Some(3.14)), got {:?}", f32_value),
        }
        
        // Test f64
        let f64_value = model.get(Column::F64Field);
        match f64_value {
            Value::Double(Some(v)) => assert!((v - 2.71828).abs() < 0.00001),
            _ => panic!("Expected Double(Some(2.71828)), got {:?}", f64_value),
        }
    }

    #[test]
    fn test_model_trait_numeric_set() {
        use numeric_tests::*;
        
        // Test setting all numeric types to non-Option fields
        let mut model = NumericFieldsModel {
            id: 1,
            u8_field: 0,
            u16_field: 0,
            u32_field: 0,
            u64_field: 0,
            f32_field: 0.0,
            f64_field: 0.0,
        };
        
        // Test u8
        let result = model.set(Column::U8Field, Value::SmallInt(Some(42)));
        assert!(result.is_ok());
        assert_eq!(model.u8_field, 42);
        
        // Test u16
        let result = model.set(Column::U16Field, Value::Int(Some(1000)));
        assert!(result.is_ok());
        assert_eq!(model.u16_field, 1000);
        
        // Test u32
        let result = model.set(Column::U32Field, Value::BigInt(Some(100000)));
        assert!(result.is_ok());
        assert_eq!(model.u32_field, 100000);
        
        // Test u64
        let result = model.set(Column::U64Field, Value::BigInt(Some(10000000000)));
        assert!(result.is_ok());
        assert_eq!(model.u64_field, 10000000000);
        
        // Test f32
        let result = model.set(Column::F32Field, Value::Float(Some(3.14)));
        assert!(result.is_ok());
        assert!((model.f32_field - 3.14).abs() < 0.001);
        
        // Test f64
        let result = model.set(Column::F64Field, Value::Double(Some(2.71828)));
        assert!(result.is_ok());
        assert!((model.f64_field - 2.71828).abs() < 0.00001);
    }

    #[test]
    fn test_model_trait_numeric_set_null_error() {
        use numeric_tests::*;
        
        // Test that setting None value to non-Option numeric fields returns error
        let mut model = NumericFieldsModel {
            id: 1,
            u8_field: 42,
            u16_field: 1000,
            u32_field: 100000,
            u64_field: 10000000000,
            f32_field: 3.14,
            f64_field: 2.71828,
        };
        
        // All numeric types should error when setting None
        assert!(model.set(Column::U8Field, Value::SmallInt(None)).is_err());
        assert!(model.set(Column::U16Field, Value::Int(None)).is_err());
        assert!(model.set(Column::U32Field, Value::BigInt(None)).is_err());
        assert!(model.set(Column::U64Field, Value::BigInt(None)).is_err());
        assert!(model.set(Column::F32Field, Value::Float(None)).is_err());
        assert!(model.set(Column::F64Field, Value::Double(None)).is_err());
    }

    #[test]
    fn test_model_trait_numeric_set_type_mismatch() {
        use numeric_tests::*;
        
        // Test type mismatches for numeric fields
        let mut model = NumericFieldsModel {
            id: 1,
            u8_field: 0,
            u16_field: 0,
            u32_field: 0,
            u64_field: 0,
            f32_field: 0.0,
            f64_field: 0.0,
        };
        
        // Wrong type for u8 (should be SmallInt, not Int)
        assert!(model.set(Column::U8Field, Value::Int(Some(42))).is_err());
        
        // Wrong type for u16 (should be Int, not BigInt)
        assert!(model.set(Column::U16Field, Value::BigInt(Some(1000))).is_err());
        
        // Wrong type for f32 (should be Float, not Double)
        assert!(model.set(Column::F32Field, Value::Double(Some(3.14))).is_err());
        
        // Wrong type for f64 (should be Double, not Float)
        assert!(model.set(Column::F64Field, Value::Float(Some(2.71828))).is_err());
        
        // String to numeric (should error)
        assert!(model.set(Column::U8Field, Value::String(Some("invalid".to_string()))).is_err());
    }

    // ===== Numeric Type Tests (Option<T>) =====
    
    #[test]
    fn test_model_trait_option_numeric_get_none() {
        use option_numeric_tests::*;
        
        // Test getting None values from Option<T> numeric fields
        let model = OptionNumericFieldsModel {
            id: 1,
            u8_field: None,
            u16_field: None,
            u32_field: None,
            u64_field: None,
            f32_field: None,
            f64_field: None,
        };
        
        // All should return None variants
        match model.get(Column::U8Field) {
            Value::SmallInt(None) => (),
            _ => panic!("Expected SmallInt(None) for None Option<u8>"),
        }
        
        match model.get(Column::U16Field) {
            Value::Int(None) => (),
            _ => panic!("Expected Int(None) for None Option<u16>"),
        }
        
        match model.get(Column::U32Field) {
            Value::BigInt(None) => (),
            _ => panic!("Expected BigInt(None) for None Option<u32>"),
        }
        
        match model.get(Column::U64Field) {
            Value::BigInt(None) => (),
            _ => panic!("Expected BigInt(None) for None Option<u64>"),
        }
        
        match model.get(Column::F32Field) {
            Value::Float(None) => (),
            _ => panic!("Expected Float(None) for None Option<f32>"),
        }
        
        match model.get(Column::F64Field) {
            Value::Double(None) => (),
            _ => panic!("Expected Double(None) for None Option<f64>"),
        }
    }

    #[test]
    fn test_model_trait_option_numeric_get_some() {
        use option_numeric_tests::*;
        
        // Test getting Some values from Option<T> numeric fields
        let model = OptionNumericFieldsModel {
            id: 1,
            u8_field: Some(42),
            u16_field: Some(1000),
            u32_field: Some(100000),
            u64_field: Some(10000000000),
            f32_field: Some(3.14),
            f64_field: Some(2.71828),
        };
        
        // Test u8
        match model.get(Column::U8Field) {
            Value::SmallInt(Some(v)) => assert_eq!(v, 42i16),
            _ => panic!("Expected SmallInt(Some(42)) for Some(42) Option<u8>"),
        }
        
        // Test u16
        match model.get(Column::U16Field) {
            Value::Int(Some(v)) => assert_eq!(v, 1000i32),
            _ => panic!("Expected Int(Some(1000)) for Some(1000) Option<u16>"),
        }
        
        // Test u32
        match model.get(Column::U32Field) {
            Value::BigInt(Some(v)) => assert_eq!(v, 100000i64),
            _ => panic!("Expected BigInt(Some(100000)) for Some(100000) Option<u32>"),
        }
        
        // Test u64
        match model.get(Column::U64Field) {
            Value::BigInt(Some(v)) => assert_eq!(v, 10000000000i64),
            _ => panic!("Expected BigInt(Some(10000000000)) for Some(10000000000) Option<u64>"),
        }
        
        // Test f32
        match model.get(Column::F32Field) {
            Value::Float(Some(v)) => assert!((v - 3.14).abs() < 0.001),
            _ => panic!("Expected Float(Some(3.14)) for Some(3.14) Option<f32>"),
        }
        
        // Test f64
        match model.get(Column::F64Field) {
            Value::Double(Some(v)) => assert!((v - 2.71828).abs() < 0.00001),
            _ => panic!("Expected Double(Some(2.71828)) for Some(2.71828) Option<f64>"),
        }
    }

    #[test]
    fn test_model_trait_option_numeric_set_none() {
        use option_numeric_tests::*;
        
        // Test setting None values to Option<T> numeric fields
        let mut model = OptionNumericFieldsModel {
            id: 1,
            u8_field: Some(42),
            u16_field: Some(1000),
            u32_field: Some(100000),
            u64_field: Some(10000000000),
            f32_field: Some(3.14),
            f64_field: Some(2.71828),
        };
        
        // All should accept None and set field to None
        assert!(model.set(Column::U8Field, Value::SmallInt(None)).is_ok());
        assert_eq!(model.u8_field, None);
        
        assert!(model.set(Column::U16Field, Value::Int(None)).is_ok());
        assert_eq!(model.u16_field, None);
        
        assert!(model.set(Column::U32Field, Value::BigInt(None)).is_ok());
        assert_eq!(model.u32_field, None);
        
        assert!(model.set(Column::U64Field, Value::BigInt(None)).is_ok());
        assert_eq!(model.u64_field, None);
        
        assert!(model.set(Column::F32Field, Value::Float(None)).is_ok());
        assert_eq!(model.f32_field, None);
        
        assert!(model.set(Column::F64Field, Value::Double(None)).is_ok());
        assert_eq!(model.f64_field, None);
    }

    #[test]
    fn test_model_trait_option_numeric_set_some() {
        use option_numeric_tests::*;
        
        // Test setting Some values to Option<T> numeric fields
        let mut model = OptionNumericFieldsModel {
            id: 1,
            u8_field: None,
            u16_field: None,
            u32_field: None,
            u64_field: None,
            f32_field: None,
            f64_field: None,
        };
        
        // Test u8
        assert!(model.set(Column::U8Field, Value::SmallInt(Some(42))).is_ok());
        assert_eq!(model.u8_field, Some(42));
        
        // Test u16
        assert!(model.set(Column::U16Field, Value::Int(Some(1000))).is_ok());
        assert_eq!(model.u16_field, Some(1000));
        
        // Test u32
        assert!(model.set(Column::U32Field, Value::BigInt(Some(100000))).is_ok());
        assert_eq!(model.u32_field, Some(100000));
        
        // Test u64
        assert!(model.set(Column::U64Field, Value::BigInt(Some(10000000000))).is_ok());
        assert_eq!(model.u64_field, Some(10000000000));
        
        // Test f32
        assert!(model.set(Column::F32Field, Value::Float(Some(3.14))).is_ok());
        assert!(model.f32_field.map(|v| (v - 3.14).abs() < 0.001).unwrap_or(false));
        
        // Test f64
        assert!(model.set(Column::F64Field, Value::Double(Some(2.71828))).is_ok());
        assert!(model.f64_field.map(|v| (v - 2.71828).abs() < 0.00001).unwrap_or(false));
    }

    #[test]
    fn test_model_trait_option_numeric_set_type_mismatch() {
        use option_numeric_tests::*;
        
        // Test type mismatches for Option<T> numeric fields
        let mut model = OptionNumericFieldsModel {
            id: 1,
            u8_field: None,
            u16_field: None,
            u32_field: None,
            u64_field: None,
            f32_field: None,
            f64_field: None,
        };
        
        // Wrong type for u8 (should be SmallInt, not Int)
        assert!(model.set(Column::U8Field, Value::Int(Some(42))).is_err());
        
        // Wrong type for u16 (should be Int, not BigInt)
        assert!(model.set(Column::U16Field, Value::BigInt(Some(1000))).is_err());
        
        // Wrong type for f32 (should be Float, not Double)
        assert!(model.set(Column::F32Field, Value::Double(Some(3.14))).is_err());
        
        // Wrong type for f64 (should be Double, not Float)
        assert!(model.set(Column::F64Field, Value::Float(Some(2.71828))).is_err());
        
        // String to numeric (should error)
        assert!(model.set(Column::U8Field, Value::String(Some("invalid".to_string()))).is_err());
    }

    #[test]
    fn test_model_trait_option_numeric_unsigned_range_validation() {
        use option_numeric_tests::*;
        
        // Test that negative values are rejected for unsigned Option<T> types
        let mut model = OptionNumericFieldsModel {
            id: 1,
            u8_field: None,
            u16_field: None,
            u32_field: None,
            u64_field: None,
            f32_field: None,
            f64_field: None,
        };
        
        // Test Option<u8>: negative value should be rejected
        let result = model.set(Column::U8Field, Value::SmallInt(Some(-1)));
        assert!(result.is_err(), "Option<u8> should reject negative values");
        let error = result.unwrap_err();
        assert!(error.to_string().contains("range 0..=255"), "Error should mention valid range");
        
        // Test Option<u8>: out-of-range value should be rejected
        let result = model.set(Column::U8Field, Value::SmallInt(Some(256)));
        assert!(result.is_err(), "Option<u8> should reject values > 255");
        
        // Test Option<u16>: negative value should be rejected
        let result = model.set(Column::U16Field, Value::Int(Some(-1)));
        assert!(result.is_err(), "Option<u16> should reject negative values");
        let error = result.unwrap_err();
        assert!(error.to_string().contains("range 0..=65535"), "Error should mention valid range");
        
        // Test Option<u16>: out-of-range value should be rejected
        let result = model.set(Column::U16Field, Value::Int(Some(65536)));
        assert!(result.is_err(), "Option<u16> should reject values > 65535");
        
        // Test Option<u32>: negative value should be rejected
        let result = model.set(Column::U32Field, Value::BigInt(Some(-1)));
        assert!(result.is_err(), "Option<u32> should reject negative values");
        let error = result.unwrap_err();
        assert!(error.to_string().contains("range 0..=4294967295"), "Error should mention valid range");
        
        // Test Option<u32>: out-of-range value should be rejected
        let result = model.set(Column::U32Field, Value::BigInt(Some(4294967296i64)));
        assert!(result.is_err(), "Option<u32> should reject values > 4294967295");
        
        // Test that valid values still work
        assert!(model.set(Column::U8Field, Value::SmallInt(Some(0))).is_ok());
        assert!(model.set(Column::U8Field, Value::SmallInt(Some(255))).is_ok());
        assert!(model.set(Column::U16Field, Value::Int(Some(0))).is_ok());
        assert!(model.set(Column::U16Field, Value::Int(Some(65535))).is_ok());
        assert!(model.set(Column::U32Field, Value::BigInt(Some(0))).is_ok());
        assert!(model.set(Column::U32Field, Value::BigInt(Some(4294967295i64))).is_ok());
        
        // Test that None values still work
        assert!(model.set(Column::U8Field, Value::SmallInt(None)).is_ok());
        assert!(model.set(Column::U16Field, Value::Int(None)).is_ok());
        assert!(model.set(Column::U32Field, Value::BigInt(None)).is_ok());
    }

    #[test]
    fn test_model_trait_numeric_unsigned_range_validation() {
        use numeric_tests::*;
        
        // Test that negative values are rejected for unsigned types
        let mut model = NumericFieldsModel {
            id: 1,
            u8_field: 0,
            u16_field: 0,
            u32_field: 0,
            u64_field: 0,
            f32_field: 0.0,
            f64_field: 0.0,
        };
        
        // Test u8: negative value should be rejected
        let result = model.set(Column::U8Field, Value::SmallInt(Some(-1)));
        assert!(result.is_err(), "u8 should reject negative values");
        let error = result.unwrap_err();
        assert!(error.to_string().contains("range 0..=255"), "Error should mention valid range");
        
        // Test u8: out-of-range value should be rejected
        let result = model.set(Column::U8Field, Value::SmallInt(Some(256)));
        assert!(result.is_err(), "u8 should reject values > 255");
        
        // Test u16: negative value should be rejected
        let result = model.set(Column::U16Field, Value::Int(Some(-1)));
        assert!(result.is_err(), "u16 should reject negative values");
        let error = result.unwrap_err();
        assert!(error.to_string().contains("range 0..=65535"), "Error should mention valid range");
        
        // Test u16: out-of-range value should be rejected
        let result = model.set(Column::U16Field, Value::Int(Some(65536)));
        assert!(result.is_err(), "u16 should reject values > 65535");
        
        // Test u32: negative value should be rejected
        let result = model.set(Column::U32Field, Value::BigInt(Some(-1)));
        assert!(result.is_err(), "u32 should reject negative values");
        let error = result.unwrap_err();
        assert!(error.to_string().contains("range 0..=4294967295"), "Error should mention valid range");
        
        // Test u32: out-of-range value should be rejected
        let result = model.set(Column::U32Field, Value::BigInt(Some(4294967296i64)));
        assert!(result.is_err(), "u32 should reject values > 4294967295");
        
        // Test that valid values still work
        assert!(model.set(Column::U8Field, Value::SmallInt(Some(0))).is_ok());
        assert!(model.set(Column::U8Field, Value::SmallInt(Some(255))).is_ok());
        assert!(model.set(Column::U16Field, Value::Int(Some(0))).is_ok());
        assert!(model.set(Column::U16Field, Value::Int(Some(65535))).is_ok());
        assert!(model.set(Column::U32Field, Value::BigInt(Some(0))).is_ok());
        assert!(model.set(Column::U32Field, Value::BigInt(Some(4294967295i64))).is_ok());
    }
}

// ============================================================================
// ACTIVEMODEL TRAIT TESTS
// ============================================================================

#[cfg(test)]
mod active_model_trait_tests {
    use super::*;
    use lifeguard::{ActiveModelTrait, LifeModelTrait};

    #[test]
    fn test_active_model_trait_get() {
        // Test that ActiveModelTrait::get() works
        // Note: get() uses to_model() internally, which requires all non-nullable fields to be set
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Get values using ActiveModelTrait
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        let email_value = record.get(<Entity as LifeModelTrait>::Column::Email);
        assert!(email_value.is_some(), "Email should be set");
        
        let id_value = record.get(<Entity as LifeModelTrait>::Column::Id);
        assert!(id_value.is_some(), "Id should be set");
    }

    #[test]
    fn test_active_model_trait_take() {
        // Test that ActiveModelTrait::take() works
        // Note: take() uses to_model() internally, which requires all non-nullable fields to be set
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Take the value
        let name_value = record.take(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some(), "Name should be returned");
        
        // After take, the field should be None (but get() will still work with remaining fields)
        // Note: get() will fail if we try to get the taken field because to_model() requires all fields
        // This is a limitation of the current implementation
    }

    #[test]
    fn test_active_model_trait_reset() {
        // Test that ActiveModelTrait::reset() works
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Verify fields are set using dirty_fields() (get() requires all fields to be set)
        assert!(record.dirty_fields().contains(&"id".to_string()));
        assert!(record.dirty_fields().contains(&"name".to_string()));
        assert!(record.dirty_fields().contains(&"email".to_string()));
        
        // Reset all fields
        record.reset();
        
        // Verify all fields are now None using dirty_fields()
        assert!(record.dirty_fields().is_empty(), "All fields should be reset");
    }

    #[test]
    fn test_active_model_trait_set_works_implementation() {
        // Test that ActiveModelTrait::set() now works with proper type conversion
        let mut record = UserRecord::new();
        
        // Set String field
        let result = record.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(Some("John".to_string())));
        assert!(result.is_ok(), "set() should work for String fields");
        assert!(record.dirty_fields().contains(&"name".to_string()));
        
        // Set Int field
        let result = record.set(<Entity as LifeModelTrait>::Column::Id, sea_query::Value::Int(Some(42)));
        assert!(result.is_ok(), "set() should work for i32 fields");
        
        // Set None value
        let result = record.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(None));
        assert!(result.is_ok(), "set() should work for None values");
        
        // Test invalid type
        let result = record.set(<Entity as LifeModelTrait>::Column::Id, sea_query::Value::String(Some("invalid".to_string())));
        assert!(result.is_err(), "set() should return error for invalid type");
        let error = result.unwrap_err();
        assert!(error.to_string().contains("Invalid value type"), "Error should indicate invalid type");
    }

    // ============================================================================
    // EDGE CASES FOR get()
    // ============================================================================

    #[test]
    fn test_active_model_trait_get_empty_record() {
        // EDGE CASE: Getting from an empty record should fail if non-nullable fields are missing
        let _record = UserRecord::new();
        // Note: get() uses to_model() which requires all non-nullable fields
        // This is expected behavior - we can't get values without all required fields
        // We can't actually test get() on an empty record because it would panic in to_model()
    }

    #[test]
    fn test_active_model_trait_get_all_field_types() {
        // Test get() with all field types
        let mut record = UserRecord::new();
        record.set_id(42);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Get i32 field
        let id_value = record.get(<Entity as LifeModelTrait>::Column::Id);
        assert!(id_value.is_some());
        match id_value.unwrap() {
            sea_query::Value::Int(Some(v)) => assert_eq!(v, 42),
            _ => panic!("Expected Int(Some(42)) for i32 field"),
        }
        
        // Get String fields
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some());
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "John"),
            _ => panic!("Expected String(Some(\"John\")) for String field"),
        }
    }

    #[test]
    fn test_active_model_trait_get_with_option_fields() {
        // EDGE CASE: Test get() with Option<T> fields
        // Note: UserRecord doesn't have Option<T> fields, but the concept applies
        // For Option<T> fields, get() would return None if the field is None
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // All fields are set, so get() should work
        assert!(record.get(<Entity as LifeModelTrait>::Column::Name).is_some());
    }

    // ============================================================================
    // EDGE CASES FOR take()
    // ============================================================================

    #[test]
    fn test_active_model_trait_take_none_field() {
        // EDGE CASE: Taking a field that's None should return None
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_email("test@example.com".to_string());
        // name is not set (None)
        
        // Note: take() uses to_model() which requires all non-nullable fields
        // So we need to set name first
        record.set_name("Test".to_string());
        
        // Now take name
        let name_value = record.take(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some(), "Name should be returned even if it was just set");
        
        // After take, the field is None, but we can't verify with get() because to_model() requires all fields
        // We can verify with dirty_fields()
        assert!(!record.dirty_fields().contains(&"name".to_string()), "Name should not be in dirty fields after take");
    }

    #[test]
    fn test_active_model_trait_take_multiple_fields() {
        // EDGE CASE: Taking multiple fields in sequence
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Take name
        let name_value = record.take(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some());
        
        // Take email (but we need to set name again for to_model() to work)
        // This demonstrates the limitation: take() requires all non-nullable fields to be set
        record.set_name("Dummy".to_string()); // Required for to_model()
        let email_value = record.take(<Entity as LifeModelTrait>::Column::Email);
        assert!(email_value.is_some());
    }

    #[test]
    fn test_active_model_trait_take_all_fields() {
        // EDGE CASE: Taking all fields one by one
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Take all fields
        let id_value = record.take(<Entity as LifeModelTrait>::Column::Id);
        assert!(id_value.is_some());
        
        // After taking id, we can't use get() or take() on other fields because to_model() requires all fields
        // This is a known limitation
    }

    // ============================================================================
    // EDGE CASES FOR reset()
    // ============================================================================

    #[test]
    fn test_active_model_trait_reset_empty_record() {
        // EDGE CASE: Resetting an already empty record
        let mut record = UserRecord::new();
        assert!(record.dirty_fields().is_empty());
        
        // Reset should work without error
        record.reset();
        assert!(record.dirty_fields().is_empty(), "Empty record should stay empty after reset");
    }

    #[test]
    fn test_active_model_trait_reset_partial_fields() {
        // EDGE CASE: Resetting a record with only some fields set
        let mut record = UserRecord::new();
        record.set_name("John".to_string());
        // id and email are not set
        
        assert!(record.dirty_fields().contains(&"name".to_string()));
        
        // Reset should clear all fields
        record.reset();
        assert!(record.dirty_fields().is_empty(), "All fields should be cleared after reset");
    }

    #[test]
    fn test_active_model_trait_reset_and_reuse() {
        // EDGE CASE: Reset and then set fields again
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Reset
        record.reset();
        assert!(record.dirty_fields().is_empty());
        
        // Set fields again
        record.set_id(2);
        record.set_name("Jane".to_string());
        record.set_email("jane@example.com".to_string());
        
        // Verify fields are set again
        assert!(record.dirty_fields().contains(&"id".to_string()));
        assert!(record.dirty_fields().contains(&"name".to_string()));
        assert!(record.dirty_fields().contains(&"email".to_string()));
    }

    #[test]
    fn test_active_model_trait_reset_after_take() {
        // EDGE CASE: Reset after taking some fields
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Take a field
        let _name_value = record.take(<Entity as LifeModelTrait>::Column::Name);
        
        // Reset should clear all fields
        record.reset();
        assert!(record.dirty_fields().is_empty(), "All fields should be cleared after reset, even after take");
    }

    // ============================================================================
    // EDGE CASES FOR set()
    // ============================================================================

    #[test]
    fn test_active_model_trait_set_different_value_types() {
        // EDGE CASE: Testing set() with different Value types (now fully implemented)
        let mut record = UserRecord::new();
        
        // Test with String value
        let result1 = record.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(Some("John".to_string())));
        assert!(result1.is_ok(), "set() should work for String values");
        
        // Test with Int value
        let result2 = record.set(<Entity as LifeModelTrait>::Column::Id, sea_query::Value::Int(Some(42)));
        assert!(result2.is_ok(), "set() should work for Int values");
        
        // Test with None value
        let result3 = record.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(None));
        assert!(result3.is_ok(), "set() should work for None values");
        
        // Test with invalid type
        let result4 = record.set(<Entity as LifeModelTrait>::Column::Id, sea_query::Value::String(Some("invalid".to_string())));
        assert!(result4.is_err(), "set() should return error for invalid type");
    }

    #[test]
    fn test_active_model_trait_set_works() {
        // Test that set() now works with proper type conversion
        let mut record = UserRecord::new();
        
        // Set String field
        let result = record.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(Some("John".to_string())));
        assert!(result.is_ok(), "set() should work for String fields");
        assert!(record.dirty_fields().contains(&"name".to_string()));
        
        // Set Int field
        let result = record.set(<Entity as LifeModelTrait>::Column::Id, sea_query::Value::Int(Some(42)));
        assert!(result.is_ok(), "set() should work for i32 fields");
        
        // Set None value
        let result = record.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(None));
        assert!(result.is_ok(), "set() should work for None values");
        
        // Test invalid type
        let result = record.set(<Entity as LifeModelTrait>::Column::Id, sea_query::Value::String(Some("invalid".to_string())));
        assert!(result.is_err(), "set() should return error for invalid type");
        let error = result.unwrap_err();
        assert!(error.to_string().contains("Invalid value type"), "Error should indicate invalid type");
    }

    // ============================================================================
    // EDGE CASES FOR CRUD OPERATIONS (placeholders)
    // ============================================================================

    #[test]
    fn test_active_model_trait_crud_operations_compile() {
        // Test that CRUD methods compile and have correct signatures
        let record = UserRecord::new();
        
        // Verify methods exist and have correct types
        // Note: These methods now have implementations, but require a real executor to test
        // For now, we just verify they compile
        
        // insert() should return Result<Model, ActiveModelError>
        let _insert_result: Result<UserModel, lifeguard::ActiveModelError> = {
            // We can't actually call this without an executor, but we can verify the type
            // This is a compile-time check
            Err(lifeguard::ActiveModelError::Other("test".to_string()))
        };
        
        // update() should return Result<Model, ActiveModelError>
        let _update_result: Result<UserModel, lifeguard::ActiveModelError> = {
            Err(lifeguard::ActiveModelError::Other("test".to_string()))
        };
        
        // delete() should return Result<(), ActiveModelError>
        let _delete_result: Result<(), lifeguard::ActiveModelError> = {
            Err(lifeguard::ActiveModelError::Other("test".to_string()))
        };
        
        // save() should return Result<Model, ActiveModelError>
        let _save_result: Result<UserModel, lifeguard::ActiveModelError> = {
            Err(lifeguard::ActiveModelError::Other("test".to_string()))
        };
        
        // Verify the record has the methods (compile-time check)
        let _ = record;
    }
    
    #[test]
    fn test_active_model_trait_insert_requires_fields() {
        // Test that insert() requires at least some fields to be set
        let record = UserRecord::new();
        
        // insert() should fail if no fields are set (but we can't test without executor)
        // This is a compile-time verification that the method exists
        let _ = record;
    }
    
    #[test]
    fn test_active_model_trait_update_requires_primary_key() {
        // Test that update() requires primary key to be set
        let mut record = UserRecord::new();
        
        // Set some fields but not primary key
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // update() should fail if primary key is not set (but we can't test without executor)
        // This is a compile-time verification that the method exists
        let _ = record;
    }
    
    #[test]
    fn test_active_model_trait_delete_requires_primary_key() {
        // Test that delete() requires primary key to be set
        let mut record = UserRecord::new();
        
        // Set primary key
        record.set_id(1);
        
        // delete() should work if primary key is set (but we can't test without executor)
        // This is a compile-time verification that the method exists
        let _ = record;
    }
    
    #[test]
    fn test_active_model_trait_save_logic() {
        // Test that save() routes to insert or update based on primary key
        let mut record_with_pk = UserRecord::new();
        record_with_pk.set_id(1);
        record_with_pk.set_name("John".to_string());
        
        let mut record_without_pk = UserRecord::new();
        record_without_pk.set_name("Jane".to_string());
        
        // save() should route to update if PK is set, insert if not (but we can't test without executor)
        // This is a compile-time verification that the method exists
        let _ = (record_with_pk, record_without_pk);
    }

    // ============================================================================
    // EDGE CASES FOR COMPOSITE PRIMARY KEYS
    // ============================================================================

    #[test]
    fn test_active_model_trait_with_composite_primary_key() {
        // EDGE CASE: Test ActiveModelTrait with composite primary keys
        // This would require a composite primary key entity with LifeRecord
        // For now, we'll test the concept with UserRecord (single primary key)
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // get() should work with single primary key
        let id_value = record.get(<Entity as LifeModelTrait>::Column::Id);
        assert!(id_value.is_some());
    }

    // ============================================================================
    // EDGE CASES FOR DIRTY FIELDS TRACKING
    // ============================================================================

    #[test]
    fn test_active_model_trait_dirty_fields_after_operations() {
        // EDGE CASE: Verify dirty_fields() behavior after various operations
        let mut record = UserRecord::new();
        assert!(record.dirty_fields().is_empty());
        
        // Set a field
        record.set_name("John".to_string());
        assert!(record.dirty_fields().contains(&"name".to_string()));
        
        // Reset
        record.reset();
        assert!(record.dirty_fields().is_empty());
        
        // Set multiple fields
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        assert_eq!(record.dirty_fields().len(), 3);
        
        // Take a field (but need to set it again for to_model())
        record.set_name("Dummy".to_string());
        let _ = record.take(<Entity as LifeModelTrait>::Column::Name);
        // After take, name should not be in dirty_fields (it's None)
        // But we can't verify this easily because take() requires all fields for to_model()
    }

    #[test]
    fn test_active_model_trait_is_dirty() {
        // EDGE CASE: Test is_dirty() with various states
        let mut record = UserRecord::new();
        assert!(!record.is_dirty(), "Empty record should not be dirty");
        
        record.set_name("John".to_string());
        assert!(record.is_dirty(), "Record with set field should be dirty");
        
        record.reset();
        assert!(!record.is_dirty(), "Reset record should not be dirty");
    }

    // ============================================================================
    // EDGE CASES FOR from_model() AND to_model()
    // ============================================================================

    #[test]
    fn test_active_model_trait_from_model_to_model_roundtrip() {
        // EDGE CASE: Test roundtrip: Model -> Record -> Model
        let model = UserModel {
            id: 1,
            name: "John".to_string(),
            email: "john@example.com".to_string(),
        };
        
        // Create record from model
        let record = UserRecord::from_model(&model);
        
        // Verify all fields are set
        assert_eq!(record.dirty_fields().len(), 3);
        
        // Convert back to model
        let model2 = record.to_model();
        assert_eq!(model2.id, 1);
        assert_eq!(model2.name, "John");
        assert_eq!(model2.email, "john@example.com");
    }

    #[test]
    fn test_active_model_trait_get_after_from_model() {
        // EDGE CASE: Test get() after creating record from model
        let model = UserModel {
            id: 1,
            name: "John".to_string(),
            email: "john@example.com".to_string(),
        };
        
        let record = UserRecord::from_model(&model);
        
        // get() should work because all fields are set
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some());
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "John"),
            _ => panic!("Expected String(Some(\"John\"))"),
        }
    }

    // ============================================================================
    // OPTION<T> FIELDS IN RECORDS - FIX FOR Option<Option<T>> ISSUE
    // ============================================================================

    #[test]
    fn test_record_with_option_fields_not_double_wrapped() {
        // CRITICAL TEST: Verify that Option<T> fields in Model don't become Option<Option<T>> in Record
        use super::option_tests::*;
        
        // Create a model with Option<String> field
        let model = UserWithOptionsModel {
            id: 1,
            name: Some("John".to_string()),
            age: Some(30),
            active: Some(true),
        };
        
        // Create record from model
        let record = UserWithOptionsRecord::from_model(&model);
        
        // Verify the record field is Option<String>, not Option<Option<String>>
        // We can't directly check the type, but we can verify behavior:
        // - get() should work correctly
        // - set() should work correctly
        // - to_model() should work correctly
        
        // Test get() with Option<String> field
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some(), "get() should return Some(Value) for Option<String> field");
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "John"),
            _ => panic!("Expected String(Some(\"John\")) for Option<String> field"),
        }
        
        // Test get() with Option<i32> field
        let age_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Age);
        assert!(age_value.is_some(), "get() should return Some(Value) for Option<i32> field");
        match age_value.unwrap() {
            sea_query::Value::Int(Some(v)) => assert_eq!(v, 30),
            _ => panic!("Expected Int(Some(30)) for Option<i32> field"),
        }
        
        // Test get() with Option<bool> field
        let active_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Active);
        assert!(active_value.is_some(), "get() should return Some(Value) for Option<bool> field");
        match active_value.unwrap() {
            sea_query::Value::Bool(Some(v)) => assert_eq!(v, true),
            _ => panic!("Expected Bool(Some(true)) for Option<bool> field"),
        }
    }

    #[test]
    fn test_record_with_option_fields_set_works() {
        // Test that set() works correctly for Option<T> fields
        use super::option_tests::*;
        
        let mut record = UserWithOptionsRecord::new();
        
        // Set Option<String> field to Some
        let result = record.set(
            <option_tests::Entity as LifeModelTrait>::Column::Name,
            sea_query::Value::String(Some("Jane".to_string()))
        );
        assert!(result.is_ok(), "set() should work for Option<String> field with Some value");
        
        // Verify get() returns the correct value
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some());
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "Jane"),
            _ => panic!("Expected String(Some(\"Jane\"))"),
        }
        
        // Set Option<String> field to None explicitly
        // When set() is called with Value::String(None), it sets the field to None (unset)
        // With Option<T> fields, we can't distinguish "set to None" from "unset" - both are None
        let result = record.set(
            <option_tests::Entity as LifeModelTrait>::Column::Name,
            sea_query::Value::String(None)
        );
        assert!(result.is_ok(), "set() should work for Option<String> field with None value");
        
        // When set to None, the field becomes unset, so get() returns None
        // This is the correct behavior - with Option<T>, we can't distinguish "set to None" from "unset"
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_none(), "get() should return None when Option<String> field is set to None (becomes unset)");
    }

    #[test]
    fn test_record_with_option_fields_from_model_to_model_roundtrip() {
        // Test roundtrip: Model with Option<T> -> Record -> Model
        use super::option_tests::*;
        
        let model = UserWithOptionsModel {
            id: 1,
            name: Some("John".to_string()),
            age: Some(30),
            active: Some(true),
        };
        
        // Create record from model
        let record = UserWithOptionsRecord::from_model(&model);
        
        // Convert back to model
        let model2 = record.to_model();
        assert_eq!(model2.id, 1);
        assert_eq!(model2.name, Some("John".to_string()));
        assert_eq!(model2.age, Some(30));
        assert_eq!(model2.active, Some(true));
    }

    #[test]
    fn test_record_with_option_fields_none_values() {
        // Test that None values in Option<T> fields work correctly
        use super::option_tests::*;
        
        let model = UserWithOptionsModel {
            id: 1,
            name: None,
            age: None,
            active: None,
        };
        
        // Create record from model
        // When from_model() is called with a model that has None values,
        // the Record fields are set to None (unset), not Some(None)
        // This is because from_model() does: name: model.name.clone()
        // So if model.name is None, record.name is None (unset)
        let record = UserWithOptionsRecord::from_model(&model);
        
        // Verify get() returns None for all unset Option<T> fields
        // This is the correct behavior - unset fields return None from get()
        // This allows CRUD operations to correctly detect unset fields
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_none(), "get() should return None for unset Option<String> field");
        
        let age_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Age);
        assert!(age_value.is_none(), "get() should return None for unset Option<i32> field");
        
        let active_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Active);
        assert!(active_value.is_none(), "get() should return None for unset Option<bool> field");
        
        // Convert back to model
        let model2 = record.to_model();
        assert_eq!(model2.id, 1);
        assert_eq!(model2.name, None);
        assert_eq!(model2.age, None);
        assert_eq!(model2.active, None);
    }

    // ============================================================================
    // BUG FIX TESTS: get() returns None for unset fields
    // ============================================================================
    // These tests verify the fix for generate_option_field_to_value which was
    // always wrapping results in Some(...), preventing get() from returning None
    // for unset fields. This broke CRUD operations that rely on get().is_none()
    // to detect unset fields.

    #[test]
    fn test_get_returns_none_for_unset_fields() {
        // CRITICAL TEST: get() should return None for unset fields
        // This is required for CRUD operations to correctly detect unset fields
        let record = UserRecord::new();
        
        // All fields are unset, so get() should return None
        let id_value = record.get(<Entity as LifeModelTrait>::Column::Id);
        assert!(id_value.is_none(), "get() should return None for unset id field");
        
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_none(), "get() should return None for unset name field");
        
        let email_value = record.get(<Entity as LifeModelTrait>::Column::Email);
        assert!(email_value.is_none(), "get() should return None for unset email field");
    }

    #[test]
    fn test_get_returns_some_for_set_fields() {
        // POSITIVE TEST: get() should return Some(Value) for set fields
        let mut record = UserRecord::new();
        record.set_id(42);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // All fields are set, so get() should return Some(Value)
        let id_value = record.get(<Entity as LifeModelTrait>::Column::Id);
        assert!(id_value.is_some(), "get() should return Some(Value) for set id field");
        match id_value.unwrap() {
            sea_query::Value::Int(Some(v)) => assert_eq!(v, 42),
            _ => panic!("Expected Int(Some(42))"),
        }
        
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some(), "get() should return Some(Value) for set name field");
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "John"),
            _ => panic!("Expected String(Some(\"John\"))"),
        }
        
        let email_value = record.get(<Entity as LifeModelTrait>::Column::Email);
        assert!(email_value.is_some(), "get() should return Some(Value) for set email field");
        match email_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "john@example.com"),
            _ => panic!("Expected String(Some(\"john@example.com\"))"),
        }
    }

    #[test]
    fn test_get_partially_set_record() {
        // EDGE CASE: get() should return None for unset fields, Some for set fields
        let mut record = UserRecord::new();
        record.set_name("Jane".to_string());
        // id and email are not set
        
        // Set field should return Some
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some(), "get() should return Some(Value) for set name field");
        
        // Unset fields should return None
        let id_value = record.get(<Entity as LifeModelTrait>::Column::Id);
        assert!(id_value.is_none(), "get() should return None for unset id field");
        
        let email_value = record.get(<Entity as LifeModelTrait>::Column::Email);
        assert!(email_value.is_none(), "get() should return None for unset email field");
    }

    #[test]
    fn test_get_with_option_fields_unset() {
        // Test get() with Option<T> fields when unset
        use super::option_tests::*;
        
        let record = UserWithOptionsRecord::new();
        
        // All Option<T> fields are unset, so get() should return None
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_none(), "get() should return None for unset Option<String> field");
        
        let age_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Age);
        assert!(age_value.is_none(), "get() should return None for unset Option<i32> field");
        
        let active_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Active);
        assert!(active_value.is_none(), "get() should return None for unset Option<bool> field");
    }

    #[test]
    fn test_get_with_option_fields_set_to_some() {
        // Test get() with Option<T> fields when set to Some(value)
        use super::option_tests::*;
        
        let mut record = UserWithOptionsRecord::new();
        record.set_name(Some("Alice".to_string()));
        record.set_age(Some(25));
        record.set_active(Some(true));
        
        // All Option<T> fields are set to Some, so get() should return Some(Value)
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some(), "get() should return Some(Value) for set Option<String> field");
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "Alice"),
            _ => panic!("Expected String(Some(\"Alice\"))"),
        }
        
        let age_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Age);
        assert!(age_value.is_some(), "get() should return Some(Value) for set Option<i32> field");
        match age_value.unwrap() {
            sea_query::Value::Int(Some(v)) => assert_eq!(v, 25),
            _ => panic!("Expected Int(Some(25))"),
        }
        
        let active_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Active);
        assert!(active_value.is_some(), "get() should return Some(Value) for set Option<bool> field");
        match active_value.unwrap() {
            sea_query::Value::Bool(Some(v)) => assert_eq!(v, true),
            _ => panic!("Expected Bool(Some(true))"),
        }
    }

    #[test]
    fn test_get_with_option_fields_set_to_none() {
        // Test get() with Option<T> fields when explicitly set to None
        // When a field is set to None (via set() with Value::String(None)),
        // it becomes unset (None). With Option<T> fields, we can't distinguish
        // "set to None" from "unset" - both are represented as None.
        use super::option_tests::*;
        
        let mut record = UserWithOptionsRecord::new();
        
        // Set fields to None explicitly (this sets the field to None, making it unset)
        record.set(
            <option_tests::Entity as LifeModelTrait>::Column::Name,
            sea_query::Value::String(None)
        ).expect("set() should work");
        
        record.set(
            <option_tests::Entity as LifeModelTrait>::Column::Age,
            sea_query::Value::Int(None)
        ).expect("set() should work");
        
        // When set to None, the field becomes unset, so get() returns None
        // This is the correct behavior - with Option<T>, we can't distinguish "set to None" from "unset"
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_none(), "get() should return None when Option<String> field is set to None (becomes unset)");
        
        let age_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Age);
        assert!(age_value.is_none(), "get() should return None when Option<i32> field is set to None (becomes unset)");
    }

    #[test]
    fn test_record_with_option_fields_setter_accepts_option() {
        // Test that setter for Option<T> fields accepts Option<T> directly
        use super::option_tests::*;
        
        let mut record = UserWithOptionsRecord::new();
        
        // Setter should accept Option<String> directly (not String)
        record.set_name(Some("John".to_string()));
        
        // Verify the value was set
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some());
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "John"),
            _ => panic!("Expected String(Some(\"John\"))"),
        }
        
        // Setter should accept None
        record.set_name(None);
        
        // When set to None, the field becomes unset, so get() returns None
        // This is the correct behavior - with Option<T>, we can't distinguish "set to None" from "unset"
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_none(), "get() should return None when Option<String> field is set to None (becomes unset)");
    }

    // ============================================================================
    // COMPREHENSIVE EDGE CASES FOR CRUD OPERATIONS
    // ============================================================================

    // ============================================================================
    // JSON SERIALIZATION TESTS
    // ============================================================================

    #[test]
    fn test_active_model_to_json() {
        // Test that to_json() serializes Record to JSON
        use serde_json::json;
        
        let mut record = UserRecord::new();
        record.set_id(42);
        record.set_name("John Doe".to_string());
        record.set_email("john@example.com".to_string());
        
        let json = record.to_json().expect("to_json() should succeed");
        
        // Verify JSON structure
        assert!(json.is_object(), "JSON should be an object");
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("id"), Some(&json!(42)));
        assert_eq!(obj.get("name"), Some(&json!("John Doe")));
        assert_eq!(obj.get("email"), Some(&json!("john@example.com")));
    }

    #[test]
    fn test_active_model_from_json() {
        // Test that from_json() deserializes JSON to Record
        use serde_json::json;
        
        let json = json!({
            "id": 42,
            "name": "John Doe",
            "email": "john@example.com"
        });
        
        let record = UserRecord::from_json(json).expect("from_json() should succeed");
        
        // Verify Record fields
        let id_value = record.get(<Entity as LifeModelTrait>::Column::Id);
        assert!(id_value.is_some());
        match id_value.unwrap() {
            sea_query::Value::Int(Some(v)) => assert_eq!(v, 42),
            _ => panic!("Expected Int(Some(42))"),
        }
        
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some());
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "John Doe"),
            _ => panic!("Expected String(Some(\"John Doe\"))"),
        }
        
        let email_value = record.get(<Entity as LifeModelTrait>::Column::Email);
        assert!(email_value.is_some());
        match email_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "john@example.com"),
            _ => panic!("Expected String(Some(\"john@example.com\"))"),
        }
    }

    #[test]
    fn test_active_model_json_roundtrip() {
        // Test roundtrip: Record -> JSON -> Record
        
        let mut original = UserRecord::new();
        original.set_id(100);
        original.set_name("Roundtrip Test".to_string());
        original.set_email("roundtrip@example.com".to_string());
        
        // Record -> JSON
        let json = original.to_json().expect("to_json() should succeed");
        
        // JSON -> Record
        let restored = UserRecord::from_json(json).expect("from_json() should succeed");
        
        // Verify all fields match
        let original_id = original.get(<Entity as LifeModelTrait>::Column::Id);
        let restored_id = restored.get(<Entity as LifeModelTrait>::Column::Id);
        assert_eq!(original_id, restored_id);
        
        let original_name = original.get(<Entity as LifeModelTrait>::Column::Name);
        let restored_name = restored.get(<Entity as LifeModelTrait>::Column::Name);
        assert_eq!(original_name, restored_name);
        
        let original_email = original.get(<Entity as LifeModelTrait>::Column::Email);
        let restored_email = restored.get(<Entity as LifeModelTrait>::Column::Email);
        assert_eq!(original_email, restored_email);
    }

    #[test]
    fn test_active_model_from_json_invalid() {
        // Test that from_json() returns error for invalid JSON
        use serde_json::json;
        
        // Invalid JSON structure (missing required fields)
        let json = json!({
            "name": "Incomplete"
            // Missing id and email
        });
        
        let result = UserRecord::from_json(json);
        assert!(result.is_err(), "from_json() should fail for invalid JSON");
    }

    #[test]
    fn test_active_model_to_json_with_option_fields() {
        // Test to_json() with Option<T> fields
        use super::option_tests::*;
        use serde_json::json;
        
        let mut record = UserWithOptionsRecord::new();
        record.set_id(1);
        record.set_name(Some("Test".to_string()));
        record.set_age(Some(30));
        record.set_active(Some(true));
        
        let json = record.to_json().expect("to_json() should succeed");
        
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("id"), Some(&json!(1)));
        assert_eq!(obj.get("name"), Some(&json!("Test")));
        assert_eq!(obj.get("age"), Some(&json!(30)));
        assert_eq!(obj.get("active"), Some(&json!(true)));
    }

    #[test]
    fn test_active_model_from_json_with_option_fields() {
        // Test from_json() with Option<T> fields
        use super::option_tests::*;
        use serde_json::json;
        
        let json = json!({
            "id": 1,
            "name": "Test",
            "age": 30,
            "active": true
        });
        
        let record = UserWithOptionsRecord::from_json(json).expect("from_json() should succeed");
        
        // Verify fields
        let name_value = record.get(<option_tests::Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some());
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "Test"),
            _ => panic!("Expected String(Some(\"Test\"))"),
        }
    }

    #[test]
    fn test_active_model_to_json_with_unset_required_fields() {
        // Test that to_json() doesn't panic when required fields are unset
        // This is the fix for the issue where to_json() called to_model() which panics
        use serde_json::json;
        
        // Create a record with only some fields set (required fields are unset)
        let mut record = UserRecord::new();
        record.set_id(42);
        // name and email are required but not set
        
        // to_json() should succeed and only include set fields
        let json = record.to_json().expect("to_json() should succeed even with unset required fields");
        
        // Verify JSON only contains set fields
        assert!(json.is_object(), "JSON should be an object");
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("id"), Some(&json!(42)), "id should be in JSON");
        assert_eq!(obj.get("name"), None, "name should not be in JSON (unset)");
        assert_eq!(obj.get("email"), None, "email should not be in JSON (unset)");
        assert_eq!(obj.len(), 1, "JSON should only contain one field (id)");
    }

    #[test]
    fn test_active_model_to_json_empty_record() {
        // Test that to_json() works on an empty record (no fields set)
        let record = UserRecord::new();
        
        // to_json() should succeed and return an empty object
        let json = record.to_json().expect("to_json() should succeed on empty record");
        
        assert!(json.is_object(), "JSON should be an object");
        let obj = json.as_object().unwrap();
        assert!(obj.is_empty(), "JSON should be empty when no fields are set");
    }

    // ============================================================================
    // JSON Serialization Edge Cases
    // ============================================================================

    #[test]
    fn test_json_from_json_with_extra_fields() {
        // EDGE CASE: from_json() with extra fields in JSON (should ignore or error)
        use serde_json::json;
        let json = json!({
            "id": 1,
            "name": "Test",
            "email": "test@example.com",
            "extra_field": "should be ignored or cause error"
        });
        
        // Should either succeed (ignoring extra) or error
        let result = UserRecord::from_json(json);
        // Current implementation may error on extra fields
        // This documents the expected behavior
        let _ = result;
    }

    #[test]
    fn test_json_from_json_with_null_for_required_field() {
        // EDGE CASE: from_json() with null for non-Option required field
        use serde_json::json;
        let json = json!({
            "id": 1,
            "name": null, // null for required String field
            "email": "test@example.com",
        });
        
        let result = UserRecord::from_json(json);
        // Should error - null not allowed for non-Option field
        assert!(result.is_err(), "from_json() should fail when null provided for required field");
    }

    #[test]
    fn test_json_roundtrip_with_option_fields() {
        // EDGE CASE: Roundtrip JSON with Option<T> fields (None and Some values)
        // Use UserWithOptions which has Option fields
        use super::option_tests::*;
        
        let mut record = UserWithOptionsRecord::new();
        record.set_id(1);
        record.set_name(Some("Test".to_string()));
        record.set_age(Some(30));
        record.set_active(Some(true));
        
        let json = record.to_json().expect("to_json() should succeed");
        let restored = UserWithOptionsRecord::from_json(json).expect("from_json() should succeed");
        
        // Verify age is preserved
        let restored_age = restored.get(<option_tests::Entity as LifeModelTrait>::Column::Age);
        assert!(restored_age.is_some());
    }

    #[test]
    fn test_json_with_large_values() {
        // EDGE CASE: JSON with very large string values
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("A".repeat(10000)); // Large string
        record.set_email("test@example.com".to_string());
        
        let json = record.to_json().expect("to_json() should handle large values");
        assert!(json.is_object());
    }

    #[test]
    fn test_json_with_special_characters() {
        // EDGE CASE: JSON with special characters (quotes, newlines, etc.)
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("Test \"quoted\" name\nwith newline".to_string());
        record.set_email("test@example.com".to_string());
        
        let json = record.to_json().expect("to_json() should handle special characters");
        let restored = UserRecord::from_json(json).expect("from_json() should handle special characters");
        
        let restored_name = restored.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(restored_name.is_some());
    }

    // Entity with float fields for testing NaN and infinity serialization
    mod float_tests {
        use super::*;
        
        #[derive(LifeModel, LifeRecord)]
        #[table_name = "float_fields"]
        pub struct FloatFields {
            #[primary_key]
            pub id: i32,
            pub f32_field: f32,
            pub f64_field: f64,
        }
    }

    #[test]
    fn test_json_with_nan_and_infinity() {
        // EDGE CASE: JSON serialization of NaN and infinity values
        use float_tests::*;
        use serde_json::json;
        use lifeguard::LifeModelTrait;
        
        let mut record = FloatFieldsRecord::new();
        record.set_id(1);
        
        // Test NaN for f32
        record.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(f32::NAN))).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed with NaN");
        let obj = json.as_object().unwrap();
        // NaN should be serialized as string "NaN", not number 0
        assert_eq!(obj.get("f32_field"), Some(&json!("NaN")), "NaN should be serialized as string");
        
        // Test positive infinity for f32
        record.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(f32::INFINITY))).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed with infinity");
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("f32_field"), Some(&json!("Infinity")), "Positive infinity should be serialized as string");
        
        // Test negative infinity for f32
        record.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(f32::NEG_INFINITY))).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed with negative infinity");
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("f32_field"), Some(&json!("-Infinity")), "Negative infinity should be serialized as string");
        
        // Test NaN for f64
        record.set(<Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(Some(f64::NAN))).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed with NaN");
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("f64_field"), Some(&json!("NaN")), "NaN should be serialized as string");
        
        // Test positive infinity for f64
        record.set(<Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(Some(f64::INFINITY))).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed with infinity");
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("f64_field"), Some(&json!("Infinity")), "Positive infinity should be serialized as string");
        
        // Test negative infinity for f64
        record.set(<Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(Some(f64::NEG_INFINITY))).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed with negative infinity");
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("f64_field"), Some(&json!("-Infinity")), "Negative infinity should be serialized as string");
        
        // Test that normal finite numbers are still serialized as numbers
        record.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(3.14))).expect("set should succeed");
        record.set(<Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(Some(2.71828))).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed with normal numbers");
        let obj = json.as_object().unwrap();
        // Normal numbers should be JSON numbers, not strings
        assert!(obj.get("f32_field").unwrap().is_number(), "Normal f32 should be a number");
        assert!(obj.get("f64_field").unwrap().is_number(), "Normal f64 should be a number");
    }

    #[test]
    fn test_json_roundtrip_with_nan_and_infinity() {
        // EDGE CASE: Roundtrip serialization/deserialization of NaN and infinity
        // With custom deserializers, we can now roundtrip NaN/infinity values
        use float_tests::*;
        use lifeguard::LifeModelTrait;
        
        let mut original = FloatFieldsRecord::new();
        original.set_id(1);
        original.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(f32::NAN))).expect("set should succeed");
        original.set(<Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(Some(f64::INFINITY))).expect("set should succeed");
        
        // Serialize to JSON (NaN/infinity become strings)
        let json = original.to_json().expect("to_json() should succeed");
        
        // Deserialize back - should now succeed with custom deserializers
        let restored = FloatFieldsRecord::from_json(json).expect("from_json() should succeed with custom deserializers");
        
        // Verify the values were preserved
        let restored_f32 = restored.get(<Entity as LifeModelTrait>::Column::F32Field);
        match restored_f32 {
            Some(sea_query::Value::Float(Some(v))) => assert!(v.is_nan(), "f32 NaN should be preserved"),
            _ => panic!("Expected Float(Some(NaN)), got {:?}", restored_f32),
        }
        
        let restored_f64 = restored.get(<Entity as LifeModelTrait>::Column::F64Field);
        match restored_f64 {
            Some(sea_query::Value::Double(Some(v))) => {
                assert!(v.is_infinite() && v.is_sign_positive(), "f64 Infinity should be preserved");
            }
            _ => panic!("Expected Double(Some(Infinity)), got {:?}", restored_f64),
        }
        
        // Test negative infinity roundtrip
        let mut original2 = FloatFieldsRecord::new();
        original2.set_id(2);
        original2.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(f32::NEG_INFINITY))).expect("set should succeed");
        original2.set(<Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(Some(f64::NEG_INFINITY))).expect("set should succeed");
        
        let json2 = original2.to_json().expect("to_json() should succeed");
        let restored2 = FloatFieldsRecord::from_json(json2).expect("from_json() should succeed");
        
        let restored_f32_2 = restored2.get(<Entity as LifeModelTrait>::Column::F32Field);
        match restored_f32_2 {
            Some(sea_query::Value::Float(Some(v))) => {
                assert!(v.is_infinite() && v.is_sign_negative(), "f32 -Infinity should be preserved");
            }
            _ => panic!("Expected Float(Some(-Infinity)), got {:?}", restored_f32_2),
        }
    }

    #[test]
    fn test_json_with_option_float_nan_and_infinity() {
        // EDGE CASE: Option<f32> and Option<f64> fields with NaN/infinity
        use float_tests::*;
        use serde_json::json;
        use lifeguard::LifeModelTrait;
        
        // Create a test entity with Option float fields
        mod option_float_tests {
            use super::super::*;
            
            #[derive(LifeModel, LifeRecord)]
            #[table_name = "option_float_fields"]
            pub struct OptionFloatFields {
                #[primary_key]
                pub id: i32,
                pub f32_field: Option<f32>,
                pub f64_field: Option<f64>,
            }
        }
        
        use option_float_tests::*;
        
        let mut record = OptionFloatFieldsRecord::new();
        record.set_id(1);
        
        // Test Option<f32> with NaN
        record.set(<option_float_tests::Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(f32::NAN))).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed");
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("f32_field"), Some(&json!("NaN")), "Option<f32> NaN should be serialized as string");
        
        // Test Option<f64> with infinity
        record.set(<option_float_tests::Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(Some(f64::INFINITY))).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed");
        let obj = json.as_object().unwrap();
        assert_eq!(obj.get("f64_field"), Some(&json!("Infinity")), "Option<f64> infinity should be serialized as string");
        
        // Test Option fields with None (should be null, not string)
        record.set(<option_float_tests::Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(None)).expect("set should succeed");
        record.set(<option_float_tests::Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(None)).expect("set should succeed");
        let json = record.to_json().expect("to_json() should succeed");
        let obj = json.as_object().unwrap();
        // None values should not appear in JSON (only set fields are included)
        // But if they were included, they'd be null, not the string "NaN"
        assert!(!obj.contains_key("f32_field") || obj.get("f32_field") == Some(&json!(null)), "Option None should be null or omitted");
    }

    #[test]
    fn test_nan_comparison_edge_cases() {
        // EDGE CASE: NaN comparison behavior
        // NaN != NaN in Rust (IEEE 754 standard), so Value comparisons with NaN will also fail
        // This is expected behavior and documents an important edge case
        use float_tests::*;
        use lifeguard::LifeModelTrait;
        
        let mut record1 = FloatFieldsRecord::new();
        record1.set_id(1);
        record1.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(f32::NAN))).expect("set should succeed");
        
        let mut record2 = FloatFieldsRecord::new();
        record2.set_id(1);
        record2.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(f32::NAN))).expect("set should succeed");
        
        // Both records have NaN
        let val1 = record1.get(<Entity as LifeModelTrait>::Column::F32Field);
        let val2 = record2.get(<Entity as LifeModelTrait>::Column::F32Field);
        
        // Extract the actual f32 values to verify they're both NaN
        match (&val1, &val2) {
            (Some(sea_query::Value::Float(Some(v1))), Some(sea_query::Value::Float(Some(v2)))) => {
                // Both should be NaN
                assert!(v1.is_nan() && v2.is_nan(), "Both values should be NaN");
                
                // NaN != NaN in Rust (IEEE 754 standard)
                // This means Value::Float(Some(NaN)) != Value::Float(Some(NaN)) when using PartialEq
                // This is expected behavior and documents an important edge case
                assert_ne!(v1, v2, "NaN != NaN in Rust (IEEE 754 standard - this is expected behavior)");
                
                // The Value variants themselves also won't compare equal because they contain NaN
                // This is a limitation of using PartialEq with NaN values
                assert_ne!(val1, val2, "Value::Float(Some(NaN)) != Value::Float(Some(NaN)) because NaN != NaN");
            }
            _ => panic!("Expected Float(Some(NaN)) values"),
        }
    }

    #[test]
    fn test_mixed_normal_and_special_float_values() {
        // EDGE CASE: Record with mix of normal numbers and NaN/infinity
        use float_tests::*;
        use serde_json::json;
        use lifeguard::LifeModelTrait;
        
        let mut record = FloatFieldsRecord::new();
        record.set_id(1);
        record.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(3.14))).expect("set should succeed");
        record.set(<Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(Some(f64::NAN))).expect("set should succeed");
        
        let json = record.to_json().expect("to_json() should succeed");
        let obj = json.as_object().unwrap();
        
        // Normal number should be a number
        assert!(obj.get("f32_field").unwrap().is_number(), "Normal f32 should be a number");
        // NaN should be a string
        assert_eq!(obj.get("f64_field"), Some(&json!("NaN")), "NaN should be serialized as string");
        
        // Test the reverse: normal f64, special f32
        record.set(<Entity as LifeModelTrait>::Column::F32Field, sea_query::Value::Float(Some(f32::INFINITY))).expect("set should succeed");
        record.set(<Entity as LifeModelTrait>::Column::F64Field, sea_query::Value::Double(Some(2.71828))).expect("set should succeed");
        
        let json = record.to_json().expect("to_json() should succeed");
        let obj = json.as_object().unwrap();
        
        assert_eq!(obj.get("f32_field"), Some(&json!("Infinity")), "Infinity should be serialized as string");
        assert!(obj.get("f64_field").unwrap().is_number(), "Normal f64 should be a number");
    }

    #[test]
    fn test_json_roundtrip_with_column_name_attribute() {
        // Test that JSON roundtrip works when #[column_name] attribute is used
        // This verifies that to_json() and from_json() use the same key names
        use column_name_tests::*;
        
        let mut original = UserWithRenamedColumnsRecord::new();
        original.set_id(100);
        original.set_firstName("John".to_string());
        original.set_email("john@example.com".to_string());
        
        // Record -> JSON (should use column names: "user_name", "email_address")
        let json = original.to_json().expect("to_json() should succeed");
        
        // Verify JSON uses column names, not field names
        let json_obj = json.as_object().expect("JSON should be an object");
        assert!(json_obj.contains_key("user_name"), "JSON should contain 'user_name' key (column name)");
        assert!(!json_obj.contains_key("firstName"), "JSON should NOT contain 'firstName' key (field name)");
        assert!(json_obj.contains_key("email_address"), "JSON should contain 'email_address' key (column name)");
        assert!(!json_obj.contains_key("email"), "JSON should NOT contain 'email' key (field name)");
        
        // JSON -> Record (should deserialize using column names via serde rename)
        let restored = UserWithRenamedColumnsRecord::from_json(json).expect("from_json() should succeed");
        
        // Verify all fields match
        let original_id = original.get(<column_name_tests::Entity as LifeModelTrait>::Column::Id);
        let restored_id = restored.get(<column_name_tests::Entity as LifeModelTrait>::Column::Id);
        assert_eq!(original_id, restored_id);
        
        let original_first_name = original.get(<column_name_tests::Entity as LifeModelTrait>::Column::FirstName);
        let restored_first_name = restored.get(<column_name_tests::Entity as LifeModelTrait>::Column::FirstName);
        assert_eq!(original_first_name, restored_first_name);
        
        let original_email = original.get(<column_name_tests::Entity as LifeModelTrait>::Column::Email);
        let restored_email = restored.get(<column_name_tests::Entity as LifeModelTrait>::Column::Email);
        assert_eq!(original_email, restored_email);
    }

    // ============================================================================
    // ACTIVEMODELBEHAVIOR HOOK TESTS
    // ============================================================================

    #[test]
    fn test_active_model_behavior_default_implementations() {
        // Test that default implementations exist and return Ok(())
        use lifeguard::ActiveModelBehavior;
        
        // UserRecord needs to implement ActiveModelBehavior to use hooks
        // In practice, users would implement this manually
        #[derive(Clone, Debug)]
        struct TestRecordDefault {
            inner: UserRecord,
        }
        
        impl lifeguard::ActiveModelTrait for TestRecordDefault {
            type Entity = Entity;
            type Model = UserModel;
            
            fn get(&self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.get(column)
            }
            
            fn set(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column, value: sea_query::Value) -> Result<(), lifeguard::ActiveModelError> {
                self.inner.set(column, value)
            }
            
            fn take(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.take(column)
            }
            
            fn reset(&mut self) {
                self.inner.reset()
            }
            
            fn insert<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn update<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn save<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn delete<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<(), lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn from_json(_json: serde_json::Value) -> Result<Self, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn to_json(&self) -> Result<serde_json::Value, lifeguard::ActiveModelError> {
                self.inner.to_json()
            }
        }
        
        // Implement ActiveModelBehavior with default implementations
        impl ActiveModelBehavior for TestRecordDefault {}
        
        let mut record = TestRecordDefault {
            inner: UserRecord::new(),
        };
        
        // All default implementations should return Ok(())
        assert!(record.before_insert().is_ok());
        assert!(record.before_update().is_ok());
        assert!(record.before_save().is_ok());
        assert!(record.before_delete().is_ok());
        
        let model = UserModel {
            id: 1,
            name: "Test".to_string(),
            email: "test@example.com".to_string(),
        };
        
        assert!(record.after_insert(&model).is_ok());
        assert!(record.after_update(&model).is_ok());
        assert!(record.after_save(&model).is_ok());
        assert!(record.after_delete().is_ok());
    }

    #[test]
    fn test_active_model_behavior_trait_bounds() {
        // Test that ActiveModelBehavior requires ActiveModelTrait
        use lifeguard::{ActiveModelBehavior, ActiveModelTrait};
        
        // Verify that a type implementing both traits compiles
        #[derive(Clone, Debug)]
        struct TestRecordBounds {
            inner: UserRecord,
        }
        
        impl ActiveModelTrait for TestRecordBounds {
            type Entity = Entity;
            type Model = UserModel;
            
            fn get(&self, _column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                None
            }
            
            fn set(&mut self, _column: <Entity as lifeguard::LifeModelTrait>::Column, _value: sea_query::Value) -> Result<(), lifeguard::ActiveModelError> {
                Ok(())
            }
            
            fn take(&mut self, _column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                None
            }
            
            fn reset(&mut self) {}
            
            fn insert<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn update<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn save<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn delete<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<(), lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn from_json(_json: serde_json::Value) -> Result<Self, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn to_json(&self) -> Result<serde_json::Value, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
        }
        
        impl ActiveModelBehavior for TestRecordBounds {}
        
        // Verify TestRecordBounds implements both traits
        fn _verify_traits<T: ActiveModelTrait + ActiveModelBehavior>() {}
        _verify_traits::<TestRecordBounds>();
    }

    #[test]
    fn test_active_model_behavior_hooks_can_return_errors() {
        // Test that hooks can return errors to abort operations
        use lifeguard::{ActiveModelBehavior, ActiveModelError};
        
        // Create a custom implementation that returns errors
        #[derive(Clone, Debug)]
        struct ErrorRecord {
            inner: UserRecord,
            should_error: bool,
        }
        
        impl lifeguard::ActiveModelTrait for ErrorRecord {
            type Entity = Entity;
            type Model = UserModel;
            
            fn get(&self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.get(column)
            }
            
            fn set(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column, value: sea_query::Value) -> Result<(), ActiveModelError> {
                self.inner.set(column, value)
            }
            
            fn take(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.take(column)
            }
            
            fn reset(&mut self) {
                self.inner.reset()
            }
            
            fn insert<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, ActiveModelError> {
                Err(ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn update<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, ActiveModelError> {
                Err(ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn save<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, ActiveModelError> {
                Err(ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn delete<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<(), ActiveModelError> {
                Err(ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn from_json(_json: serde_json::Value) -> Result<Self, ActiveModelError> {
                Err(ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn to_json(&self) -> Result<serde_json::Value, ActiveModelError> {
                self.inner.to_json()
            }
        }
        
        impl ActiveModelBehavior for ErrorRecord {
            fn before_insert(&mut self) -> Result<(), ActiveModelError> {
                if self.should_error {
                    Err(ActiveModelError::Other("before_insert error".to_string()))
                } else {
                    Ok(())
                }
            }
            
            fn before_update(&mut self) -> Result<(), ActiveModelError> {
                if self.should_error {
                    Err(ActiveModelError::Other("before_update error".to_string()))
                } else {
                    Ok(())
                }
            }
            
            fn before_save(&mut self) -> Result<(), ActiveModelError> {
                if self.should_error {
                    Err(ActiveModelError::Other("before_save error".to_string()))
                } else {
                    Ok(())
                }
            }
            
            fn before_delete(&mut self) -> Result<(), ActiveModelError> {
                if self.should_error {
                    Err(ActiveModelError::Other("before_delete error".to_string()))
                } else {
                    Ok(())
                }
            }
        }
        
        // Test that errors from hooks are returned
        let mut record = ErrorRecord {
            inner: UserRecord::new(),
            should_error: true,
        };
        
        assert!(record.before_insert().is_err());
        assert!(record.before_update().is_err());
        assert!(record.before_save().is_err());
        assert!(record.before_delete().is_err());
        
        // Test that hooks return Ok when should_error is false
        record.should_error = false;
        assert!(record.before_insert().is_ok());
        assert!(record.before_update().is_ok());
        assert!(record.before_save().is_ok());
        assert!(record.before_delete().is_ok());
    }

    #[test]
    fn test_active_model_behavior_after_hooks_receive_model() {
        // Test that after hooks receive the correct model parameter
        use lifeguard::ActiveModelBehavior;
        
        #[derive(Clone, Debug)]
        struct TestRecordAfter {
            inner: UserRecord,
        }
        
        impl lifeguard::ActiveModelTrait for TestRecordAfter {
            type Entity = Entity;
            type Model = UserModel;
            
            fn get(&self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.get(column)
            }
            
            fn set(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column, value: sea_query::Value) -> Result<(), lifeguard::ActiveModelError> {
                self.inner.set(column, value)
            }
            
            fn take(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.take(column)
            }
            
            fn reset(&mut self) {
                self.inner.reset()
            }
            
            fn insert<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn update<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn save<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn delete<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<(), lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn from_json(_json: serde_json::Value) -> Result<Self, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn to_json(&self) -> Result<serde_json::Value, lifeguard::ActiveModelError> {
                self.inner.to_json()
            }
        }
        
        impl ActiveModelBehavior for TestRecordAfter {}
        
        let mut record = TestRecordAfter {
            inner: UserRecord::new(),
        };
        
        let model = UserModel {
            id: 42,
            name: "Test".to_string(),
            email: "test@example.com".to_string(),
        };
        
        // after_insert should receive the model
        assert!(record.after_insert(&model).is_ok());
        
        // after_update should receive the model
        assert!(record.after_update(&model).is_ok());
        
        // after_save should receive the model
        assert!(record.after_save(&model).is_ok());
    }

    #[test]
    fn test_active_model_behavior_hooks_can_modify_record() {
        // Test that hooks can modify the record (via set())
        use lifeguard::{ActiveModelBehavior, ActiveModelTrait, LifeModelTrait};
        
        #[derive(Clone, Debug)]
        struct ModifyingRecord {
            inner: UserRecord,
        }
        
        impl lifeguard::ActiveModelTrait for ModifyingRecord {
            type Entity = Entity;
            type Model = UserModel;
            
            fn get(&self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.get(column)
            }
            
            fn set(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column, value: sea_query::Value) -> Result<(), lifeguard::ActiveModelError> {
                self.inner.set(column, value)
            }
            
            fn take(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.take(column)
            }
            
            fn reset(&mut self) {
                self.inner.reset()
            }
            
            fn insert<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn update<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn save<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn delete<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<(), lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn from_json(_json: serde_json::Value) -> Result<Self, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn to_json(&self) -> Result<serde_json::Value, lifeguard::ActiveModelError> {
                self.inner.to_json()
            }
        }
        
        impl ActiveModelBehavior for ModifyingRecord {
            fn before_insert(&mut self) -> Result<(), lifeguard::ActiveModelError> {
                // Modify the record in before_insert
                self.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(Some("Modified in before_insert".to_string())))?;
                Ok(())
            }
            
            fn before_update(&mut self) -> Result<(), lifeguard::ActiveModelError> {
                // Modify the record in before_update
                self.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(Some("Modified in before_update".to_string())))?;
                Ok(())
            }
        }
        
        let mut record = ModifyingRecord {
            inner: UserRecord::new(),
        };
        
        // Call before_insert and verify it can modify the record
        assert!(record.before_insert().is_ok());
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some());
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "Modified in before_insert"),
            _ => panic!("Expected String(Some(\"Modified in before_insert\"))"),
        }
        
        // Reset and test before_update
        record.reset();
        assert!(record.before_update().is_ok());
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        assert!(name_value.is_some());
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "Modified in before_update"),
            _ => panic!("Expected String(Some(\"Modified in before_update\"))"),
        }
    }

    #[test]
    fn test_active_model_behavior_hook_execution_order() {
        // Test that hooks are called in the correct order
        // This is verified by checking that before hooks are called before after hooks
        // and that save() calls both before_save and before_insert/before_update
        use lifeguard::ActiveModelBehavior;
        
        // The execution order should be:
        // insert(): before_insert -> [operation] -> after_insert
        // update(): before_update -> [operation] -> after_update
        // save(): before_save -> [insert/update] -> after_save (which internally calls before_insert/update and after_insert/update)
        // delete(): before_delete -> [operation] -> after_delete
        
        #[derive(Clone, Debug)]
        struct TestRecordOrder {
            inner: UserRecord,
        }
        
        impl lifeguard::ActiveModelTrait for TestRecordOrder {
            type Entity = Entity;
            type Model = UserModel;
            
            fn get(&self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.get(column)
            }
            
            fn set(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column, value: sea_query::Value) -> Result<(), lifeguard::ActiveModelError> {
                self.inner.set(column, value)
            }
            
            fn take(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.take(column)
            }
            
            fn reset(&mut self) {
                self.inner.reset()
            }
            
            fn insert<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn update<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn save<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn delete<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<(), lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn from_json(_json: serde_json::Value) -> Result<Self, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn to_json(&self) -> Result<serde_json::Value, lifeguard::ActiveModelError> {
                self.inner.to_json()
            }
        }
        
        impl ActiveModelBehavior for TestRecordOrder {}
        
        // We can't easily test the full order without a mock executor,
        // but we can verify the hooks exist and can be called
        let mut record = TestRecordOrder {
            inner: UserRecord::new(),
        };
        
        // Verify all hooks can be called
        assert!(record.before_insert().is_ok());
        assert!(record.before_update().is_ok());
        assert!(record.before_save().is_ok());
        assert!(record.before_delete().is_ok());
        
        let model = UserModel {
            id: 1,
            name: "Test".to_string(),
            email: "test@example.com".to_string(),
        };
        
        assert!(record.after_insert(&model).is_ok());
        assert!(record.after_update(&model).is_ok());
        assert!(record.after_save(&model).is_ok());
        assert!(record.after_delete().is_ok());
    }

    #[test]
    fn test_active_model_behavior_save_hooks_vs_insert_update_hooks() {
        // Test that save() calls before_save/after_save in addition to insert/update hooks
        // The order should be:
        // save() -> before_save -> [before_insert or before_update] -> [operation] -> [after_insert or after_update] -> after_save
        use lifeguard::ActiveModelBehavior;
        
        #[derive(Clone, Debug)]
        struct TestRecordSave {
            inner: UserRecord,
        }
        
        impl lifeguard::ActiveModelTrait for TestRecordSave {
            type Entity = Entity;
            type Model = UserModel;
            
            fn get(&self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.get(column)
            }
            
            fn set(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column, value: sea_query::Value) -> Result<(), lifeguard::ActiveModelError> {
                self.inner.set(column, value)
            }
            
            fn take(&mut self, column: <Entity as lifeguard::LifeModelTrait>::Column) -> Option<sea_query::Value> {
                self.inner.take(column)
            }
            
            fn reset(&mut self) {
                self.inner.reset()
            }
            
            fn insert<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn update<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn save<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn delete<E: lifeguard::LifeExecutor>(&self, _executor: &E) -> Result<(), lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn from_json(_json: serde_json::Value) -> Result<Self, lifeguard::ActiveModelError> {
                Err(lifeguard::ActiveModelError::Other("not implemented".to_string()))
            }
            
            fn to_json(&self) -> Result<serde_json::Value, lifeguard::ActiveModelError> {
                self.inner.to_json()
            }
        }
        
        impl ActiveModelBehavior for TestRecordSave {}
        
        // We can't test the full execution without a mock executor,
        // but we can verify that save() hooks are separate from insert/update hooks
        let mut record = TestRecordSave {
            inner: UserRecord::new(),
        };
        
        // All hooks should be callable independently
        assert!(record.before_save().is_ok());
        assert!(record.before_insert().is_ok());
        assert!(record.before_update().is_ok());
        
        let model = UserModel {
            id: 1,
            name: "Test".to_string(),
            email: "test@example.com".to_string(),
        };
        
        assert!(record.after_save(&model).is_ok());
        assert!(record.after_insert(&model).is_ok());
        assert!(record.after_update(&model).is_ok());
    }

    // Note: Full hook execution tests with actual database operations require integration tests
    // The actual hook calls in insert/update/save/delete are tested in integration tests
    // Here we verify the trait is properly implemented and hooks can be overridden

    // INSERT Edge Cases
    // ============================================================================

    #[test]
    fn test_insert_edge_case_empty_record() {
        // EDGE CASE: Empty record should fail insert (no fields set)
        let record = UserRecord::new();
        
        // Verify record is empty
        assert!(record.dirty_fields().is_empty());
        
        // insert() should fail with "No fields set for insert" error
        // We can't test this without an executor, but we can verify the logic exists
        // The macro generates: if columns.is_empty() { return Err(...) }
        let _ = record;
    }

    #[test]
    fn test_insert_edge_case_only_auto_increment_pk_set() {
        // EDGE CASE: Only auto-increment PK set should skip PK in INSERT
        let mut record = UserRecord::new();
        record.set_id(1); // Auto-increment PK (id is primary_key, auto_increment by default)
        
        // The INSERT logic should skip auto-increment PKs if they're set
        // But since id is the only field set, and it's auto-increment, columns will be empty
        // This should result in "No fields set for insert" error
        assert!(record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    #[test]
    fn test_insert_edge_case_auto_increment_pk_with_other_fields() {
        // EDGE CASE: Auto-increment PK + other fields should include other fields, skip PK
        let mut record = UserRecord::new();
        record.set_id(1); // Auto-increment PK (should be skipped)
        record.set_name("John".to_string()); // Should be included
        record.set_email("john@example.com".to_string()); // Should be included
        
        // INSERT should include name and email, but skip id (auto-increment)
        assert!(record.dirty_fields().contains(&"id".to_string()));
        assert!(record.dirty_fields().contains(&"name".to_string()));
        assert!(record.dirty_fields().contains(&"email".to_string()));
        let _ = record;
    }

    #[test]
    fn test_insert_edge_case_only_nullable_fields() {
        // EDGE CASE: Only nullable fields set (if we had any)
        // For User entity, all fields are non-nullable, so this test is conceptual
        let mut record = UserRecord::new();
        record.set_name("John".to_string());
        
        // INSERT should work with just name (though email is required in Model)
        // But insert() only checks if fields are set, not if all required fields are set
        assert!(record.dirty_fields().contains(&"name".to_string()));
        let _ = record;
    }

    #[test]
    fn test_insert_edge_case_all_fields_including_auto_increment_pk() {
        // EDGE CASE: All fields set including auto-increment PK
        let mut record = UserRecord::new();
        record.set_id(1); // Should be skipped (auto-increment)
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // INSERT should include name and email, skip id
        assert_eq!(record.dirty_fields().len(), 3);
        let _ = record;
    }

    // UPDATE Edge Cases
    // ============================================================================

    #[test]
    fn test_update_edge_case_no_primary_key() {
        // EDGE CASE: Update without primary key should fail
        let mut record = UserRecord::new();
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        // id (PK) is not set
        
        // update() should fail with PrimaryKeyRequired error
        // The macro generates: if self.id.is_none() { return Err(PrimaryKeyRequired) }
        assert!(!record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    #[test]
    fn test_update_edge_case_only_primary_key_set() {
        // EDGE CASE: Only primary key set, no dirty fields
        let mut record = UserRecord::new();
        record.set_id(1);
        // No other fields set
        
        // update() should succeed (PK is set), but no SET clauses will be added
        // This is valid - UPDATE with no SET clauses is a no-op
        assert!(record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    #[test]
    fn test_update_edge_case_primary_key_and_dirty_fields() {
        // EDGE CASE: Primary key + dirty fields should update only dirty fields
        let mut record = UserRecord::new();
        record.set_id(1); // PK (required)
        record.set_name("John".to_string()); // Dirty field
        // email is not set (not dirty)
        
        // update() should include only name in SET clause, not email
        assert!(record.dirty_fields().contains(&"id".to_string()));
        assert!(record.dirty_fields().contains(&"name".to_string()));
        assert!(!record.dirty_fields().contains(&"email".to_string()));
        let _ = record;
    }

    #[test]
    fn test_update_edge_case_all_fields_dirty() {
        // EDGE CASE: All fields dirty (PK + all other fields)
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // update() should include name and email in SET clause (PK is used in WHERE)
        assert_eq!(record.dirty_fields().len(), 3);
        let _ = record;
    }

    #[test]
    fn test_update_edge_case_setting_none_for_nullable_field() {
        // EDGE CASE: Setting None for nullable field (if we had nullable fields)
        // For User entity, all fields are non-nullable, so this is conceptual
        // The logic would be: if let Some(value) = self.get(...) { query.value(...) }
        // So None values are automatically skipped (not included in SET clause)
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        
        // Setting name to None should remove it from dirty_fields
        record.set(<Entity as LifeModelTrait>::Column::Name, sea_query::Value::String(None)).unwrap();
        // After setting to None, name should not be in dirty_fields (or should be None)
        let _ = record;
    }

    // DELETE Edge Cases
    // ============================================================================

    #[test]
    fn test_delete_edge_case_no_primary_key() {
        // EDGE CASE: Delete without primary key should fail
        let mut record = UserRecord::new();
        record.set_name("John".to_string());
        // id (PK) is not set
        
        // delete() should fail with PrimaryKeyRequired error
        assert!(!record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    #[test]
    fn test_delete_edge_case_only_primary_key_set() {
        // EDGE CASE: Only primary key set (valid for DELETE)
        let mut record = UserRecord::new();
        record.set_id(1);
        // No other fields needed for DELETE
        
        // delete() should succeed with just PK
        assert!(record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    #[test]
    fn test_delete_edge_case_primary_key_and_other_fields() {
        // EDGE CASE: Primary key + other fields (DELETE only needs PK)
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // delete() should succeed (only uses PK in WHERE clause)
        assert_eq!(record.dirty_fields().len(), 3);
        let _ = record;
    }

    // SAVE Edge Cases
    // ============================================================================

    #[test]
    fn test_save_edge_case_no_primary_key() {
        // EDGE CASE: Save without primary key should route to insert
        let mut record = UserRecord::new();
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        // id (PK) is not set
        
        // save() should route to insert()
        // The macro generates: if has_primary_key { update() } else { insert() }
        assert!(!record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    #[test]
    fn test_save_edge_case_with_primary_key() {
        // EDGE CASE: Save with primary key should route to update
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        
        // save() should route to update()
        assert!(record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    #[test]
    fn test_save_edge_case_update_fails_then_insert() {
        // EDGE CASE: Save with PK, update fails (no rows), then insert
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        
        // save() logic: if has_primary_key {
        //     match update() {
        //         Ok(model) => Ok(model),
        //         Err(DatabaseError(_)) => insert(), // Update failed, try insert
        //         Err(e) => Err(e),
        //     }
        // }
        // This handles the case where PK exists but record doesn't (upsert behavior)
        assert!(record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    // Type Conversion Edge Cases in set()
    // ============================================================================

    #[test]
    fn test_set_edge_case_invalid_type_for_int_field() {
        // EDGE CASE: Setting String value for Int field should fail
        let mut record = UserRecord::new();
        
        let result = record.set(
            <Entity as LifeModelTrait>::Column::Id,
            sea_query::Value::String(Some("invalid".to_string()))
        );
        
        assert!(result.is_err(), "set() should fail for invalid type");
        let error = result.unwrap_err();
        assert!(error.to_string().contains("Invalid value type"), "Error should indicate invalid type");
    }

    #[test]
    fn test_set_edge_case_invalid_type_for_string_field() {
        // EDGE CASE: Setting Int value for String field should fail
        let mut record = UserRecord::new();
        
        let result = record.set(
            <Entity as LifeModelTrait>::Column::Name,
            sea_query::Value::Int(Some(42))
        );
        
        assert!(result.is_err(), "set() should fail for invalid type");
    }

    #[test]
    fn test_set_edge_case_none_for_non_nullable_field() {
        // EDGE CASE: Setting None for non-nullable field
        // This is allowed in the record (Option<T>), but will fail in to_model()
        let mut record = UserRecord::new();
        
        // Setting None for non-nullable field should succeed in set()
        let result = record.set(
            <Entity as LifeModelTrait>::Column::Name,
            sea_query::Value::String(None)
        );
        
        assert!(result.is_ok(), "set() should allow None for non-nullable fields");
        // But to_model() will fail if required fields are None
    }

    #[test]
    fn test_set_edge_case_valid_type_conversions() {
        // EDGE CASE: All valid type conversions should work
        let mut record = UserRecord::new();
        
        // Int field
        let result = record.set(
            <Entity as LifeModelTrait>::Column::Id,
            sea_query::Value::Int(Some(42))
        );
        assert!(result.is_ok(), "set() should work for Int -> i32");
        
        // String field
        let result = record.set(
            <Entity as LifeModelTrait>::Column::Name,
            sea_query::Value::String(Some("John".to_string()))
        );
        assert!(result.is_ok(), "set() should work for String -> String");
        
        // String field with None
        let result = record.set(
            <Entity as LifeModelTrait>::Column::Name,
            sea_query::Value::String(None)
        );
        assert!(result.is_ok(), "set() should work for String(None) -> Option<String>");
    }

    // Composite Primary Key Edge Cases
    // ============================================================================

    #[test]
    fn test_composite_pk_edge_case_partial_primary_key() {
        // EDGE CASE: Partial composite primary key should fail update/delete
        // For single PK entity, this is not applicable, but the logic exists
        let mut record = UserRecord::new();
        record.set_id(1); // Single PK, so this is complete
        
        // For composite PKs, all PK fields must be set
        // The macro generates: if self.pk1.is_none() || self.pk2.is_none() { return Err(PrimaryKeyRequired) }
        assert!(record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    #[test]
    fn test_composite_pk_edge_case_all_primary_keys_set() {
        // EDGE CASE: All composite primary keys set (valid)
        // For single PK entity, this is just the single PK
        let mut record = UserRecord::new();
        record.set_id(1);
        
        // All PKs are set, update/delete should work
        assert!(record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    // Auto-increment Edge Cases
    // ============================================================================

    #[test]
    fn test_auto_increment_edge_case_explicitly_set() {
        // EDGE CASE: Auto-increment PK explicitly set should be skipped in INSERT
        let mut record = UserRecord::new();
        record.set_id(1); // Auto-increment PK set explicitly
        
        // INSERT logic: if is_primary_key && is_auto_increment {
        //     if let Some(value) = self.get(...) { include } // Only if set
        // }
        // So if auto-increment PK is set, it WILL be included (user override)
        // But typically, auto-increment PKs are not set by user
        assert!(record.dirty_fields().contains(&"id".to_string()));
        let _ = record;
    }

    #[test]
    fn test_auto_increment_edge_case_not_set() {
        // EDGE CASE: Auto-increment PK not set should be skipped in INSERT
        let mut record = UserRecord::new();
        // id (auto-increment PK) is not set
        record.set_name("John".to_string());
        
        // INSERT should skip id (auto-increment, not set), include name
        assert!(!record.dirty_fields().contains(&"id".to_string()));
        assert!(record.dirty_fields().contains(&"name".to_string()));
        let _ = record;
    }

    // Error Handling Edge Cases
    // ============================================================================

    #[test]
    fn test_error_edge_case_primary_key_required() {
        // EDGE CASE: PrimaryKeyRequired error type
        let error = lifeguard::ActiveModelError::PrimaryKeyRequired;
        let error_str = error.to_string();
        // The error message should indicate that a primary key is required
        // We just verify the error can be converted to string (exact message may vary)
        assert!(!error_str.is_empty(), "Error should have a non-empty string representation");
    }

    #[test]
    fn test_error_edge_case_database_error() {
        // EDGE CASE: DatabaseError error type
        let error = lifeguard::ActiveModelError::DatabaseError("test error".to_string());
        assert!(error.to_string().contains("test error"));
    }

    #[test]
    fn test_error_edge_case_other_error() {
        // EDGE CASE: Other error type
        let error = lifeguard::ActiveModelError::Other("custom error".to_string());
        assert!(error.to_string().contains("custom error"));
    }

    // Dirty Fields Tracking Edge Cases
    // ============================================================================

    #[test]
    fn test_dirty_fields_edge_case_after_set() {
        // EDGE CASE: Dirty fields after set()
        let mut record = UserRecord::new();
        assert!(record.dirty_fields().is_empty());
        
        record.set_name("John".to_string());
        assert!(record.dirty_fields().contains(&"name".to_string()));
        assert_eq!(record.dirty_fields().len(), 1);
    }

    #[test]
    fn test_dirty_fields_edge_case_after_reset() {
        // EDGE CASE: Dirty fields after reset()
        let mut record = UserRecord::new();
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        assert_eq!(record.dirty_fields().len(), 2);
        
        record.reset();
        assert!(record.dirty_fields().is_empty());
    }

    #[test]
    fn test_dirty_fields_edge_case_after_take() {
        // EDGE CASE: Dirty fields after take()
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        let _ = record.take(<Entity as LifeModelTrait>::Column::Name);
        // After take(), name should be None, but dirty_fields() might still show it
        // The exact behavior depends on implementation
        let _ = record;
    }

    #[test]
    fn test_dirty_fields_edge_case_is_dirty() {
        // EDGE CASE: is_dirty() with various states
        let mut record = UserRecord::new();
        assert!(!record.is_dirty());
        
        record.set_name("John".to_string());
        assert!(record.is_dirty());
        
        record.reset();
        assert!(!record.is_dirty());
    }

    // Round-trip Edge Cases
    // ============================================================================

    #[test]
    fn test_roundtrip_edge_case_model_to_record_to_model() {
        // EDGE CASE: Model -> Record -> Model round-trip
        let model = UserModel {
            id: 1,
            name: "John".to_string(),
            email: "john@example.com".to_string(),
        };
        
        let record = UserRecord::from_model(&model);
        assert_eq!(record.dirty_fields().len(), 3);
        
        let model2 = record.to_model();
        assert_eq!(model.id, model2.id);
        assert_eq!(model.name, model2.name);
        assert_eq!(model.email, model2.email);
    }

    #[test]
    fn test_roundtrip_edge_case_record_operations_preserve_state() {
        // EDGE CASE: Record operations preserve state correctly
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        
        // Get values
        let id_value = record.get(<Entity as LifeModelTrait>::Column::Id);
        let name_value = record.get(<Entity as LifeModelTrait>::Column::Name);
        
        assert!(id_value.is_some());
        assert!(name_value.is_some());
        
        // Values should match what was set
        match id_value.unwrap() {
            sea_query::Value::Int(Some(v)) => assert_eq!(v, 1),
            _ => panic!("Expected Int(Some(1))"),
        }
        
        match name_value.unwrap() {
            sea_query::Value::String(Some(v)) => assert_eq!(v, "John"),
            _ => panic!("Expected String(Some(\"John\"))"),
        }
    }

    // ============================================================================
    // ENTITY STATIC METHODS (Entity::insert, Entity::update, Entity::delete)
    // ============================================================================

    #[test]
    fn test_entity_insert_method_exists() {
        // Test that Entity::insert() static method exists and has correct signature
        // This is a compile-time check
        use lifeguard::{LifeModelTrait, ActiveModelTrait, LifeExecutor, ActiveModelError};
        
        fn _verify_insert_signature<E: LifeModelTrait, AM: ActiveModelTrait<Model = E::Model>, Ex: LifeExecutor>(
            _entity: E,
            _active_model: AM,
            _executor: &Ex,
        ) -> Result<E::Model, ActiveModelError> {
            // Entity::insert() should accept ActiveModel and executor, return Result<Model, ActiveModelError>
            E::insert(_active_model, _executor)
        }
        
        // Verify the method exists for Entity
        let _ = Entity::find(); // Entity implements LifeModelTrait
    }

    #[test]
    fn test_entity_update_method_exists() {
        // Test that Entity::update() static method exists and has correct signature
        // This is a compile-time check
        use lifeguard::{LifeModelTrait, ActiveModelTrait, LifeExecutor, ActiveModelError};
        
        fn _verify_update_signature<E: LifeModelTrait, AM: ActiveModelTrait<Model = E::Model>, Ex: LifeExecutor>(
            _entity: E,
            _active_model: AM,
            _executor: &Ex,
        ) -> Result<E::Model, ActiveModelError> {
            // Entity::update() should accept ActiveModel and executor, return Result<Model, ActiveModelError>
            E::update(_active_model, _executor)
        }
        
        // Verify the method exists for Entity
        let _ = Entity::find(); // Entity implements LifeModelTrait
    }

    #[test]
    fn test_entity_delete_method_exists() {
        // Test that Entity::delete() static method exists and has correct signature
        // This is a compile-time check
        use lifeguard::{LifeModelTrait, ActiveModelTrait, LifeExecutor, ActiveModelError};
        
        fn _verify_delete_signature<E: LifeModelTrait, AM: ActiveModelTrait<Model = E::Model>, Ex: LifeExecutor>(
            _entity: E,
            _active_model: AM,
            _executor: &Ex,
        ) -> Result<(), ActiveModelError> {
            // Entity::delete() should accept ActiveModel and executor, return Result<(), ActiveModelError>
            E::delete(_active_model, _executor)
        }
        
        // Verify the method exists for Entity
        let _ = Entity::find(); // Entity implements LifeModelTrait
    }

    #[test]
    fn test_entity_static_methods_delegate_to_active_model_trait() {
        // Test that Entity static methods delegate to ActiveModelTrait instance methods
        // This is a compile-time verification that the delegation pattern works
        
        // The static methods should accept any type that implements ActiveModelTrait
        // with the correct Model type, and delegate to the instance method
        
        let _record = UserRecord::new();
        // Entity::insert(record, executor) should call record.insert(executor)
        // Entity::update(record, executor) should call record.update(executor)
        // Entity::delete(record, executor) should call record.delete(executor)
        
        // This test verifies the types are compatible
        let _ = _record;
    }

    // ============================================================================
    // ACTIVEVALUE WRAPPER TESTS
    // ============================================================================

    #[test]
    fn test_active_value_set() {
        // Test ActiveValue::Set variant
        use lifeguard::ActiveValue;
        
        let value = ActiveValue::Set(sea_query::Value::Int(Some(42)));
        assert!(value.is_set());
        assert!(!value.is_not_set());
        assert!(!value.is_unset());
        
        let extracted = value.into_value();
        assert!(extracted.is_some());
        match extracted.unwrap() {
            sea_query::Value::Int(Some(v)) => assert_eq!(v, 42),
            _ => panic!("Expected Int(Some(42))"),
        }
    }

    #[test]
    fn test_active_value_not_set() {
        // Test ActiveValue::NotSet variant
        use lifeguard::ActiveValue;
        
        let value = ActiveValue::NotSet;
        assert!(!value.is_set());
        assert!(value.is_not_set());
        assert!(!value.is_unset());
        
        let extracted = value.into_value();
        assert!(extracted.is_none());
    }

    #[test]
    fn test_active_value_unset() {
        // Test ActiveValue::Unset variant
        use lifeguard::ActiveValue;
        
        let value = ActiveValue::Unset;
        assert!(!value.is_set());
        assert!(!value.is_not_set());
        assert!(value.is_unset());
        
        let extracted = value.into_value();
        assert!(extracted.is_none());
    }

    #[test]
    fn test_active_value_from_value() {
        // Test conversion from Option<Value>
        use lifeguard::ActiveValue;
        
        let value = ActiveValue::from_value(Some(sea_query::Value::Int(Some(42))));
        assert!(value.is_set());
        
        let value = ActiveValue::from_value(None);
        assert!(value.is_not_set());
    }

    #[test]
    fn test_active_value_from_trait() {
        // Test From trait implementations
        use lifeguard::ActiveValue;
        
        // From<Value>
        let value: ActiveValue = sea_query::Value::Int(Some(42)).into();
        assert!(value.is_set());
        
        // From<Option<Value>>
        let value: ActiveValue = Some(sea_query::Value::String(Some("test".to_string()))).into();
        assert!(value.is_set());
        
        let value: ActiveValue = None.into();
        assert!(value.is_not_set());
        
        // From<ActiveValue> for Option<Value>
        let active_value = ActiveValue::Set(sea_query::Value::Int(Some(42)));
        let option_value: Option<sea_query::Value> = active_value.into();
        assert!(option_value.is_some());
    }

    #[test]
    fn test_active_value_as_value() {
        // Test as_value() method
        use lifeguard::ActiveValue;
        
        let value = ActiveValue::Set(sea_query::Value::Int(Some(42)));
        let ref_value = value.as_value();
        assert!(ref_value.is_some());
        
        let value = ActiveValue::NotSet;
        let ref_value = value.as_value();
        assert!(ref_value.is_none());
    }

    #[test]
    fn test_active_model_trait_into_active_value() {
        // Test into_active_value() method on ActiveModelTrait
        use lifeguard::{ActiveModelTrait, LifeModelTrait};
        
        let mut record = UserRecord::new();
        record.set_id(1);
        record.set_name("John".to_string());
        record.set_email("john@example.com".to_string());
        
        // Test with set field
        let active_value = record.into_active_value(<Entity as LifeModelTrait>::Column::Id);
        assert!(active_value.is_set());
        
        // Test with another set field
        let active_value = record.into_active_value(<Entity as LifeModelTrait>::Column::Name);
        assert!(active_value.is_set());
        
        // Test with unset field (after reset)
        record.reset();
        let active_value = record.into_active_value(<Entity as LifeModelTrait>::Column::Id);
        assert!(active_value.is_not_set());
    }

    #[test]
    fn test_active_value_conversion_roundtrip() {
        // Test roundtrip conversion: Value -> ActiveValue -> Option<Value>
        use lifeguard::ActiveValue;
        
        let original = sea_query::Value::Int(Some(42));
        let active_value: ActiveValue = original.clone().into();
        let converted: Option<sea_query::Value> = active_value.into();
        
        assert_eq!(converted, Some(original));
    }

    #[test]
    fn test_active_value_all_variants() {
        // Test all ActiveValue variants
        use lifeguard::ActiveValue;
        
        let set = ActiveValue::Set(sea_query::Value::String(Some("test".to_string())));
        let not_set = ActiveValue::NotSet;
        let unset = ActiveValue::Unset;
        
        // Verify they're distinct
        assert_ne!(set, not_set);
        assert_ne!(set, unset);
        assert_ne!(not_set, unset);
        
        // Verify is_* methods
        assert!(set.is_set());
        assert!(not_set.is_not_set());
        assert!(unset.is_unset());
    }
}

