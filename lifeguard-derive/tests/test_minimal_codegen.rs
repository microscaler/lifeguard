//! Minimal test using codegen (not procedural macros)
//!
//! This test uses lifeguard-codegen to generate Entity, Model, Column, etc.
//! before compilation, avoiding E0223 errors from procedural macros.
//!
//! The generated code is in tests/generated/user.rs

// Include generated code (generated by lifeguard-codegen)
// Use include! macro to include the generated file
include!("generated/user.rs");

#[cfg(test)]
mod tests {
    use super::*;
    use lifeguard::{FromRow, LifeEntityName, LifeModelTrait};

    #[test]
    fn test_entity_exists() {
        // Verify User (Entity) unit struct exists and implements required traits
        let entity = User;

        // Test LifeEntityName
        assert_eq!(entity.table_name(), "users");
        assert_eq!(User::default().table_name(), "users");

        // Test Default
        let _default_entity = User::default();
    }

    #[test]
    fn test_column_enum_exists() {
        // Verify Column enum exists and implements Iden
        use sea_query::Iden;

        assert_eq!(Column::Id.unquoted(), "id");
        assert_eq!(Column::Name.unquoted(), "name");
        assert_eq!(Column::Email.unquoted(), "email");
    }

    #[test]
    fn test_primary_key_enum_exists() {
        // Verify PrimaryKey enum exists
        let _pk = PrimaryKey::Id;
    }

    #[test]
    fn test_model_struct_exists() {
        // Verify Model struct exists and can be instantiated
        let model = UserModel {
            id: 1,
            email: "test@example.com".to_string(),
            name: Some("Test User".to_string()),
        };

        assert_eq!(model.id, 1);
        assert_eq!(model.email, "test@example.com");
        assert_eq!(model.name, Some("Test User".to_string()));
    }

    #[test]
    fn test_from_row_trait_implemented() {
        // Verify FromRow trait is implemented for UserModel
        fn _verify_from_row<T: FromRow>() {}
        _verify_from_row::<UserModel>();
    }

    #[test]
    fn test_life_model_trait_implemented() {
        // Verify LifeModelTrait is implemented for User (Entity)
        fn _verify_life_model_trait<E: LifeModelTrait>() {}
        _verify_life_model_trait::<User>();

        // Verify the associated type Model is correct
        fn _verify_model_type<E: LifeModelTrait<Model = UserModel>>() {}
        _verify_model_type::<User>();
    }

    #[test]
    fn test_find_method_works() {
        // Verify User::find() returns SelectQuery
        let _query = User::find();
        // Just verify it compiles - actual execution requires an executor
    }

    #[test]
    fn test_entity_table_name_constant() {
        // Verify User::TABLE_NAME constant exists
        assert_eq!(User::TABLE_NAME, "users");
    }

    // ============================================================================
    // Option Type Detection Tests - Verifies Option<String> handling
    // ============================================================================

    #[test]
    fn test_option_string_detection_some() {
        // CRITICAL TEST: Verify Option<String> generates String values correctly
        use lifeguard::ModelTrait;

        let model = UserModel {
            id: 1,
            email: "test@example.com".to_string(),
            name: Some("John Doe".to_string()),
        };

        let name_value = model.get(Column::Name);
        
        // Verify it's String(Some("John Doe")), not String(None) or wrong type
        match name_value {
            sea_query::Value::String(Some(ref s)) if s == "John Doe" => {
                // Correct! Option<String> with Some("John Doe") generates String(Some("John Doe"))
            }
            sea_query::Value::String(None) => {
                panic!("BUG: Option<String> with Some(_) generated String(None)! This indicates the Option detection fix is broken.");
            }
            sea_query::Value::Int(_) | sea_query::Value::BigInt(_) | sea_query::Value::SmallInt(_) => {
                panic!("BUG: Option<String> generated integer value instead of String! This indicates the Option detection fix is broken.");
            }
            _ => {
                panic!("Option<String> generated unexpected value: {:?}", name_value);
            }
        }
    }

    #[test]
    fn test_option_string_detection_none() {
        // CRITICAL TEST: Verify Option<String> with None generates String(None) correctly
        use lifeguard::ModelTrait;

        let model = UserModel {
            id: 1,
            email: "test@example.com".to_string(),
            name: None,
        };

        let name_value = model.get(Column::Name);
        
        // Verify it's String(None)
        match name_value {
            sea_query::Value::String(None) => {
                // Correct! Option<String> with None generates String(None)
            }
            sea_query::Value::String(Some(_)) => {
                panic!("BUG: Option<String> with None generated String(Some(_))! This indicates the Option detection fix is broken.");
            }
            _ => {
                panic!("Option<String> with None generated unexpected value type: {:?}", name_value);
            }
        }
    }

    #[test]
    fn test_option_string_vs_non_option_string() {
        // Verify Option<String> and String are handled differently
        use lifeguard::ModelTrait;

        let model = UserModel {
            id: 1,
            email: "test@example.com".to_string(), // Non-Option String
            name: Some("John".to_string()),        // Option<String>
        };

        // Non-Option String should generate String(Some(_))
        let email_value = model.get(Column::Email);
        assert!(matches!(email_value, sea_query::Value::String(Some(_))), 
            "Non-Option String should generate String(Some(_)), got: {:?}", email_value);

        // Option<String> with Some should also generate String(Some(_))
        let name_value = model.get(Column::Name);
        assert!(matches!(name_value, sea_query::Value::String(Some(_))), 
            "Option<String> with Some should generate String(Some(_)), got: {:?}", name_value);

        // Option<String> with None should generate String(None)
        let model_none = UserModel {
            id: 1,
            email: "test@example.com".to_string(),
            name: None,
        };
        let name_none_value = model_none.get(Column::Name);
        assert!(matches!(name_none_value, sea_query::Value::String(None)), 
            "Option<String> with None should generate String(None), got: {:?}", name_none_value);
    }
}
