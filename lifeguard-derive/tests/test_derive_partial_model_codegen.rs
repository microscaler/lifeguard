//! Tests for DerivePartialModel using codegen (avoids E0284 errors)
//!
//! This test file uses codegen-generated partial models instead of direct macro expansion.
//! The generated code uses fully qualified paths (crate::UserEntity), avoiding the E0284
//! type inference errors that occur during macro expansion.

use lifeguard::PartialModelTrait;
use lifeguard::{LifeModelTrait, LifeEntityName};

// Test entity for partial models (manually defined, similar to DeriveRelation tests)
#[derive(Default, Copy, Clone)]
pub struct UserEntity;

impl sea_query::Iden for UserEntity {
    fn unquoted(&self) -> &str {
        "users"
    }
}

impl LifeEntityName for UserEntity {
    fn table_name(&self) -> &'static str {
        "users"
    }
}

impl LifeModelTrait for UserEntity {
    type Model = UserModel;
    type Column = UserColumn;
}

pub struct UserModel;

#[derive(Copy, Clone, Debug)]
pub enum UserColumn {
    Id,
    Name,
    Email,
    Age,
}

impl sea_query::Iden for UserColumn {
    fn unquoted(&self) -> &str {
        match self {
            UserColumn::Id => "id",
            UserColumn::Name => "name",
            UserColumn::Email => "email",
            UserColumn::Age => "age",
        }
    }
}

impl sea_query::IdenStatic for UserColumn {
    fn as_str(&self) -> &'static str {
        match self {
            UserColumn::Id => "id",
            UserColumn::Name => "name",
            UserColumn::Email => "email",
            UserColumn::Age => "age",
        }
    }
}

// Include codegen-generated partial models
// These files are generated by: cargo run --bin lifeguard-codegen -- partial-model ...
mod generated {
    // Make UserEntity available in the generated module's scope
    // UserEntity is not directly used here, but may be referenced in generated code
    
    // Include generated partial models
    include!("generated/user_partial.rs");
    include!("generated/user_partial_with_column_name.rs");
    include!("generated/user_id_only.rs");
}

// Re-export for use in tests
pub use generated::{UserPartial, UserPartialWithColumnName, UserIdOnly};

#[test]
fn test_codegen_partial_model_basic() {
    // Verify PartialModelTrait is implemented
    let columns = UserPartial::selected_columns();
    assert_eq!(columns, vec!["id", "name"]);
    
    // Verify Entity type is correct
    fn _test_entity_type<P: PartialModelTrait<Entity = UserEntity>>() {}
    _test_entity_type::<UserPartial>();
}

#[test]
fn test_codegen_partial_model_with_column_name() {
    // Verify column names use custom column_name attribute
    let columns = UserPartialWithColumnName::selected_columns();
    assert_eq!(columns, vec!["id", "full_name"]);
}

#[test]
fn test_codegen_partial_model_single_column() {
    let columns = UserIdOnly::selected_columns();
    assert_eq!(columns, vec!["id"]);
}

#[test]
fn test_codegen_partial_model_from_row() {
    use lifeguard::FromRow;
    
    // Verify FromRow is implemented
    fn _test_from_row<P: FromRow>() {}
    _test_from_row::<UserPartial>();
}

#[test]
fn test_codegen_partial_model_field_name_to_snake_case() {
    // Generate a partial model with camelCase field names
    // This test verifies that field names are converted to snake_case for column names
    // Note: We'd need to generate this via codegen with the appropriate fields
    // For now, this test documents the expected behavior
    let columns = UserPartial::selected_columns();
    assert_eq!(columns, vec!["id", "name"]);
}
