# Design Document: RelationMetadata and Composite Primary Key Support

## Overview

This document outlines the design and implementation plan for:
1. **RelationMetadata Usage**: Enabling `find_related()` to use relationship metadata without trait bounds
2. **Composite Primary Key Support**: Full support for composite primary keys in `find_related()`

**Status:** üü° Design Phase - Awaiting Review  
**Related Sections:** [SEAORM_LIFEGUARD_MAPPING.md ¬ß13 - Implementation Notes](./SEAORM_LIFEGUARD_MAPPING.md#13-implementation-notes)

---

## 1. Current State Analysis

### 1.1 RelationMetadata Trait

**Current Implementation:**
- ‚úÖ `RelationMetadata` trait defined in `src/relation.rs`
- ‚úÖ `DeriveRelation` macro generates `RelationMetadata` implementations when `from`/`to` columns are provided
- ‚ùå Not used in `find_related()` due to trait bound limitations

**Location:** `src/relation.rs:242-260`

**Generated Code Example:**
```rust
impl RelationMetadata<Entity> for super::users::Entity {
    fn foreign_key_column() -> Option<&'static str> {
        Some("user_id")
    }
}
```

### 1.2 Composite Primary Keys

**Current Implementation:**
- ‚úÖ `PrimaryKeyArityTrait` exists and works
- ‚úÖ Macro generates composite key support in `PrimaryKeyTrait::ValueType` (tuples)
- ‚ùå `ModelTrait::get_primary_key_value()` only returns first key value
- ‚ùå `find_related()` only supports single-column primary keys

**Location:** 
- `src/query/primary_key.rs:177-208` (PrimaryKeyArityTrait)
- `src/model.rs:104` (get_primary_key_value)
- `src/relation.rs:378-415` (find_related)

### 1.3 Derive Macros

**Current Capabilities:**
- ‚úÖ `LifeModel` macro generates Model, Column, PrimaryKey enums
- ‚úÖ `DeriveRelation` macro generates Related and RelationMetadata implementations
- ‚úÖ Can parse attributes and generate code based on metadata

**Location:** `lifeguard-derive/src/macros/`

---

## 2. Problem Statement

### 2.1 RelationMetadata Usage Problem

**Issue:** Cannot use `RelationMetadata` in `find_related()` without making it a required trait bound.

**Root Cause:**
- Rust trait system requires explicit trait bounds to call trait methods
- Adding `R: RelationMetadata<Self::Entity>` would break existing code
- No way to conditionally use a trait method

**Impact:**
- Relationship metadata is generated but unused
- Users must manually specify foreign key columns or rely on defaults
- Custom foreign key column names are not supported

### 2.2 Composite Primary Key Problem

**Issue:** `find_related()` cannot handle composite primary keys (multiple columns).

**Root Cause:**
1. `get_primary_key_value()` returns single `Value`, not collection
2. Cannot enumerate `PrimaryKey` enum variants at runtime
3. No way to map multiple primary key columns to foreign key columns

**Impact:**
- Entities with composite primary keys cannot use `find_related()`
- Must manually construct queries for composite key relationships
- Limits ORM functionality for complex schemas

---

## 3. Proposed Solution: Static Metadata Registry

### 3.1 Architecture Overview

Instead of using trait bounds, we'll use a **static metadata registry** that stores relationship metadata at compile time and accesses it at runtime using `TypeId`.

**Key Components:**
1. **Metadata Registry**: Static HashMap storing foreign key column mappings
2. **Macro-Generated Registration**: Code generated by `DeriveRelation` to populate registry
3. **Runtime Lookup**: Helper functions to query registry using `TypeId`
4. **Enhanced ModelTrait**: Support for getting all primary key values

### 3.2 Solution 1: RelationMetadata Registry

#### 3.2.1 Design

**Registry Structure:**
```rust
// Key: (RelatedEntity TypeId, SourceEntity TypeId)
// Value: Foreign key column name
type RelationMetadataMap = HashMap<(TypeId, TypeId), &'static str>;
```

**Registration (Generated by Macro):**
```rust
// Generated by DeriveRelation macro
lazy_static::lazy_static! {
    static ref RELATION_METADATA: RelationMetadataMap = {
        let mut map = HashMap::new();
        // PostEntity -> UserEntity: foreign key is "user_id"
        map.insert(
            (TypeId::of::<PostEntity>(), TypeId::of::<UserEntity>()),
            "user_id"
        );
        map
    };
}
```

**Usage in find_related():**
```rust
let fk_column = RELATION_METADATA
    .get(&(TypeId::of::<R>(), TypeId::of::<Self::Entity>()))
    .copied()
    .unwrap_or_else(|| format!("{}_id", current_table));
```

#### 3.2.2 Implementation Plan

**Step 1: Create Metadata Registry Module**
- **File:** `src/relation/metadata.rs` (new)
- **Contents:**
  - Registry type definition
  - Registration function
  - Lookup helper functions
  - Public API for accessing metadata

**Step 2: Update DeriveRelation Macro**
- **File:** `lifeguard-derive/src/macros/relation.rs`
- **Changes:**
  - Generate registry registration code instead of (or in addition to) trait impl
  - Use `lazy_static` or `once_cell::Lazy` for static initialization
  - Include `TypeId::of` calls for both entities

**Step 3: Update find_related()**
- **File:** `src/relation.rs`
- **Changes:**
  - Remove trait-based approach
  - Add registry lookup
  - Fall back to default naming if not found

**Step 4: Add Tests**
- **File:** `tests/integration/relation_metadata.rs` (new)
- **Tests:**
  - Registry registration and lookup
  - Custom foreign key column names
  - Default fallback behavior

#### 3.2.3 Dependencies

**New Dependencies:**
- `std::any::TypeId` (standard library)
- `once_cell` or `lazy_static` (for static initialization)
- `std::collections::HashMap` (standard library)

**Existing Dependencies:**
- `lifeguard-derive` (for macro generation)

### 3.3 Solution 2: Composite Primary Key Support

#### 3.3.1 Design

**Enhanced ModelTrait:**
```rust
trait ModelTrait {
    // Existing method (single key)
    fn get_primary_key_value(&self) -> Value;
    
    // New method (composite keys)
    fn get_all_primary_key_values(&self) -> Vec<Value>;
}
```

**Macro-Generated Implementation:**
```rust
// For single key
impl ModelTrait for UserModel {
    fn get_primary_key_value(&self) -> Value {
        self.id.into()
    }
    
    fn get_all_primary_key_values(&self) -> Vec<Value> {
        vec![self.id.into()]  // Single element for single key
    }
}

// For composite key (id, tenant_id)
impl ModelTrait for TenantUserModel {
    fn get_primary_key_value(&self) -> Value {
        self.id.into()  // Returns first key (backward compatible)
    }
    
    fn get_all_primary_key_values(&self) -> Vec<Value> {
        vec![self.id.into(), self.tenant_id.into()]  // All keys
    }
}
```

**Composite Key Metadata Registry:**
```rust
// Key: (RelatedEntity TypeId, SourceEntity TypeId)
// Value: Vector of foreign key column names (matches primary key order)
type CompositeKeyMetadataMap = HashMap<(TypeId, TypeId), Vec<&'static str>>;
```

**Usage in find_related():**
```rust
let pk_values = self.get_all_primary_key_values();
let arity = <Self::Entity as PrimaryKeyArityTrait>::arity();

if matches!(arity, PrimaryKeyArity::Single) {
    // Single key: existing logic
    let fk_column = get_foreign_key_column::<R, Self::Entity>();
    query = query.filter(Expr::column(format!("{}.{}", related_table, fk_column)).eq(pk_values[0]));
} else {
    // Composite key: multiple WHERE conditions
    let fk_columns = get_composite_foreign_key_columns::<R, Self::Entity>();
    for (pk_val, fk_col) in pk_values.iter().zip(fk_columns.iter()) {
        query = query.filter(Expr::column(format!("{}.{}", related_table, fk_col)).eq(pk_val));
    }
}
```

#### 3.3.2 Implementation Plan

**Step 1: Enhance ModelTrait**
- **File:** `src/model.rs`
- **Changes:**
  - Add `get_all_primary_key_values()` method
  - Update documentation
  - Provide default implementation that calls `get_primary_key_value()`

**Step 2: Update LifeModel Macro**
- **File:** `lifeguard-derive/src/macros/life_model.rs`
- **Changes:**
  - Generate `get_all_primary_key_values()` implementation
  - For single keys: return vec with single element
  - For composite keys: return vec with all primary key values
  - Use existing primary key tracking logic

**Step 3: Create Composite Key Metadata Registry**
- **File:** `src/relation/metadata.rs`
- **Changes:**
  - Add composite key registry type
  - Add registration and lookup functions
  - Handle both single and composite keys

**Step 4: Update DeriveRelation Macro**
- **File:** `lifeguard-derive/src/macros/relation.rs`
- **Changes:**
  - Detect composite primary keys in target entity
  - Generate composite key metadata registration
  - Support multiple foreign key columns in `from` attribute

**Step 5: Update find_related()**
- **File:** `src/relation.rs`
- **Changes:**
  - Use `get_all_primary_key_values()` instead of `get_primary_key_value()`
  - Check `PrimaryKeyArity` to determine single vs composite
  - Build multiple WHERE conditions for composite keys

**Step 6: Add Tests**
- **File:** `tests/integration/composite_key_relations.rs` (new)
- **Tests:**
  - Single key relationships (backward compatibility)
  - Composite key relationships
  - Multiple foreign key columns
  - Edge cases (mismatched key sizes, etc.)

#### 3.3.3 Dependencies

**New Dependencies:**
- None (uses existing `PrimaryKeyArityTrait`)

**Existing Dependencies:**
- `lifeguard-derive` (for macro generation)
- `std::any::TypeId` (for registry)

---

## 4. Implementation Details

### 4.1 Metadata Registry Module Structure

**File:** `src/relation/metadata.rs`

```rust
use std::any::TypeId;
use std::collections::HashMap;
use once_cell::sync::Lazy;

// Single foreign key column registry
type ForeignKeyRegistry = HashMap<(TypeId, TypeId), &'static str>;

// Composite foreign key columns registry
type CompositeForeignKeyRegistry = HashMap<(TypeId, TypeId), Vec<&'static str>>;

// Global registries (populated by macro-generated code)
static FOREIGN_KEY_METADATA: Lazy<ForeignKeyRegistry> = Lazy::new(|| {
    let mut map = HashMap::new();
    // Macro will generate registration calls here
    map
});

static COMPOSITE_FOREIGN_KEY_METADATA: Lazy<CompositeForeignKeyRegistry> = Lazy::new(|| {
    let mut map = HashMap::new();
    // Macro will generate registration calls here
    map
});

// Public API
pub fn get_foreign_key_column<R, E>() -> Option<&'static str>
where
    R: 'static,
    E: 'static,
{
    FOREIGN_KEY_METADATA.get(&(TypeId::of::<R>(), TypeId::of::<E>())).copied()
}

pub fn get_composite_foreign_key_columns<R, E>() -> Option<Vec<&'static str>>
where
    R: 'static,
    E: 'static,
{
    COMPOSITE_FOREIGN_KEY_METADATA.get(&(TypeId::of::<R>(), TypeId::of::<E>())).cloned()
}

// Registration functions (called by macro-generated code)
pub fn register_foreign_key<R, E>(column: &'static str)
where
    R: 'static,
    E: 'static,
{
    FOREIGN_KEY_METADATA.insert((TypeId::of::<R>(), TypeId::of::<E>()), column);
}

pub fn register_composite_foreign_keys<R, E>(columns: Vec<&'static str>)
where
    R: 'static,
    E: 'static,
{
    COMPOSITE_FOREIGN_KEY_METADATA.insert((TypeId::of::<R>(), TypeId::of::<E>()), columns);
}
```

**Note:** The registration functions need to be called at initialization time. We'll need to use a different approach - see Section 4.2.

### 4.2 Registration Strategy

**Problem:** Static `Lazy` collections can't be mutated after initialization.

**Solution Options:**

**Option A: Initialize-once Pattern**
```rust
static FOREIGN_KEY_METADATA: Lazy<Mutex<ForeignKeyRegistry>> = Lazy::new(|| {
    Mutex::new(HashMap::new())
});

pub fn register_foreign_key<R, E>(column: &'static str) {
    FOREIGN_KEY_METADATA.lock().unwrap().insert(...);
}
```
**Pros:** Simple, works  
**Cons:** Runtime mutex overhead, not thread-safe for concurrent registration

**Option B: Macro-Generated Initialization Function**
```rust
// Generated by macro
#[ctor::ctor]
fn init_relation_metadata() {
    register_foreign_key::<PostEntity, UserEntity>("user_id");
}

// Registry is populated before main()
static FOREIGN_KEY_METADATA: Lazy<ForeignKeyRegistry> = Lazy::new(|| {
    let mut map = HashMap::new();
    // Macro generates this initialization
    init_relation_metadata();
    map
});
```
**Pros:** No runtime overhead, thread-safe  
**Cons:** Requires `ctor` crate, initialization order issues

**Option C: Build-time Registration (Recommended)**
```rust
// Macro generates a function that returns the map
#[macro_export]
macro_rules! register_relation_metadata {
    () => {{
        let mut map = HashMap::new();
        map.insert((TypeId::of::<PostEntity>(), TypeId::of::<UserEntity>()), "user_id");
        map
    }};
}

// User's code (generated by macro)
static FOREIGN_KEY_METADATA: Lazy<ForeignKeyRegistry> = Lazy::new(|| {
    register_relation_metadata!()
});
```
**Pros:** No runtime overhead, compile-time initialization  
**Cons:** Requires macro to generate code in user's crate

**Recommended:** Option C - Generate static initialization in user's code via macro.

### 4.3 Macro Generation Changes

#### 4.3.1 DeriveRelation Macro Updates

**Current:** Generates trait implementations  
**New:** Generates trait implementations + registry initialization

**Generated Code Pattern:**
```rust
// Existing: Related trait impl
impl Related<super::users::Entity> for Entity {
    fn to() -> SelectQuery<super::users::Entity> {
        SelectQuery::new()
    }
}

// New: Registry initialization (if from/to provided)
#[doc(hidden)]
#[allow(non_upper_case_globals)]
static _RELATION_METADATA_INIT: once_cell::sync::Lazy<()> = once_cell::sync::Lazy::new(|| {
    lifeguard::relation::metadata::register_foreign_key::<super::users::Entity, Entity>("user_id");
});
```

**Location:** `lifeguard-derive/src/macros/relation.rs:130-150`

#### 4.3.2 LifeModel Macro Updates

**Current:** Generates `get_primary_key_value()`  
**New:** Also generates `get_all_primary_key_values()`

**Generated Code Pattern:**
```rust
// Single key
impl ModelTrait for UserModel {
    fn get_primary_key_value(&self) -> Value {
        self.id.into()
    }
    
    fn get_all_primary_key_values(&self) -> Vec<Value> {
        vec![self.id.into()]
    }
}

// Composite key
impl ModelTrait for TenantUserModel {
    fn get_primary_key_value(&self) -> Value {
        self.id.into()  // First key (backward compatible)
    }
    
    fn get_all_primary_key_values(&self) -> Vec<Value> {
        vec![self.id.into(), self.tenant_id.into()]
    }
}
```

**Location:** `lifeguard-derive/src/macros/life_model.rs:1045-1075`

### 4.4 find_related() Updates

**Current Implementation:**
```rust
fn find_related<R>(&self) -> SelectQuery<R> {
    let mut query = R::to();
    let pk_value = self.get_primary_key_value();
    // ... single key logic
}
```

**New Implementation:**
```rust
fn find_related<R>(&self) -> SelectQuery<R> {
    let mut query = R::to();
    let pk_values = self.get_all_primary_key_values();
    let arity = <Self::Entity as PrimaryKeyArityTrait>::arity();
    
    let related_table = R::default().table_name();
    
    match arity {
        PrimaryKeyArity::Single => {
            // Single key: existing logic with registry lookup
            let fk_column = metadata::get_foreign_key_column::<R, Self::Entity>()
                .unwrap_or_else(|| format!("{}_id", current_table));
            query = query.filter(Expr::column(format!("{}.{}", related_table, fk_column)).eq(pk_values[0]));
        }
        _ => {
            // Composite key: multiple WHERE conditions
            let fk_columns = metadata::get_composite_foreign_key_columns::<R, Self::Entity>()
                .unwrap_or_else(|| {
                    // Default: generate column names from primary key
                    generate_default_fk_columns(current_table, arity)
                });
            
            for (pk_val, fk_col) in pk_values.iter().zip(fk_columns.iter()) {
                query = query.filter(Expr::column(format!("{}.{}", related_table, fk_col)).eq(pk_val));
            }
        }
    }
    
    query
}
```

**Location:** `src/relation.rs:378-415`

---

## 5. API Changes

### 5.1 Breaking Changes

**None** - All changes are additive:
- `get_all_primary_key_values()` is a new method with default implementation
- Registry lookup is internal implementation detail
- Existing code continues to work

### 5.2 New Public APIs

**New Module:** `lifeguard::relation::metadata`
- `get_foreign_key_column<R, E>() -> Option<&'static str>`
- `get_composite_foreign_key_columns<R, E>() -> Option<Vec<&'static str>>`

**Enhanced Trait:** `ModelTrait`
- `get_all_primary_key_values(&self) -> Vec<Value>` (new method)

### 5.3 DeriveRelation Macro Changes

**New Attribute Support:**
```rust
#[lifeguard(
    belongs_to = "super::users::Entity",
    from = "Column::UserId",           // Single foreign key
    to = "super::users::Column::Id"
)]
User,

// For composite keys (future):
#[lifeguard(
    belongs_to = "super::tenants::Entity",
    from = ["Column::UserId", "Column::TenantId"],  // Multiple foreign keys
    to = ["super::tenants::Column::Id", "super::tenants::Column::TenantId"]
)]
Tenant,
```

---

## 6. Testing Strategy

### 6.1 Unit Tests

**File:** `src/relation/metadata.rs` (tests module)
- Registry registration and lookup
- TypeId-based key matching
- Default fallback behavior

### 6.2 Integration Tests

**File:** `tests/integration/relation_metadata.rs`
- Custom foreign key column names
- Single key relationships
- Default naming fallback

**File:** `tests/integration/composite_key_relations.rs`
- Composite primary key relationships
- Multiple foreign key columns
- Single key backward compatibility

### 6.3 Macro Tests

**File:** `lifeguard-derive/tests/test_derive_relation.rs`
- Registry initialization code generation
- Foreign key column name extraction
- Composite key metadata generation

---

## 7. Migration Path

### 7.1 For Existing Code

**No changes required** - all enhancements are backward compatible:
- Existing `find_related()` calls continue to work
- Default foreign key naming still works
- Single primary keys unchanged

### 7.2 For New Code

**Optional:** Use `from`/`to` attributes in `DeriveRelation` to specify custom foreign key columns:
```rust
#[derive(DeriveRelation)]
pub enum Relation {
    #[lifeguard(
        belongs_to = "super::users::Entity",
        from = "Column::UserId",  // Custom foreign key
        to = "super::users::Column::Id"
    )]
    User,
}
```

---

## 8. Dependencies

### 8.1 New Dependencies

**Required:**
- `once_cell` (already in use) or `lazy_static` - for static initialization
- `std::any::TypeId` - standard library, no new dependency

**Optional (for initialization):**
- `ctor` - if using constructor-based initialization (Option B)

### 8.2 Existing Dependencies

- `lifeguard-derive` - for macro generation
- `sea-query` - for query building
- All existing dependencies remain

---

## 9. Implementation Checklist

### Phase 1: Metadata Registry Infrastructure
- [ ] Create `src/relation/metadata.rs` module
- [ ] Define registry types and lookup functions
- [ ] Add unit tests for registry
- [ ] Document public API

### Phase 2: RelationMetadata Registry Integration
- [ ] Update `DeriveRelation` macro to generate registry initialization
- [ ] Update `find_related()` to use registry lookup
- [ ] Add integration tests for custom foreign key columns
- [ ] Verify backward compatibility

### Phase 3: Composite Primary Key Support
- [ ] Add `get_all_primary_key_values()` to `ModelTrait`
- [ ] Update `LifeModel` macro to generate composite key support
- [ ] Create composite key metadata registry
- [ ] Update `DeriveRelation` to support composite key metadata
- [ ] Update `find_related()` to handle composite keys
- [ ] Add comprehensive tests

### Phase 4: Documentation and Polish
- [ ] Update `DERIVE_RELATION_USAGE.md` with examples
- [ ] Update `SEAORM_LIFEGUARD_MAPPING.md` implementation notes
- [ ] Add examples to documentation
- [ ] Performance testing and optimization

---

## 10. Risks and Mitigations

### 10.1 TypeId Collisions

**Risk:** Different types with same name could collide  
**Mitigation:** Use full module path in TypeId (already handled by Rust)

### 10.2 Initialization Order

**Risk:** Registry accessed before initialization  
**Mitigation:** Use `Lazy` static initialization (guaranteed before first access)

### 10.3 Performance

**Risk:** HashMap lookup overhead  
**Mitigation:** 
- TypeId comparison is fast (pointer comparison)
- Lookup is O(1) average case
- Only called once per `find_related()` call
- Benchmark and optimize if needed

### 10.4 Backward Compatibility

**Risk:** Breaking existing code  
**Mitigation:** 
- All changes are additive
- Default behavior preserved
- Comprehensive testing before release

---

## 11. Success Criteria

### 11.1 RelationMetadata Usage
- ‚úÖ `find_related()` uses custom foreign key columns when specified
- ‚úÖ Default naming still works when metadata not provided
- ‚úÖ No trait bound requirements
- ‚úÖ Zero breaking changes

### 11.2 Composite Primary Key Support
- ‚úÖ `find_related()` works with composite primary keys
- ‚úÖ Multiple WHERE conditions generated correctly
- ‚úÖ Single key support unchanged
- ‚úÖ Comprehensive test coverage

---

## 12. References

- **Implementation Notes:** [SEAORM_LIFEGUARD_MAPPING.md ¬ß13](./SEAORM_LIFEGUARD_MAPPING.md#13-implementation-notes)
- **Related Trait:** [SEAORM_LIFEGUARD_MAPPING.md ¬ß1 - Related](./SEAORM_LIFEGUARD_MAPPING.md#1-core-traits--types)
- **DeriveRelation Macro:** [SEAORM_LIFEGUARD_MAPPING.md ¬ß2 - DeriveRelation](./SEAORM_LIFEGUARD_MAPPING.md#2-derive-macros)
- **Usage Guide:** [DERIVE_RELATION_USAGE.md](./DERIVE_RELATION_USAGE.md)

---

## 13. Open Questions

1. **Initialization Strategy:** Which approach (A, B, or C) should we use for registry initialization?
2. **Composite Key Syntax:** Should we support array syntax `from = [...]` or require separate attributes?
3. **Error Handling:** How should we handle mismatched key sizes (e.g., 2 primary keys but 1 foreign key)?
4. **Performance:** Should we add caching or other optimizations for registry lookups?

---

**Document Status:** üü° Awaiting Review  
**Last Updated:** 2025-01-27  
**Next Steps:** Review design, approve approach, begin Phase 1 implementation
