# DeriveLinked Macro Usage Guide

## Overview

The `DeriveLinked` macro automatically generates `Linked<I, T>` trait implementations from enum variants with `#[lifeguard(linked = "...")]` attributes, reducing boilerplate for multi-hop relationship queries.

## Basic Usage

### Simple Two-Hop Relationship

```rust
use lifeguard_derive::DeriveLinked;

#[derive(DeriveLinked)]
pub enum LinkedRelation {
    #[lifeguard(linked = "PostEntity -> CommentEntity")]
    Comments,
}
```

This generates:
```rust
impl Linked<PostEntity, CommentEntity> for Entity {
    fn via() -> Vec<RelationDef> {
        vec![
            <Entity as Related<PostEntity>>::to(),
            <PostEntity as Related<CommentEntity>>::to(),
        ]
    }
}
```

### Three-Hop Relationship

```rust
#[derive(DeriveLinked)]
pub enum LinkedRelation {
    #[lifeguard(linked = "PostEntity -> CommentEntity -> ReactionEntity")]
    Reactions,
}
```

This generates a path with 3 hops: `Entity -> PostEntity -> CommentEntity -> ReactionEntity`

## Path Syntax

### Arrow Syntax

The macro uses arrow syntax (`->`) to separate hops in the path:

```rust
#[lifeguard(linked = "Entity1 -> Entity2 -> Entity3")]
```

### Module-Qualified Paths

You can use module-qualified paths for entities in different modules:

```rust
#[lifeguard(linked = "super::posts::PostEntity -> super::comments::CommentEntity")]
```

Or with relative paths:

```rust
#[lifeguard(linked = "posts::PostEntity -> comments::CommentEntity")]
```

### Self-Referential Paths

Self-referential chains are supported:

```rust
#[lifeguard(linked = "Entity -> Entity")]
```

This is useful for hierarchical relationships (e.g., category parent-child relationships).

## Multiple Linked Paths

You can define multiple linked paths in a single enum:

```rust
#[derive(DeriveLinked)]
pub enum LinkedRelation {
    #[lifeguard(linked = "PostEntity -> CommentEntity")]
    Comments,
    
    #[lifeguard(linked = "PostEntity -> TagEntity")]
    Tags,
    
    #[lifeguard(linked = "ArticleEntity -> CommentEntity")]
    CommentsViaArticles,
}
```

Each variant generates a separate `Linked<I, T>` implementation.

## Prerequisites

For `DeriveLinked` to work, you must have:

1. **Related trait implementations** for each hop in the path
   - These are typically generated by `DeriveRelation` macro
   - Example: For `"PostEntity -> CommentEntity"`, you need:
     - `impl Related<PostEntity> for Entity`
     - `impl Related<CommentEntity> for PostEntity`

2. **Entity types** that implement `LifeModelTrait`

## Usage with find_linked()

Once you've defined linked relationships, you can use them with `find_linked()`:

```rust
use lifeguard::{FindLinked, ModelTrait};

let user: UserModel = ...;
let executor: &dyn LifeExecutor = ...;

// Find comments through posts
let comments: Vec<CommentModel> = user
    .find_linked::<PostEntity, CommentEntity>()
    .all(executor)?;
```

## Complete Example

```rust
use lifeguard_derive::{LifeModel, DeriveRelation, DeriveLinked};
use lifeguard::{Related, FindLinked, LifeModelTrait, ModelTrait, LifeExecutor};

// Define entities with relations
#[derive(LifeModel)]
#[table_name = "users"]
pub struct User {
    #[primary_key]
    #[auto_increment]
    pub id: i32,
    pub name: String,
}

#[derive(DeriveRelation)]
pub enum Relation {
    #[lifeguard(has_many = "super::posts::Entity")]
    Posts,
}

// Define linked relationships
#[derive(DeriveLinked)]
pub enum LinkedRelation {
    #[lifeguard(linked = "super::posts::Entity -> super::comments::Entity")]
    Comments,
}

// Usage
// let user: UserModel = ...;
// let comments = user.find_linked::<PostEntity, CommentEntity>().all(executor)?;
```

## Error Cases

### Invalid Path Syntax

```rust
// Error: Only one hop (needs at least 2)
#[lifeguard(linked = "PostEntity")]
```

**Error:** `Linked path must have at least 2 hops (intermediate and target), found 1`

### Empty Path

```rust
// Error: Empty path
#[lifeguard(linked = "")]
```

**Error:** `Linked path cannot be empty. Use format: Entity1 -> Entity2`

### Invalid Entity Path

```rust
// Error: Invalid entity path
#[lifeguard(linked = "Post-Entity -> CommentEntity")]
```

**Error:** `Invalid entity path in hop 1 'Post-Entity': unexpected token`

### Missing Related Implementation

If a `Related` implementation is missing for any hop in the path, Rust will report a compile error when the generated code tries to use it:

```rust
// If Related<PostEntity> for Entity doesn't exist:
#[lifeguard(linked = "PostEntity -> CommentEntity")]
// Error: the trait bound `Entity: Related<PostEntity>` is not satisfied
```

## Comparison with Manual Implementation

### Before (Manual)

```rust
impl Linked<PostEntity, CommentEntity> for UserEntity {
    fn via() -> Vec<RelationDef> {
        vec![
            <UserEntity as Related<PostEntity>>::to(),
            <PostEntity as Related<CommentEntity>>::to(),
        ]
    }
}

impl Linked<PostEntity, TagEntity> for UserEntity {
    fn via() -> Vec<RelationDef> {
        vec![
            <UserEntity as Related<PostEntity>>::to(),
            <PostEntity as Related<TagEntity>>::to(),
        ]
    }
}
```

**Lines of code:** ~20 lines

### After (With DeriveLinked)

```rust
#[derive(DeriveLinked)]
pub enum LinkedRelation {
    #[lifeguard(linked = "PostEntity -> CommentEntity")]
    Comments,
    
    #[lifeguard(linked = "PostEntity -> TagEntity")]
    Tags,
}
```

**Lines of code:** ~4 lines

**Boilerplate reduction:** ~80% (from 20 lines to 4 lines)

## Best Practices

1. **Use descriptive variant names** that indicate the relationship path:
   ```rust
   #[lifeguard(linked = "PostEntity -> CommentEntity")]
   Comments,  // Good: Clear what this represents
   ```

2. **Group related paths** in the same enum for discoverability

3. **Use module-qualified paths** when entities are in different modules to avoid ambiguity

4. **Ensure Related impls exist** before defining linked paths - the macro will generate code that requires them

## Migration from Manual Implementation

To migrate from manual `Linked` implementations:

1. Create a `LinkedRelation` enum (or similar name)
2. Add `#[derive(DeriveLinked)]` to the enum
3. Convert each `impl Linked<I, T>` to a variant:
   ```rust
   // Before:
   impl Linked<PostEntity, CommentEntity> for Entity { ... }
   
   // After:
   #[lifeguard(linked = "PostEntity -> CommentEntity")]
   Comments,
   ```
4. Remove the manual `impl` blocks
5. The macro generates equivalent code automatically

## See Also

- `DeriveRelation` - For generating `Related` trait implementations
- `Linked` trait - The trait being implemented
- `FindLinked` trait - For using `find_linked()` method
