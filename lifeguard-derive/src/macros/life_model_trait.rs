//! Derive macro for LifeModelTrait
//!
//! Generates LifeModelTrait implementation for Entity.
//! This is separate from LifeModel to avoid trait bound resolution issues.

use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

/// Generate LifeModelTrait implementation for Entity
///
/// This derive expects:
/// - Entity: unit struct (generated by DeriveEntity or LifeModel)
/// - Model: struct (generated by DeriveModel or LifeModel)
///
/// It generates: `impl LifeModelTrait for Entity { type Model = Model; }`
///
/// Following SeaORM's pattern: DeriveEntity generates EntityTrait implementation
/// with the Model associated type. The Model must exist when this is expanded.
pub fn derive_life_model_trait(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    
    let entity_name = &input.ident;
    
    // Extract Model name from attributes or infer from Entity name
    // Check for #[model = "ModelName"] attribute
    let model_name = input.attrs
        .iter()
        .find(|attr| attr.path().is_ident("model"))
        .and_then(|attr| {
            attr.parse_args::<syn::Ident>().ok()
        })
        .unwrap_or_else(|| {
            // Default: assume Model is named "{Entity}Model" or just "Model"
            // Try "Model" first (SeaORM convention), then "{Entity}Model"
            if entity_name.to_string() == "Entity" {
                syn::Ident::new("Model", entity_name.span())
            } else {
                // Remove "Entity" suffix if present, add "Model"
                let base = entity_name.to_string();
                let base = if base.ends_with("Entity") {
                    &base[..base.len() - 6]
                } else {
                    &base
                };
                syn::Ident::new(&format!("{}Model", base), entity_name.span())
            }
        });
    
    let expanded: TokenStream2 = quote! {
        // Implement LifeModelTrait for Entity
        // This is separate from Model generation to avoid trait bound resolution issues
        // Following SeaORM: EntityTrait is generated by DeriveEntity after Model exists
        impl lifeguard::LifeModelTrait for #entity_name {
            type Model = #model_name;
        }
    };
    
    TokenStream::from(expanded)
}
