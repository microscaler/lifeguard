# Migration Tool Design Improvements

## Current Limitations

1. **Hardcoded Entity Matching** (lines 467-497 in main.rs)
   - Uses match statement with hardcoded table names
   - Not generic - only works for specific entities
   - Requires code changes for each new entity

2. **Static Entity Inclusion** (entities.rs)
   - Entities must be known at compile time via `#[path = "..."]`
   - Cannot handle arbitrary 3rd party entities
   - Requires recompilation for new entities

3. **Single Execution Mode**
   - Only supports `--entities-dir` and `--output-dir` flags
   - No config file support
   - No service tree mapping

4. **No Dynamic Discovery**
   - Cannot infer entities from directory structure
   - Must manually match table names to entity modules

## Design Goals

1. **Generic & Extensible**: Work with any 3rd party entities without code changes
2. **Multiple Execution Modes**: Support both oneshot and config-based execution
3. **Dynamic Discovery**: Automatically infer entities from source files
4. **Better UX**: Clear, intuitive CLI with helpful error messages

## Context: Integrated Rust Tool

**Important Insight**: Lifeguard is a Rust ORM, and users will always:
- Have Lifeguard as a dependency in their `Cargo.toml`
- Have the Rust toolchain available
- Integrate the migration tool into their build/development workflow
- Have their entities already compiled as part of their project

This means we can leverage:
- Existing compilation context
- Cargo's build system
- Proc-macros and build scripts
- The fact that entities are already type-checked and available

## Proposed Architecture

**REJECTED APPROACH**: Metadata-based parsing (parsing source files without compilation) is **EXPLICITLY REJECTED** and will not be implemented because:
- ‚ùå **CRITICAL**: May produce different SQL than what compiled entities would generate
- ‚ùå Type inference may differ between parsing and compilation
- ‚ùå Edge cases handled by macro system may be missed
- ‚ùå Cannot guarantee migrations match what the application uses
- ‚ùå Risk of schema drift between generated migrations and runtime behavior
- ‚ùå **Will not be implemented in any form**

**REQUIREMENT**: The migration tool MUST use the same compiled entities that the backend application uses. This is non-negotiable. Only approaches that use compiled entities are acceptable.

### Option A: Cargo Build Script Integration

**Core Idea**: Use a Cargo build script that discovers entities at build time, generates a registry module, and compiles it as part of the user's project.

#### Advantages
- ‚úÖ Can use existing `sql_generator` that requires `LifeModelTrait`
- ‚úÖ Leverages existing type system and trait implementations
- ‚úÖ Type-safe at compile time
- ‚úÖ Entities are already compiled as part of user's project
- ‚úÖ No runtime discovery needed - entities known at compile time
- ‚úÖ Natural integration with Cargo workflow

#### Disadvantages
- ‚ùå Requires build script setup in user's project
- ‚ùå Must regenerate registry when entities change
- ‚ùå More complex integration - users must configure build script
- ‚ùå Slower - requires compilation step
- ‚ùå May fail if entities have compilation errors

#### Implementation Approach

1. **Build Script** (`build.rs`)
   - Scan user's source directory for entities
   - Generate a registry module that includes all discovered entities
   - Compile as part of user's project

2. **Registry Module** (generated)
   ```rust
   // Generated by build script
   pub mod entity_registry {
       #[path = "path/to/entity1.rs"]
       pub mod entity1;
       // ... more entities
   }
   ```

3. **CLI Tool Integration**
   - Use the compiled registry to access entities
   - Can use existing `sql_generator` with `LifeModelTrait`
   - No parsing needed - entities are already compiled

**Note**: This approach requires users to add a build script to their `Cargo.toml`, which may be acceptable for an integrated tool.

### Option B: Proc-Macro with Registry Pattern

**Core Idea**: Use a proc-macro that automatically registers entities when they're compiled, building a registry at compile time.

#### Advantages
- ‚úÖ Fully automatic - no user configuration needed
- ‚úÖ Type-safe - leverages existing compilation
- ‚úÖ Can use existing `sql_generator` with `LifeModelTrait`
- ‚úÖ No parsing needed - uses compiled entity metadata
- ‚úÖ Works seamlessly with user's existing build process

#### Disadvantages
- ‚ùå More complex implementation - requires proc-macro changes
- ‚ùå Registry must be built during compilation
- ‚ùå May need to handle incremental compilation carefully
- ‚ùå Requires changes to `lifeguard-derive` to support registration

#### Implementation Approach

1. **Enhanced LifeModel Derive**
   - Add registration code to `#[derive(LifeModel)]` macro
   - Register entity metadata in a compile-time registry
   - Store registry in a generated module

2. **Registry Access**
   - CLI tool reads the compiled registry
   - Can iterate over all registered entities
   - Access entities via their `LifeModelTrait` implementation

3. **CLI Tool**
   - Load registry from compiled artifacts
   - Use existing `sql_generator` with registered entities
   - No discovery or parsing needed

**Note**: This is the most elegant solution but requires changes to the derive macro system.

## Recommended Solution: Option B (Proc-Macro Registry) as Primary, Option A as Alternative

**Critical Requirement**: The migration tool MUST use the same compiled entities that the backend application uses. This ensures:
- ‚úÖ Migrations match the actual runtime behavior
- ‚úÖ Type inference and edge cases are handled correctly
- ‚úÖ No discrepancies between generated SQL and application code
- ‚úÖ Same "depth of usage" as the application

**Primary Recommendation**: Option B (Proc-Macro Registry) because:
- ‚úÖ Uses the exact same compiled entities as the application
- ‚úÖ Automatic - no user configuration needed
- ‚úÖ Type-safe and leverages existing compilation
- ‚úÖ Zero risk of generating different SQL than what the app uses

**Alternative**: Option A (Cargo Build Script) if Option B is not feasible:
- ‚úÖ Still uses compiled entities (same as application)
- ‚úÖ Requires build script setup but ensures correctness
- ‚úÖ Can use existing SQL generator without modification

**REJECTED**: Metadata Parsing (parsing source files without compilation):
- ‚ùå **EXPLICITLY REJECTED** - May produce different SQL than compiled entities
- ‚ùå Type inference differences between parsing and compilation
- ‚ùå Edge cases may be missed
- ‚ùå Cannot guarantee migrations match what the application uses
- ‚ùå **Will not be implemented in any form**

**NO FALLBACK MECHANISM**: The tool MUST FAIL if it cannot access compiled entities. There is no fallback to parsing. This ensures migrations always match what the application uses.

### Implementation Plan

**Note**: All implementation phases use compiled entities only. No metadata parsing will be implemented.

#### Phase 3: CLI Enhancements

**Enhanced Command Structure**:

```rust
#[derive(Subcommand)]
enum Commands {
    /// Generate SQL migrations from entity definitions
    GenerateFromEntities {
        /// Source directory containing entity files (oneshot mode)
        #[arg(long)]
        source_dir: Option<PathBuf>,
        
        /// Output directory for generated SQL files (oneshot mode)
        #[arg(long)]
        output_dir: Option<PathBuf>,
        
        /// Config file path (config-based mode)
        #[arg(long)]
        config: Option<PathBuf>,
        
        /// Service filter - only generate for specific service
        #[arg(long)]
        service: Option<String>,
        
        /// Dry run - show what would be generated without writing files
        #[arg(long)]
        dry_run: bool,
        
        /// Verbose output - show detailed entity processing information
        #[arg(long)]
        verbose: bool,
    },
    // ... other commands
}
```

#### Phase 4: Config File Support

**Config File Format** (`lifeguard-migrate.toml`):

```toml
[migration]
# Entity source tree mapping
# Maps service paths to entity source directories
entity_source_tree = {
    "accounting/general-ledger" = "./src/entities/accounting/general-ledger",
    "accounting/accounts-payable" = "./src/entities/accounting/accounts-payable",
    "accounting/accounts-receivable" = "./src/entities/accounting/accounts-receivable",
    "accounting/invoice" = "./src/entities/accounting/invoice",
}

# Migration output tree mapping
# Maps service paths to migration output directories
migration_output_tree = {
    "accounting/general-ledger" = "./migrations/generated/accounting/general-ledger",
    "accounting/accounts-payable" = "./migrations/generated/accounting/accounts-payable",
    "accounting/accounts-receivable" = "./migrations/generated/accounting/accounts-receivable",
    "accounting/invoice" = "./migrations/generated/accounting/invoice",
}

# Default output directory (used if service not in mapping)
default_output_dir = "./migrations/generated"

# Entity discovery settings
[discovery]
# File patterns to include (default: ["*.rs"])
include_patterns = ["*.rs"]

# File patterns to exclude
exclude_patterns = ["*_test.rs", "*_tests.rs", "mod.rs", "lib.rs", "main.rs"]

# Directories to exclude
exclude_dirs = ["target", ".git", "node_modules"]
```

### Execution Modes

#### Mode 1: Registry-Based Execution (Default)

```bash
lifeguard-migrate generate-from-entities \
    --output-dir ./migrations/generated
```

**Behavior**:
- Loads entity registry from compiled artifacts
- Uses compiled entities via registry
- Groups by service path from entity metadata
- Writes SQL files to `--output-dir` preserving structure

#### Mode 2: Config-Based Execution

```bash
lifeguard-migrate generate-from-entities --config ./lifeguard-migrate.toml
```

**Behavior**:
- Reads config file
- Loads entity registry from compiled artifacts
- For each service in config:
  - Filter entities by service path
  - Generate SQL from compiled entities
  - Write to corresponding `migration_output_tree` directory
- If service not in mapping, use `default_output_dir`

#### Mode 3: Service-Specific Execution

```bash
lifeguard-migrate generate-from-entities \
    --config ./lifeguard-migrate.toml \
    --service accounting/general-ledger
```

**Behavior**:
- Only process entities for specified service
- Uses compiled entities from registry
- Useful for incremental updates

### Entity Discovery Algorithm

**Using Compiled Entities (Option B - Proc-Macro Registry)**:
```
1. Entities are automatically registered during compilation via proc-macro
2. Registry module is generated containing all registered entities
3. Tool loads registry and iterates over registered entities
4. Uses existing SQL generator with LifeModelTrait implementations
5. Groups by service path from entity metadata
```

**Using Compiled Entities (Option A - Build Script)**:
```
1. Build script scans source directories for entities
2. Generates registry module with #[path = "..."] includes
3. Registry is compiled as part of user's project
4. Tool loads registry and uses compiled entities
5. Uses existing SQL generator with LifeModelTrait implementations
```

### Error Handling & UX Improvements

#### Clear Error Messages

```rust
// If registry not found:
Error: Compiled entities registry not found
  ‚îî‚îÄ The migration tool requires access to compiled entities
  ‚îî‚îÄ Ensure your project builds successfully: cargo build
  ‚îî‚îÄ If using Option A (build script), ensure build.rs is configured correctly
  ‚îî‚îÄ If using Option B (proc-macro), ensure lifeguard-derive is up to date

// If entity compilation fails:
Error: Entity compilation failed
  ‚îî‚îÄ Cannot generate migrations from entities with compilation errors
  ‚îî‚îÄ Fix compilation errors first, then regenerate migrations
```

#### Validation

- ‚úÖ Verify all entities have `#[table_name]`
- ‚úÖ Check for duplicate table names
- ‚úÖ Validate column types are valid SQL types
- ‚úÖ Warn about missing primary keys
- ‚úÖ Check foreign key references exist

#### Progress Indicators

```
üîç Loading entity registry...
   ‚úÖ Registry found: 12 entities registered

üìã Processing compiled entities...
   ‚úÖ ChartOfAccount (table: chart_of_accounts)
   ‚úÖ Account (table: accounts)
   ‚úÖ JournalEntry (table: journal_entries)
   ‚úÖ JournalEntryLine (table: journal_entry_lines)
   ‚úÖ AccountBalance (table: account_balances)

üî® Generating SQL from compiled entities...
   ‚úÖ Generated SQL for chart_of_accounts
   ‚úÖ Generated SQL for accounts
   ‚úÖ Generated SQL for journal_entries
   ‚úÖ Generated SQL for journal_entry_lines
   ‚úÖ Generated SQL for account_balances

üìä Summary:
   ‚úÖ 5 entities processed successfully
   üìÅ 1 SQL file written to ./migrations/generated/accounting/general-ledger
```

### Migration Path

1. **Phase 1**: Implement Option B (Proc-Macro Registry) - primary approach
2. **Phase 2**: Implement Option A (Cargo Build Script) - alternative if needed
3. **Phase 3**: Add config file support
4. **Phase 4**: Update CLI with new modes
5. **Phase 5**: Deprecate old hardcoded approach
6. **Phase 6**: Remove hardcoded entity matching

### Benefits

1. **CRITICAL**: Uses exact same compiled entities as the application
2. **Type-Safe**: Leverages existing compilation and type system
3. **Guaranteed Correctness**: Migrations match runtime behavior
4. **Flexible**: Multiple execution modes
5. **User-Friendly**: Clear errors, progress indicators, validation
6. **Maintainable**: No hardcoded entity lists
7. **Extensible**: Easy to add new features (e.g., diff generation, validation rules)
8. **Zero Schema Drift**: Cannot produce different SQL than what the app uses

### Dependencies

- `toml` - Config file parsing (already in Cargo.toml)
- Standard Rust compilation (entities must compile)

### Testing Strategy

1. **Unit Tests**: Test registry generation and access
2. **Integration Tests**: Test full workflow with compiled entities
3. **Edge Cases**: 
   - Entities with all attribute types
   - Nested modules
   - Multiple entities per file
   - Compilation errors (tool must fail gracefully)

## Alternative: Keep Current Approach but Make It Dynamic

If Option A is too complex, we could:

1. **Remove hardcoded match statement** - Use a registry pattern
2. **Dynamic module loading** - Use `include!()` macro with generated code
3. **Build script** - Generate `entities.rs` from discovered files

However, this still requires compilation and is less elegant than Option A.

## Implementation Strategy

### Phase 1: Option B (Proc-Macro Registry) - Primary Implementation

**Why Start Here**:
- **CRITICAL**: Ensures migrations match what the application actually uses
- Uses the exact same compiled entities as the backend
- Most elegant and automatic solution
- Zero risk of schema drift

**Implementation Steps**:
1. Enhance `lifeguard-derive` to support entity registration
2. Generate registry module during compilation
3. Update CLI to require registry (fail if not found)
4. Use existing SQL generator with compiled entities

### Phase 2: Option A (Cargo Build Script) - Alternative Implementation

**Why Add as Alternative**:
- Provides same guarantee as Option B (uses compiled entities)
- Can be implemented if Option B has technical challenges
- Still ensures migrations match application code

**Implementation Steps**:
1. Create build script infrastructure
2. Implement entity discovery in build script
3. Generate registry module
4. Update CLI to use registry (fail if not found)

### Critical Design Decision: NO FALLBACK, NO PARSING

**The tool MUST fail if it cannot access compiled entities**. There is no fallback mechanism. This ensures:
- Migrations always match what the application uses
- No silent schema drift
- Clear error messages guide users to fix the issue
- Production safety is maintained
- **Metadata parsing is explicitly rejected and will not be implemented**

**Error Handling**:
```rust
// Pseudo-code
if registry_not_found() {
    return Err(MigrationError::CompiledEntitiesRequired {
        hint: "Entities must be compiled. Ensure your project builds successfully. \
               The migration tool requires access to compiled entities to ensure \
               migrations match what your application uses."
    });
}
// No fallback - fail fast and clearly
```

## Recommendation

**CRITICAL INSIGHT**: Migrations must use the same compiled entities that the backend application uses. This is non-negotiable for production safety.

**Primary Implementation: Option B (Proc-Macro Registry)** because:
- ‚úÖ **CRITICAL**: Uses exact same compiled entities as the application
- ‚úÖ Guarantees migrations match runtime behavior
- ‚úÖ Automatic - no user configuration needed
- ‚úÖ Type-safe and leverages existing compilation
- ‚úÖ Zero risk of schema drift
- ‚úÖ Most elegant long-term solution

**Alternative: Option A (Cargo Build Script)** if Option B has technical challenges:
- ‚úÖ Still uses compiled entities (same guarantee)
- ‚úÖ Requires build script setup but ensures correctness
- ‚úÖ Can use existing SQL generator without modification

**EXPLICITLY REJECTED: Metadata Parsing**:
- ‚ùå **WILL NOT BE IMPLEMENTED** - May produce different SQL than compiled entities
- ‚ùå Cannot guarantee migrations match what the application uses
- ‚ùå Risk of schema drift
- ‚ùå **Completely rejected in any form**

**NO FALLBACK**: The tool must fail if compiled entities cannot be accessed. There is no fallback mechanism. This ensures production safety and prevents schema drift.

Since users always have Lifeguard as a dependency and their entities are already compiled as part of their project, we must leverage that compilation context to ensure migrations match exactly what the application uses.
