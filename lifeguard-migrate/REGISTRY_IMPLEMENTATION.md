# Entity Registry Implementation Design

## Overview

This document details the technical implementation of Option B (Proc-Macro Registry) for the migration tool. The registry allows the CLI tool to access compiled entities without hardcoding them.

## Technical Challenge

Proc-macros in Rust run in isolation and cannot easily share state across compilation units. Each macro expansion is independent. We need a mechanism to collect all entities during compilation and make them accessible to the CLI tool.

## Solution: Build Script + Macro-Generated Includes

**Hybrid Approach**: Combine proc-macro code generation with a build script to create a registry.

### Architecture

1. **Macro Enhancement**: `#[derive(LifeModel)]` generates registration code
2. **Build Script**: Collects all registration calls and generates registry module
3. **Registry Module**: Contains all entities accessible via `LifeModelTrait`

## Implementation Strategy

### Phase 1: Macro-Generated Registration Code

When `#[derive(LifeModel)]` is applied, generate code that:
- Creates a registration function that can be called at link time
- Includes entity metadata (table name, module path, etc.)
- Can be discovered by a build script

**Approach**: Generate a `register_entity!()` macro call that includes entity information.

```rust
// Generated by #[derive(LifeModel)]
#[linkme::distributed_slice(lifeguard_entity_registry)]
#[linkme(crate = lifeguard_migrate::registry)]
static ENTITY_REGISTRATION: EntityRegistration = EntityRegistration {
    table_name: "chart_of_accounts",
    entity_path: "accounting_entities::accounting::general_ledger::chart_of_accounts::Entity",
    module_path: module_path!(),
};
```

**Note**: This requires the `linkme` crate which uses linker sections. However, `linkme` requires nightly Rust.

### Alternative: Build Script Discovery

Since we need stable Rust, use a build script approach:

1. **Macro generates marker file**: Each `#[derive(LifeModel)]` writes entity info to a file in `OUT_DIR`
2. **Build script collects markers**: Reads all marker files and generates registry module
3. **Registry module**: Includes all entities via `#[path = "..."]` includes

## Recommended: Build Script Approach (Stable Rust)

### Step 1: Entity Marker Generation

In `lifeguard-derive`, when `#[derive(LifeModel)]` is processed:

```rust
// Generate marker file in OUT_DIR
let out_dir = env::var("OUT_DIR").unwrap();
let marker_file = format!("{}/lifeguard_entity_{}.json", out_dir, table_name);
let marker = EntityMarker {
    table_name: table_name.clone(),
    struct_name: struct_name.to_string(),
    module_path: module_path!().to_string(),
    file_path: file!().to_string(),
};
fs::write(marker_file, serde_json::to_string(&marker)?)?;
```

### Step 2: Build Script Registry Generation

User's `build.rs` (or auto-generated):

```rust
fn main() {
    // Collect all entity markers
    let out_dir = env::var("OUT_DIR").unwrap();
    let markers = collect_entity_markers(&out_dir)?;
    
    // Generate registry module
    generate_registry_module(&markers, &out_dir)?;
}
```

### Step 3: Registry Module Structure

Generated `entity_registry.rs`:

```rust
// Auto-generated - DO NOT EDIT
pub mod entity_registry {
    #[path = "path/to/chart_of_accounts.rs"]
    pub mod chart_of_accounts;
    
    #[path = "path/to/account.rs"]
    pub mod account;
    
    // ... more entities
    
    pub fn all_entities() -> Vec<&'static dyn lifeguard::LifeModelTrait> {
        vec![
            &chart_of_accounts::Entity::default(),
            &account::Entity::default(),
            // ... more
        ]
    }
}
```

### Step 4: CLI Tool Access

CLI tool loads the registry:

```rust
// In user's project (compiled)
use entity_registry::entity_registry;

// CLI tool can access
for entity in entity_registry::all_entities() {
    let table_def = entity.table_definition();
    generate_sql(entity, table_def)?;
}
```

## Implementation Plan

1. **Add marker generation to lifeguard-derive**
   - Write entity marker JSON files during macro expansion
   - Include table_name, struct_name, module_path, file_path

2. **Create build script helper library**
   - `lifeguard-migrate-build` crate
   - Functions to collect markers and generate registry

3. **Generate registry module**
   - Create `entity_registry.rs` with all entities
   - Include `all_entities()` function

4. **Update CLI tool**
   - Load registry from compiled artifacts
   - Iterate over entities and generate SQL

5. **Auto-detect build script**
   - Provide helper to add build script to user's `Cargo.toml`
   - Or detect and use automatically

## Alternative: Simpler Build Script (Option A)

If proc-macro registry proves too complex, fall back to pure build script approach:
- Build script scans source directories
- Generates registry module directly
- No macro changes needed

This is Option A from the design document and is more straightforward to implement.
