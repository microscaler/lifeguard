//! Comprehensive tests for SQL generation from entities
//!
//! These tests verify that SQL generated from Lifeguard entities matches
//! the original SQL migrations in migrations/original/

// Use the library crate
use lifeguard_migrate::sql_generator;
use lifeguard::{LifeModelTrait, ColumnTrait};
use sea_query::IdenStatic;
use std::fs;
use std::path::PathBuf;

// Import test entities - we'll create simple test entities here
// In a real scenario, these would be imported from examples/entities

#[cfg(test)]
mod test_entities {
    use lifeguard_derive::LifeModel;
    
    #[derive(LifeModel)]
    #[table_name = "chart_of_accounts"]
    #[table_comment = "Hierarchical chart of accounts structure"]
    #[index = "idx_chart_of_accounts_code(code)"]
    #[index = "idx_chart_of_accounts_parent_id(parent_id)"]
    #[index = "idx_chart_of_accounts_account_type(account_type)"]
    #[index = "idx_chart_of_accounts_is_active(is_active)"]
    pub struct ChartOfAccount {
        #[primary_key]
        pub id: uuid::Uuid,
        
        #[unique]
        #[indexed]
        #[column_type = "VARCHAR(50)"]
        pub code: String,
        
        #[column_type = "VARCHAR(255)"]
        pub name: String,
        
        #[indexed]
        #[column_type = "VARCHAR(50)"]
        pub account_type: String,
        
        #[foreign_key = "chart_of_accounts(id) ON DELETE SET NULL"]
        #[indexed]
        pub parent_id: Option<uuid::Uuid>,
        
        #[default_value = "0"]
        pub level: i32,
        
        #[default_value = "true"]
        #[indexed]
        pub is_active: bool,
        
        pub description: Option<String>,
        
        #[default_expr = "CURRENT_TIMESTAMP"]
        pub created_at: chrono::NaiveDateTime,
        
        #[default_expr = "CURRENT_TIMESTAMP"]
        pub updated_at: chrono::NaiveDateTime,
    }
}

#[test]
fn test_chart_of_accounts_sql_generation() {
    // Define entity directly in test function (like lifeguard-derive tests)
    // This matches the working pattern from test_column_type_attribute
    use lifeguard_derive::LifeModel;
    
    #[derive(LifeModel)]
    #[table_name = "chart_of_accounts"]
    #[table_comment = "Hierarchical chart of accounts structure"]
    #[index = "idx_chart_of_accounts_code(code)"]
    #[index = "idx_chart_of_accounts_parent_id(parent_id)"]
    #[index = "idx_chart_of_accounts_account_type(account_type)"]
    #[index = "idx_chart_of_accounts_is_active(is_active)"]
    pub struct ChartOfAccount {
        #[primary_key]
        pub id: uuid::Uuid,
        
        #[unique]
        #[indexed]
        #[column_type = "VARCHAR(50)"]
        pub code: String,
        
        #[column_type = "VARCHAR(255)"]
        pub name: String,
        
        #[indexed]
        #[column_type = "VARCHAR(50)"]
        pub account_type: String,
        
        #[foreign_key = "chart_of_accounts(id) ON DELETE SET NULL"]
        #[indexed]
        pub parent_id: Option<uuid::Uuid>,
        
        #[default_value = "0"]
        pub level: i32,
        
        #[default_value = "true"]
        #[indexed]
        pub is_active: bool,
        
        pub description: Option<String>,
        
        #[default_expr = "CURRENT_TIMESTAMP"]
        pub created_at: chrono::NaiveDateTime,
        
        #[default_expr = "CURRENT_TIMESTAMP"]
        pub updated_at: chrono::NaiveDateTime,
    }
    
    // Entity is generated by the macro in the same scope
    // Access it directly (macro generates it in the same scope as the struct)
    use lifeguard::LifeModelTrait;
    
    let table_def = Entity::table_definition();
    
    // Access columns directly (like the working minimal test)
    // This matches the pattern from test_column_type_attribute which works
    // Column enum variants are in PascalCase (e.g., Id, Code, Name)
    let id_col = <Entity as LifeModelTrait>::Column::Id;
    let id_def = id_col.column_def();
    println!("id column_type = {:?} (should be Some(\"UUID\") from type inference)", id_def.column_type);
    
    let code_col = <Entity as LifeModelTrait>::Column::Code;
    let code_def = code_col.column_def();
    println!("code column_type = {:?} (should be Some(\"VARCHAR(50)\"))", code_def.column_type);
    println!("code unique = {} (should be true)", code_def.unique);
    
    let name_col = <Entity as LifeModelTrait>::Column::Name;
    let name_def = name_col.column_def();
    println!("name column_type = {:?} (should be Some(\"VARCHAR(255)\"))", name_def.column_type);
    
    let level_col = <Entity as LifeModelTrait>::Column::Level;
    let level_def = level_col.column_def();
    println!("level default_value = {:?} (should be Some(\"0\"))", level_def.default_value);
    
    let parent_id_col = <Entity as LifeModelTrait>::Column::ParentId;
    let parent_id_def = parent_id_col.column_def();
    println!("parent_id foreign_key = {:?} (should be Some(\"chart_of_accounts(id) ON DELETE SET NULL\"))", parent_id_def.foreign_key);
    println!("parent_id nullable = {} (should be true - it's Option<uuid::Uuid>)", parent_id_def.nullable);
    
    // Now use all_columns() for SQL generation
    // Use column_def() instead of def() - the macro generates column_def() with all metadata
    let columns = Entity::all_columns();
    println!("\nUsing all_columns() with column_def():");
    for col in columns {
        let col_def = col.column_def();
        println!("  {}: column_type={:?}, nullable={}, default_value={:?}, default_expr={:?}, unique={}, foreign_key={:?}", 
            col.as_str(), 
            col_def.column_type, 
            col_def.nullable,
            col_def.default_value,
            col_def.default_expr,
            col_def.unique,
            col_def.foreign_key
        );
    }
    
    // Generate SQL
    let generated_sql = sql_generator::generate_create_table_sql::<Entity>(table_def)
        .expect("Should generate SQL");
    
    println!("Generated SQL:\n{}", generated_sql);
    
    // Load original SQL
    let migrations_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .join("migrations")
        .join("original");
    
    let original_file = migrations_dir.join("20240120120000_create_chart_of_accounts.sql");
    
    if !original_file.exists() {
        eprintln!("Warning: Original migration file not found: {:?}", original_file);
        eprintln!("Skipping comparison test");
        return;
    }
    
    let original_sql = fs::read_to_string(&original_file)
        .expect("Should read original SQL file");
    
    // Extract chart_of_accounts table definition from original
    let original_table_sql = extract_table_sql(&original_sql, "chart_of_accounts")
        .expect("Should extract table SQL");
    
    println!("\nOriginal SQL (chart_of_accounts table):\n{}", original_table_sql);
    
    // Compare (normalized)
    let generated_normalized = normalize_sql(&generated_sql);
    let original_normalized = normalize_sql(&original_table_sql);
    
    if generated_normalized == original_normalized {
        println!("\n✅ Generated SQL matches original!");
    } else {
        println!("\n❌ Generated SQL differs from original!");
        println!("\nDifferences:");
        compare_sql(&generated_normalized, &original_normalized);
        
        // For now, don't fail the test - we're still iterating
        // panic!("SQL generation mismatch");
    }
}

#[test]
fn test_load_original_migrations() {
    // Test that we can load the original migration files
    let migrations_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .join("migrations")
        .join("original");
    
    let chart_of_accounts_file = migrations_dir.join("20240120120000_create_chart_of_accounts.sql");
    
    assert!(
        chart_of_accounts_file.exists(),
        "Original migration file should exist: {:?}",
        chart_of_accounts_file
    );
    
    let content = fs::read_to_string(&chart_of_accounts_file)
        .expect("Should be able to read migration file");
    
    assert!(
        content.contains("CREATE TABLE IF NOT EXISTS chart_of_accounts"),
        "Migration file should contain chart_of_accounts table definition"
    );
}

fn extract_table_sql(sql: &str, table_name: &str) -> Result<String, Box<dyn std::error::Error>> {
    // Extract CREATE TABLE statement for the specified table
    let start_marker = format!("CREATE TABLE IF NOT EXISTS {}", table_name);
    let end_marker = ");";
    
    if let Some(start) = sql.find(&start_marker) {
        if let Some(end) = sql[start..].find(end_marker) {
            let table_sql = &sql[start..start + end + end_marker.len()];
            
            // Also extract indexes and comments for this table
            let mut result = table_sql.to_string();
            result.push('\n');
            
            // Extract indexes
            for line in sql.lines() {
                if line.contains(&format!("ON {}", table_name)) {
                    result.push_str(line.trim());
                    result.push('\n');
                }
            }
            
            // Extract comment
            for line in sql.lines() {
                if line.contains(&format!("COMMENT ON TABLE {}", table_name)) {
                    result.push_str(line.trim());
                    result.push('\n');
                }
            }
            
            return Ok(result);
        }
    }
    
    Err(format!("Could not find table definition for {}", table_name).into())
}

fn normalize_sql(sql: &str) -> String {
    sql.lines()
        .map(|line| line.trim())
        .filter(|line| !line.is_empty() && !line.starts_with("--"))
        .collect::<Vec<_>>()
        .join("\n")
}

fn compare_sql(generated: &str, original: &str) {
    let gen_lines: Vec<&str> = generated.lines().collect();
    let orig_lines: Vec<&str> = original.lines().collect();
    
    let max_len = gen_lines.len().max(orig_lines.len());
    
    for i in 0..max_len {
        let gen_line = gen_lines.get(i).copied().unwrap_or("");
        let orig_line = orig_lines.get(i).copied().unwrap_or("");
        
        if gen_line != orig_line {
            println!("  Line {}:", i + 1);
            if !gen_line.is_empty() {
                println!("    Generated: {}", gen_line);
            }
            if !orig_line.is_empty() {
                println!("    Original:  {}", orig_line);
            }
        }
    }
}
