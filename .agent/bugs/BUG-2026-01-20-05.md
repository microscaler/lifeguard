# BUG-2026-01-20-05: Migration Lock Deadlock in startup_migrations

**Date:** 2026-01-20  
**Status:** ✅ FIXED  
**Priority:** High  
**Severity:** Deadlock / Timeout

## Summary

The `startup_migrations()` and `startup_migrations_with_timeout()` functions were acquiring the migration lock via `MigrationLockGuard::new()`, then calling `migrator.up()` which also attempted to acquire the same lock. Since the Flyway-style lock is non-reentrant (uses `INSERT ... ON CONFLICT DO NOTHING`), the second acquisition would poll indefinitely waiting for the lock it already holds, causing a timeout/deadlock.

## Discovery

**Date:** 2026-01-20  
**Source:** Code review / Issue report  
**Severity:** `high`  
**Status:** `fixed`

## Location

- **File:** `src/migration/startup.rs`
- **Lines:** 56-67 (startup_migrations), 88-95 (startup_migrations_with_timeout)
- **Related File:** `src/migration/migrator.rs` (lines 216-218)

## Description

The migration system uses a Flyway-style table-based locking mechanism where a lock record (version = -1) is inserted into the `lifeguard_migrations` table. The process that successfully inserts this record holds the lock.

**The Bug:** Both `startup_migrations()` functions follow this pattern:
1. Acquire lock via `MigrationLockGuard::new()` (line 57/89)
2. Call `migrator.up()` (line 67/95)
3. `migrator.up()` internally tries to acquire the lock again (line 218 in migrator.rs)

Since the lock is non-reentrant (uses `INSERT ... ON CONFLICT DO NOTHING`), the second lock acquisition attempt:
- Tries to INSERT the lock record again
- Fails silently (ON CONFLICT DO NOTHING, rows_affected = 0)
- The polling loop in `acquire_migration_lock()` sees rows_affected = 0
- Assumes another process has the lock
- Continues waiting indefinitely for a lock it already holds
- Eventually times out or deadlocks

## Root Cause

The lock mechanism uses `INSERT ... ON CONFLICT DO NOTHING` with a primary key constraint on `version = -1`. When the same process tries to acquire the lock twice:
1. First acquisition succeeds (INSERT succeeds, rows_affected > 0)
2. Second acquisition fails silently (INSERT does nothing, rows_affected = 0)
3. The polling loop in `acquire_migration_lock()` sees rows_affected = 0 and continues waiting indefinitely

The `migrator.up()` method was designed to be called standalone (it acquires its own lock), but `startup_migrations()` functions already hold the lock, so they should use `up_with_lock()` instead.

## Fix

Changed `startup_migrations()` and `startup_migrations_with_timeout()` to:
1. Create a `SchemaManager` from the executor
2. Call `migrator.up_with_lock()` instead of `migrator.up()`

The `up_with_lock()` method assumes the lock is already held and does not attempt to acquire it again.

**Key Changes:**
```rust
// Before (broken):
let _lock = MigrationLockGuard::new(executor, timeout_seconds)?;
let migrator = Migrator::new(migrations_dir);
migrator.validate_checksums(executor)?;
let applied = migrator.up(executor, None)?;  // ❌ Tries to acquire lock again

// After (fixed):
let _lock = MigrationLockGuard::new(executor, timeout_seconds)?;
let migrator = Migrator::new(migrations_dir);
migrator.validate_checksums(executor)?;
let manager = SchemaManager::new(executor);
let applied = migrator.up_with_lock(executor, &manager, None)?;  // ✅ Uses existing lock
```

## Testing

- Verify that `startup_migrations()` no longer deadlocks when called
- Verify that migrations still execute correctly
- Verify that lock is properly released after migrations complete

## Impact

- **Fixes deadlock:** `startup_migrations()` functions no longer deadlock when called
- **No breaking changes:** Existing code continues to work, but now functions correctly
- **Improves reliability:** Migration startup is now safe from deadlock issues

## Related Files

- `src/migration/startup.rs` - Fixed to use `up_with_lock()` instead of `up()`
- `src/migration/migrator.rs` - Contains `up_with_lock()` method that assumes lock is held
- `src/migration/lock.rs` - Contains the non-reentrant lock mechanism

## Verification

- [x] Bug identified and root cause analyzed
- [x] Fix implemented (changed to use `up_with_lock()`)
- [x] Code compiles successfully
- [x] Comments added explaining the fix
- [ ] Integration tests verify fix works in real scenarios (recommended)
