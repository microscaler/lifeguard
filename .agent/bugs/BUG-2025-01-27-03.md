# BUG-2025-01-27-03: Invalid SQL Generated from TableRef Debug Formatting

## Metadata

- **ID**: BUG-2025-01-27-03
- **Date**: 2025-01-27
- **Source**: Cursor verification
- **Status**: `fixed`
- **Severity**: `critical`
- **Location**: `src/relation/def.rs:216-217`, `src/relation/def.rs:288`

## Description

Both `join_tbl_on_condition` and `build_where_condition` use `format!("{:?}", table_ref)` to convert `TableRef` to a string for SQL generation. The `{:?}` format specifier invokes Rust's `Debug` trait, which produces output like `Table(TableName(None, DynIden(...)), None)` rather than the actual table name (e.g., `"posts"`). This generates syntactically invalid SQL that cannot be executed against any database, regardless of other logic issues.

## Impact

- **Critical**: All SQL queries generated by `join_tbl_on_condition` and `build_where_condition` are syntactically invalid
- Affects all relationship queries (has_many, belongs_to, has_one)
- Prevents any related entity queries from executing successfully
- No runtime errors are raised until the SQL is executed, making this a silent failure

## Root Cause

The code was using `format!("{:?}", table_ref)` which calls the `Debug` implementation of `TableRef`, producing developer-facing debug output instead of the actual table name string needed for SQL.

## Solution

Created a helper function `extract_table_name()` that properly extracts the table name from `TableRef` by:
1. Matching on `TableRef::Table` variant
2. Extracting the `DynIden` from `TableName` tuple struct
3. Using `DynIden::to_string()` to get the actual table name string

Both `join_tbl_on_condition` and `build_where_condition` now use this helper function instead of `format!("{:?}", table_ref)`.

## Changes Made

1. **Added `extract_table_name()` helper function** (`src/relation/def.rs:111-149`)
   - Properly extracts table name from `TableRef::Table(TableName(schema, table), alias)`
   - Returns actual table name string, not debug representation

2. **Fixed `join_tbl_on_condition()`** (`src/relation/def.rs:216-217`)
   - Replaced `format!("{:?}", from_tbl)` with `extract_table_name(&from_tbl)`
   - Replaced `format!("{:?}", to_tbl)` with `extract_table_name(&to_tbl)`

3. **Fixed `build_where_condition()`** (`src/relation/def.rs:288`)
   - Replaced `format!("{:?}", rel_def.from_tbl)` with `extract_table_name(&rel_def.from_tbl)`

## Tests Added

1. **`test_extract_table_name()`** (`src/relation/def.rs`)
   - Verifies `extract_table_name()` returns actual table names
   - Ensures no debug representation (`Table(`, `TableName(`) appears in output

2. **`test_join_tbl_on_condition_single_key()`** (enhanced)
   - Now verifies generated SQL contains actual table names
   - Checks that SQL does not contain debug representation strings
   - Uses `PostgresQueryBuilder` to generate SQL and verify output

## Verification

- ✅ Code compiles successfully
- ✅ Unit tests pass
- ✅ SQL output verified to contain actual table names
- ✅ SQL output verified to not contain debug representation

## Related Files

- `src/relation/def.rs` - Main fix location
- `src/relation/def.rs` (tests) - Test verification

## Notes

This bug would have been caught immediately if integration tests were run against a real database, as the SQL would fail to execute. The fix ensures that all generated SQL uses proper table name strings that are valid SQL identifiers.
