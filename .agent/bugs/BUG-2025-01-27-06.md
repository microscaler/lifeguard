# BUG-2025-01-27-06: Incorrect Foreign Key Column Name Inference for Module-Qualified Entity Paths

## Summary

The `infer_foreign_key_column_name` function incorrectly handled module-qualified entity paths like `"super::users::Entity"`. When the last path segment is exactly `"Entity"` (common in module-based organization), the function would strip the entire segment since `"Entity".ends_with("Entity")` is true, resulting in an empty string. This produced `"_id"` instead of the expected `"user_id"`. The function's docstring claimed to handle this pattern by extracting the module name (e.g., `"users"`), but the implementation only correctly handled patterns like `"UserEntity"` or `"CommentEntity"`.

## Discovery

**Date**: 2025-01-27  
**Source**: User verification request  
**Severity**: `high`  
**Status**: `fixed`

## Location

- **File**: `lifeguard-derive/src/macros/relation.rs`
- **Lines**: 186-203 (function `infer_foreign_key_column_name`)

## Impact

When using module-qualified entity paths in `DeriveRelation` macro attributes (e.g., `belongs_to = "super::users::Entity"`), the foreign key column name inference would fail, producing `"_id"` instead of the correct `"user_id"`. This causes incorrect SQL generation when default column inference is used (i.e., when `from`/`to` attributes are not explicitly specified).

### Example

```rust
#[derive(DeriveRelation)]
pub enum Relation {
    #[lifeguard(belongs_to = "super::users::Entity")]
    // Without fix: infers "_id" (incorrect)
    // With fix: infers "user_id" (correct)
    User,
}
```

## Root Cause

The original implementation had this logic:

```rust
if last_segment.ends_with("Entity") {
    // Remove "Entity" suffix
    &last_segment[..last_segment.len() - 6]
}
```

For `"super::users::Entity"`, the last segment is `"Entity"`, which:
1. Matches `ends_with("Entity")` → strips "Entity" → results in empty string
2. Empty string → `"_id"` (incorrect)

The function should have checked if the last segment is exactly `"Entity"` AND there are multiple segments, then use the second-to-last segment (the module name).

## Fix

### Changes Made

Added special case handling before the `ends_with("Entity")` check:

```rust
// Special case: if the last segment is exactly "Entity" and there are multiple segments,
// use the second-to-last segment (e.g., "users" from "super::users::Entity")
if last_segment == "Entity" && segments.len() > 1 {
    segments[segments.len() - 2]
} else if last_segment.ends_with("Entity") && last_segment != "Entity" {
    // Remove "Entity" suffix if present (e.g., "CommentEntity" -> "Comment")
    &last_segment[..last_segment.len() - 6]
} else {
    last_segment
}
```

This correctly extracts the module name (`"users"`) from `"super::users::Entity"` while maintaining backward compatibility with existing patterns like `"UserEntity"` and `"CommentEntity"`.

## Testing

Added comprehensive test `test_derive_relation_module_qualified_path()` in `lifeguard-derive/tests/test_derive_relation.rs` that verifies:

1. **Module-qualified paths** (the bug case):
   - `"super::users::Entity"` → `"user_id"` ✅
   - `"super::authors::Entity"` → `"author_id"` ✅
   - `"crate::posts::Entity"` → `"post_id"` ✅
   - `"super::super::comments::Entity"` → `"comment_id"` ✅

2. **Backward compatibility** with existing patterns:
   - `"AuthorEntity"` → `"author_id"` ✅
   - `"UserEntity"` → `"user_id"` ✅
   - `"CommentEntity"` → `"comment_id"` ✅

### Test Results

```
running 1 test
test test_derive_relation_module_qualified_path ... ok

test result: ok. 1 passed; 0 failed; 0 ignored
```

## Verification

- ✅ Fix implemented correctly
- ✅ Tests pass
- ✅ Backward compatibility maintained
- ✅ Module-qualified paths now work correctly
- ✅ No breaking changes to existing code

## Related Issues

- Related to [BUG-2025-01-27-04](BUG-2025-01-27-04.md) - Default column inference in DeriveRelation macro
- Part of relationship system implementation (Epic 02)

## Notes

- The fix maintains backward compatibility for all existing entity path patterns
- The special case check must come before the `ends_with("Entity")` check to avoid the empty string issue
- The function correctly handles both module-qualified paths (`"super::users::Entity"`) and direct entity names (`"UserEntity"`)
