# BUG-2026-01-20-02: ValueType Inconsistent Value Variants for u8, u16, u32 Between into_value() and null_value()

**Date:** 2026-01-20  
**Status:** âœ… FIXED  
**Priority:** High  
**Severity:** API inconsistency / Incorrect null handling

## Summary

The `ValueType` implementations for `u8`, `u16`, and `u32` use inconsistent `Value` variants between `into_value()` and `null_value()`. For example, `u8::into_value()` produces `Value::SmallInt` but `u8::null_value()` returns `Value::TinyUnsigned(None)`. This breaks `Option<T>::from_value()`, which relies on comparing against `T::null_value()` to detect null.

## Discovery

**Date:** 2026-01-20  
**Source:** Code review / User report  
**Severity:** `high`  
**Status:** `open`

## Location

- **File:** `src/value/types.rs`
- **Lines:** 151-169 (u8), 171-189 (u16), 191-209 (u32)

## Description

When reading `Value::SmallInt(None)` as `Option<u8>`, the method incorrectly returns `None` (type mismatch) instead of `Some(None)` (null value). This happens because:

1. `u8::into_value()` produces `Value::SmallInt(Some(...))`
2. `u8::null_value()` returns `Value::TinyUnsigned(None)`
3. `Option<u8>::from_value()` compares the input value against `u8::null_value()` to detect null
4. When `Value::SmallInt(None)` is compared against `Value::TinyUnsigned(None)`, they don't match, so it's treated as a type mismatch

The same issue exists for:
- `u16`: `into_value()` produces `Value::Int(Some(...))` but `null_value()` returns `Value::SmallUnsigned(None)`
- `u32`: `into_value()` produces `Value::BigInt(Some(...))` but `null_value()` returns `Value::Unsigned(None)`

## Root Cause

The `null_value()` method should return the same `Value` variant that `into_value()` uses, just with `None` instead of `Some(...)`. This ensures consistency and allows `Option<T>::from_value()` to correctly detect null values.

## Fix

Update `null_value()` for `u8`, `u16`, and `u32` to return the same variant as `into_value()`:
- `u8::null_value()` should return `Value::SmallInt(None)` (not `Value::TinyUnsigned(None)`)
- `u16::null_value()` should return `Value::Int(None)` (not `Value::SmallUnsigned(None)`)
- `u32::null_value()` should return `Value::BigInt(None)` (not `Value::Unsigned(None)`)

The `from_value()` implementations already handle both the signed and unsigned variants, so this change maintains backward compatibility.

## Testing

Add tests to verify:
1. `Option<u8>::from_value()` correctly handles `Value::SmallInt(None)`
2. `Option<u16>::from_value()` correctly handles `Value::Int(None)`
3. `Option<u32>::from_value()` correctly handles `Value::BigInt(None)`
4. Round-trip tests: `Option<u8>::into_value()` followed by `Option<u8>::from_value()` works correctly

## Impact

- Breaks `Option<u8>`, `Option<u16>`, and `Option<u32>` value extraction when null values are represented using the signed integer variants
- May cause silent failures when reading nullable unsigned integer columns from the database

## Related Files

- `src/value/types.rs` - ValueType trait implementations

## Verification

- [x] Bug identified and root cause analyzed
- [x] Fix implemented
- [x] Test added to verify fix
- [x] Tests run and passing
- [x] Integration tests verify fix works in real scenarios

## Fix Applied

Updated `null_value()` implementations for `u8`, `u16`, and `u32` to return the same `Value` variant that `into_value()` uses:
- `u8::null_value()` now returns `Value::SmallInt(None)` (was `Value::TinyUnsigned(None)`)
- `u16::null_value()` now returns `Value::Int(None)` (was `Value::SmallUnsigned(None)`)
- `u32::null_value()` now returns `Value::BigInt(None)` (was `Value::Unsigned(None)`)

This ensures consistency between `into_value()` and `null_value()`, allowing `Option<T>::from_value()` to correctly detect null values. The `from_value()` implementations already handle both signed and unsigned variants, so backward compatibility is maintained.
