# BUG-2026-01-19-02: DeriveTryIntoModel Macro Silent Ignoring of parse_nested_meta Errors in extract_field_attribute

**Date:** 2026-01-19  
**Status:** ✅ FIXED | **Priority:** High | **Severity:** Silent failure / API inconsistency

## Summary

The `extract_field_attribute` function silently ignores `parse_nested_meta` errors by checking `.is_ok()` and continuing to the next attribute or returning `None`. If a user writes a malformed attribute like `#[lifeguard(convert = 123)]` (integer instead of string), it's silently ignored rather than producing a compile error. This can lead to conversions not being applied when the user intended them, causing subtle bugs if the types happen to match, or confusing type mismatch errors that don't mention the malformed attribute.

## Discovery

**Date:** 2026-01-19  
**Source:** User verification request  
**Severity:** `high`  
**Status:** `fixed`

## Location

- **File:** `lifeguard-derive/src/macros/try_into_model.rs`
- **Lines:** 256-279 (function `extract_field_attribute`)

## Description

The `extract_field_attribute` function was using `.is_ok()` to check the result of `parse_nested_meta`, silently ignoring parsing errors. When a user specified a malformed attribute value (e.g., `convert = 123` instead of `convert = "function_name"`), the error was silently ignored and the function would return `None`, causing the attribute to be treated as if it wasn't present.

### Example Scenario

```rust
#[derive(DeriveTryIntoModel)]
#[lifeguard(model = "UserModel")]
struct CreateUserRequest {
    #[lifeguard(convert = 123)]  // ERROR: Should be "function_name" but silently ignored!
    name: String,
}
```

**Before Fix:**
- Compiles successfully (no error)
- `convert` attribute is silently dropped
- Field is directly mapped without conversion
- If types happen to match, no error occurs but conversion is not applied
- If types don't match, confusing type mismatch error that doesn't mention the malformed attribute

**After Fix:**
- Compile error: `error: expected ','` or `error: expected string literal`
- User immediately knows their attribute is malformed
- Prevents silent failures and incorrect behavior

## Root Cause

The `parse_nested_meta` method returns `Result<(), syn::Error>`, but the result was being checked with `.is_ok()` and silently ignored if parsing failed:

```rust
// BEFORE (incorrect):
if attr.parse_nested_meta(|meta| {
    // ... parsing logic that may return errors ...
}).is_ok() {
    // Only process if parsing succeeded, but ignore errors
    if value.is_some() {
        return value;
    }
}
```

When `meta.value()?.parse()?` fails (e.g., trying to parse an integer as `syn::LitStr`), the error is returned from the closure, but the `.is_ok()` check discards it, causing the error to be silently ignored.

## Fix

### Changes Made

1. **Changed return type** (line 269):
   - Changed from `fn extract_field_attribute(...) -> Option<String>`
   - To `fn extract_field_attribute(...) -> Result<Option<String>, syn::Error>`
   - This allows propagating parsing errors as compile errors

2. **Propagate parse_nested_meta errors** (line 275):
   - Changed from `if attr.parse_nested_meta(...).is_ok() { ... }`
   - To `if let Err(err) = attr.parse_nested_meta(...) { return Err(err); }`
   - This propagates parsing errors immediately instead of silently ignoring them

3. **Updated call sites** (lines 97-108):
   - Updated calls to `extract_field_attribute` to handle the `Result` return type
   - Errors are converted to compile errors using `err.to_compile_error()`

4. **Added comprehensive tests** (`lifeguard-derive/tests/ui/`):
   - `compile_error_try_into_model_malformed_convert.rs`: Tests malformed `convert` attribute
   - `compile_error_try_into_model_malformed_map_from.rs`: Tests malformed `map_from` attribute
   - Both tests verify that compile errors are properly reported

### Code Changes

```rust
// BEFORE (incorrect):
fn extract_field_attribute(field: &Field, attr_name: &str) -> Option<String> {
    for attr in &field.attrs {
        if attr.path().is_ident("lifeguard") {
            let mut value: Option<String> = None;
            if attr.parse_nested_meta(|meta| {
                // ... parsing logic ...
            }).is_ok() {
                if value.is_some() {
                    return value;
                }
            }
        }
    }
    None
}

// AFTER (correct):
fn extract_field_attribute(field: &Field, attr_name: &str) -> Result<Option<String>, syn::Error> {
    for attr in &field.attrs {
        if attr.path().is_ident("lifeguard") {
            let mut value: Option<String> = None;
            // Check result and propagate errors instead of silently ignoring them
            if let Err(err) = attr.parse_nested_meta(|meta| {
                // ... parsing logic ...
            }) {
                // Return parse error immediately - malformed attribute detected
                return Err(err);
            }
            if value.is_some() {
                return Ok(value);
            }
        }
    }
    Ok(None)
}
```

## Testing

Added comprehensive UI tests using `trybuild` to verify compile errors are properly reported:

1. **`test compile_error_try_into_model_malformed_convert`**: Verifies `convert = 123` causes compile error
2. **`test compile_error_try_into_model_malformed_map_from`**: Verifies `map_from = 456` causes compile error

### Test Results

```
running 2 tests
test compile_error_try_into_model_malformed_convert ... ok
test compile_error_try_into_model_malformed_map_from ... ok

test result: ok. 2 passed; 0 failed; 0 ignored
```

All tests pass, confirming that malformed attributes now properly generate compile errors.

## Impact

This fix ensures that:
- Users get immediate feedback when they specify invalid attribute values
- Malformed attributes are caught at compile time instead of causing silent failures
- Error messages are clear and point to the exact location of the problem
- No breaking changes to existing valid code

## Related Issues

- Related to BUG-2025-01-27-07: Similar issue in DeriveRelation macro that was fixed using the same pattern
- Prevents silent failures that lead to incorrect behavior or confusing error messages
- Part of the TryIntoModel feature implementation (Epic 02)

## Verification

- ✅ Tests pass
- ✅ Malformed attributes now cause compile errors instead of being silently ignored
- ✅ Error messages are clear and point to the exact location of the problem
- ✅ No breaking changes to existing valid code
- ✅ Follows the same pattern as the fix for BUG-2025-01-27-07

## Notes

- The fix ensures all parsing errors are properly propagated as compile errors
- Users now get immediate feedback when they specify invalid attribute values
- This prevents runtime errors and incorrect behavior caused by silently dropped attributes
- The error messages are generated by `syn::Error::to_compile_error()`, which provides clear, location-aware error messages
- This reintroduces the same pattern that was identified and fixed in BUG-2025-01-27-07 for `DeriveRelation`, demonstrating the importance of consistent error handling across all macros
