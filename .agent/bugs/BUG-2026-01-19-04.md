# BUG-2026-01-19-04: DeriveRelation Macro Non-Exhaustive Match in def() Method for Duplicate Relations and Unannotated Variants

**Date:** 2026-01-19  
**Status:** âœ… FIXED  
**Priority:** High  
**Severity:** Compilation error / Non-exhaustive match

## Summary

The `DeriveRelation` macro's generated `def()` method had non-exhaustive match patterns when:
1. Multiple enum variants targeted the same entity (whether with same or different column configurations)
2. Enum variants without `#[lifeguard(...)]` attributes were mixed with annotated variants

This caused compilation errors because the generated `def()` method was missing match arms for some variants.

## Discovery

**Date:** 2026-01-19  
**Source:** Code review and test failures  
**Severity:** `high`  
**Status:** `fixed`

## Location

- **File:** `lifeguard-derive/src/macros/relation.rs`
- **Lines:** 330-550 (main loop and def() generation)

## Description

The `DeriveRelation` macro generates a `def()` method for the Relation enum that returns a `RelationDef` for each variant. However, the implementation had two issues:

### Issue 1: Duplicate Relations with Same Column Config
When multiple variants targeted the same entity with the same column configuration, the macro would:
- Generate only one `Related` impl (correct, to avoid duplicates)
- Skip adding a match arm for the duplicate variant (incorrect)
- Result: Non-exhaustive match error for the skipped variant

Example:
```rust
#[derive(DeriveRelation)]
pub enum Relation {
    #[lifeguard(has_many = "PostEntity")]
    CreatedPosts,
    #[lifeguard(has_many = "PostEntity")]  // Same config - skipped Related impl
    EditedPosts,  // Missing match arm in def() method
}
```

### Issue 2: Duplicate Relations with Different Column Configs
When multiple variants targeted the same entity with different column configurations, the macro would:
- Emit a compile error (correct)
- Skip adding a match arm for the error variant (incorrect)
- Result: Non-exhaustive match error in addition to the configuration error

### Issue 3: Unannotated Variants
When enum variants without `#[lifeguard(...)]` attributes were present alongside annotated variants:
- The macro would silently skip unannotated variants
- Generate `def()` method with match arms only for annotated variants
- Result: Non-exhaustive match error for unannotated variants

Example:
```rust
#[derive(DeriveRelation)]
pub enum Relation {
    #[lifeguard(has_many = "PostEntity")]
    Posts,
    UnannotatedVariant,  // Missing match arm in def() method
}
```

## Root Cause

1. **Duplicate handling**: When skipping duplicate `Related` impls, the code used `continue` without adding a match arm to `def_match_arms`.
2. **Error handling**: When emitting errors for different column configs, the code used `continue` without adding a match arm.
3. **Unannotated variants**: The code only processed variants with `#[lifeguard(...)]` attributes, so unannotated variants were never added to `def_match_arms`.

## Fix

### Changes Made

1. **Track RelationDef for duplicates**: Modified `seen_related_impls` to store the `RelationDef` construction code, allowing reuse for duplicate variants with same config.

2. **Add match arms for duplicates**: When a duplicate variant with same config is detected, add a match arm that reuses the existing `RelationDef`:
   ```rust
   // Same column configuration - skip this Related impl (already generated)
   // But still add a match arm that reuses the same RelationDef
   let existing_def_str = existing_def_relation_def.to_string();
   if !existing_def_str.trim().is_empty() {
       def_match_arms.push(quote! {
           #enum_name::#variant_name => #existing_def_relation_def,
       });
   }
   ```

3. **Add match arms for error cases**: When different column configs are detected, add a match arm that panics:
   ```rust
   def_match_arms.push(quote! {
       #enum_name::#variant_name => {
           panic!("Multiple relations target the same entity with different column configurations. See compile error above.")
       },
   });
   ```

4. **Track all variants**: Added a first pass to collect all variant names (including unannotated ones).

5. **Add match arms for unannotated variants**: When `process_relation_variant` returns `None`, add a match arm that panics:
   ```rust
   } else {
       // If process_relation_variant returns None, it means there was no relationship info
       // This is not an error case, just a variant without relationship attributes
       // We still need to add a match arm for this variant to make def() exhaustive
       let variant_name = variant.ident.clone();
       def_match_arms.push(quote! {
           #enum_name::#variant_name => {
               panic!("Relation variant `{}` does not have a `#[lifeguard(...)]` attribute and cannot be used with `def()` method.", stringify!(#variant_name))
           },
       });
   }
   ```

## Testing

### Positive Cases
- **Test**: `test_derive_relation_duplicate_same_config`
  - Verifies that multiple variants targeting the same entity with same column config both work with `def()` method
  - Both variants get match arms and return the same `RelationDef`

### Negative Cases
- **Test**: `test_derive_relation_mixed_annotated_unannotated`
  - Verifies that unannotated variants get match arms that panic when `def()` is called
  - Ensures exhaustive match pattern

- **Test**: `compile_error_duplicate_related_impl_different_columns`
  - Updated expected stderr to remove non-exhaustive match error
  - Verifies that error cases get match arms (even though they panic)

## Impact

- **Before**: Compilation errors for non-exhaustive match patterns in `def()` method
- **After**: All variants (annotated, unannotated, duplicates) have match arms in `def()` method
- **Breaking Changes**: None - this is a bug fix that makes the macro work correctly

## Related Files

- `lifeguard-derive/src/macros/relation.rs` - Main fix location
- `lifeguard-derive/tests/test_derive_relation.rs` - Test cases added
- `lifeguard-derive/tests/ui/compile_error_duplicate_related_impl_different_columns.stderr` - Updated expected output

## Verification

- [x] Bug identified and root cause analyzed
- [x] Fix implemented
- [x] Test added to verify fix
- [x] Tests run and passing
- [x] Integration tests verify fix works in real scenarios
