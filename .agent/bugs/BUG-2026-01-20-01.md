# BUG-2026-01-20-01: TryGetable Returns TypeMismatch Instead of ConversionError for Negative Values

**Date:** 2026-01-20  
**Status:** ✅ FIXED  
**Priority:** High  
**Severity:** API inconsistency / Incorrect error type

## Summary

The `TryGetable` implementations for `u8`, `u16`, and `u32` incorrectly returned `TypeMismatch` errors when signed values were out of range (negative or overflow) for the target type. This contradicted the PR's stated goal of distinguishing between type mismatches and conversion errors.

## Discovery

**Date:** 2026-01-20  
**Source:** User report  
**Severity:** `high`  
**Status:** `fixed`

## Location

- **File:** `src/value/try_getable.rs`
- **Lines:** 114-163 (u8, u16, u32 implementations)

## Description

When attempting to extract unsigned integer types (`u8`, `u16`, `u32`) from signed integer `Value` variants, the implementations would:

1. Check if the value was in the valid range using pattern guards: `if v >= 0 && v <= MAX`
2. If the value didn't match (e.g., negative or overflow), it would fall through to the `_` catch-all pattern
3. The catch-all pattern returned `TypeMismatch` error, even though the value type WAS correct (e.g., `SmallInt`), but the value was simply out of range

**Example:**
```rust
let value = Value::SmallInt(Some(-1));
let result: Result<u8, _> = TryGetable::try_get(value);
// ❌ Before: Returns TypeMismatch("expected TinyUnsigned or SmallInt")
// ✅ After: Returns ConversionError("Cannot convert negative value -1 to u8")
```

## Root Cause

The match expressions for unsigned types used pattern guards to check valid ranges, but didn't explicitly handle:
1. Negative values (which should return `ConversionError` for range underflow)
2. Overflow values (which should return `ConversionError` for range overflow)

When values didn't match the guarded pattern, they fell through to the `_` case, which incorrectly returned `TypeMismatch`.

## Fix

Added explicit pattern matching for negative values and overflow cases:

1. **For negative values:** Added explicit check `if v < 0` that returns `ConversionError` with a clear message
2. **For overflow values:** Added explicit catch-all for signed integer variants that returns `ConversionError` with overflow details
3. **Updated tests:** Changed existing overflow tests to expect `ConversionError` instead of `TypeMismatch`
4. **Added tests:** Added new tests for negative value handling (`test_try_get_u8_negative`, `test_try_get_u16_negative`, `test_try_get_u32_negative`)

**Fixed implementations:**
- `u8::try_get` - Now handles `Value::SmallInt(Some(v))` with explicit negative and overflow checks
- `u16::try_get` - Now handles `Value::Int(Some(v))` with explicit negative and overflow checks  
- `u32::try_get` - Now handles `Value::BigInt(Some(v))` with explicit negative and overflow checks

## Testing

**Tests added:**
- `test_try_get_u8_negative` - Verifies negative values return `ConversionError`
- `test_try_get_u16_negative` - Verifies negative values return `ConversionError`
- `test_try_get_u32_negative` - Verifies negative values return `ConversionError`

**Tests updated:**
- `test_try_get_u8_overflow` - Now expects `ConversionError` instead of `TypeMismatch`
- `test_try_get_u16_overflow` - Now expects `ConversionError` instead of `TypeMismatch`
- `test_try_get_u32_overflow` - Now expects `ConversionError` instead of `TypeMismatch`

**Test results:**
```
test value::try_getable::tests::test_try_get_u8_negative ... ok
test value::try_getable::tests::test_try_get_u8_overflow ... ok
test value::try_getable::tests::test_try_get_u16_negative ... ok
test value::try_getable::tests::test_try_get_u16_overflow ... ok
test value::try_getable::tests::test_try_get_u32_negative ... ok
test value::try_getable::tests::test_try_get_u32_overflow ... ok
```

All 36 tests in `value::try_getable::tests` pass.

## Impact

**Before fix:**
- Negative values returned `TypeMismatch` (incorrect - value type was correct)
- Overflow values returned `TypeMismatch` (incorrect - value type was correct)
- Error messages were misleading, claiming type mismatch when the issue was range conversion

**After fix:**
- Negative values return `ConversionError` with clear message about negative value
- Overflow values return `ConversionError` with clear message about overflow
- Error types correctly distinguish between type mismatches and conversion failures
- Aligns with PR goal of proper error type distinction

## Related Files

- `src/value/try_getable.rs` - Fixed implementations and tests
- `src/value/mod.rs` - Public API (no changes needed)
- `src/lib.rs` - Public API (no changes needed)

## Verification

- [x] Bug identified and root cause analyzed
- [x] Fix implemented
- [x] Test added to verify fix
- [x] Tests run and passing
- [x] Integration tests verify fix works in real scenarios

## Related Issues

This is similar to previous fixes for error type distinction in the value extraction system. The fix ensures that:
- `TypeMismatch` is only returned when the `Value` variant itself is wrong (e.g., trying to extract `i32` from `Value::String`)
- `ConversionError` is returned when the value type is correct but the value is out of range (negative, overflow, etc.)
