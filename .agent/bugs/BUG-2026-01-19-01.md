# BUG-2026-01-19-01: DeriveTryIntoModel Macro extract_field_attribute Only Checks First Attribute and Custom Error Type Handling Issues

**Date:** 2026-01-19  
**Status:** âœ… FIXED  
**Priority:** High  
**Severity:** Silent failure / API inconsistency

## Summary

Two related issues in the `DeriveTryIntoModel` macro:
1. The `extract_field_attribute` function returns after processing the first `#[lifeguard(...)]` attribute, even if that attribute doesn't contain the requested key. If a user splits attributes across multiple `#[lifeguard]` blocks (e.g., `#[lifeguard(map_from = "foo")]` and `#[lifeguard(convert = "bar")]` on separate lines), the second attribute is silently ignored.
2. When a custom error type is specified via `#[lifeguard(error = "CustomError")]` and a field uses `#[lifeguard(convert = "...")]`, the generated code uses `?` directly which requires `CustomError: From<ConversionError>`. This is an undocumented requirement that causes confusing compilation failures.

## Discovery

**Date:** 2026-01-19  
**Source:** User report  
**Severity:** `high`  
**Status:** `fixed`

## Location

- **File:** `lifeguard-derive/src/macros/try_into_model.rs`
- **Lines:** 245-263 (extract_field_attribute function), 135-156 (custom error handling)

## Description

### Issue 1: extract_field_attribute Only Checks First Attribute

The `extract_field_attribute` function iterates through field attributes and when it finds a `#[lifeguard]` attribute, it calls `parse_nested_meta` and returns immediately if parsing succeeds, even if the requested attribute key was not found. This means:

```rust
#[derive(DeriveTryIntoModel)]
#[lifeguard(model = "UserModel")]
struct CreateUserRequest {
    #[lifeguard(map_from = "name")]  // First attribute - checked
    #[lifeguard(convert = "convert_fn")]  // Second attribute - silently ignored!
    user_name: String,
}
```

The `convert` attribute would be silently ignored because the function returns after processing the first `#[lifeguard]` attribute.

### Issue 2: Custom Error Type Requires Undocumented From Trait

When using a custom error type with a conversion function that returns a different error type:

```rust
#[derive(DeriveTryIntoModel)]
#[lifeguard(model = "UserModel", error = "CustomError")]
struct CreateUserRequest {
    #[lifeguard(convert = "convert_name")]  // Returns Result<String, ParseIntError>
    name: String,
}
```

The generated code uses `?` directly:
```rust
name: convert_name(self.name)?,  // Requires CustomError: From<ParseIntError>
```

This requires `CustomError: From<ParseIntError>` to be implemented, which is an undocumented requirement. If not implemented, users get confusing compilation errors about the `?` operator.

## Root Cause

### Issue 1
The `extract_field_attribute` function returns `value` (which could be `None`) immediately after parsing the first `#[lifeguard]` attribute, even if that attribute didn't contain the requested key. It should continue checking all attributes and only return `None` if none of them contain the requested key.

### Issue 2
The code uses `?` directly for custom error types, which implicitly requires `From` trait implementation. The code should use `map_err` with `Into::into` to make the requirement more explicit and provide clearer error messages.

## Fix

### Issue 1: Check All Attributes
Modified `extract_field_attribute` to continue checking all `#[lifeguard]` attributes instead of returning early:

```rust
fn extract_field_attribute(field: &Field, attr_name: &str) -> Option<String> {
    for attr in &field.attrs {
        if attr.path().is_ident("lifeguard") {
            let mut value: Option<String> = None;
            if attr.parse_nested_meta(|meta| {
                if meta.path.is_ident(attr_name) {
                    let lit: syn::LitStr = meta.value()?.parse()?;
                    value = Some(lit.value());
                    Ok(())
                } else {
                    Ok(())
                }
            }).is_ok() {
                // If we found the requested attribute, return it
                // Otherwise, continue checking other attributes
                if value.is_some() {
                    return value;
                }
            }
        }
    }
    None
}
```

### Issue 2: Use Explicit Error Conversion
Changed the generated code to use `map_err` with `Into::into` instead of direct `?`:

```rust
// Before (for custom error types):
#target_field_name: #convert_fn_ident(self.#field_name)?,

// After:
#target_field_name: #convert_fn_ident(self.#field_name)
    .map_err(std::convert::Into::<#error_type>::into)?,
```

This makes the `From` trait requirement more explicit and provides clearer error messages when the conversion is not available.

## Testing

### Tests Added
1. **test_derive_try_into_model_split_attributes** - Verifies that split attributes work correctly
2. **compile_pass_try_into_model_split_attributes** - UI test that verifies split attributes compile successfully
3. Updated **compile_error_try_into_model_custom_error_convert.stderr** - Updated expected error message to match new implementation

### Test Files
- `lifeguard-derive/tests/test_try_into_model.rs` - Added test for split attributes
- `lifeguard-derive/tests/ui/compile_error_try_into_model_split_attributes.rs` - UI test for split attributes
- `lifeguard-derive/tests/ui/compile_error_try_into_model_custom_error_convert.stderr` - Updated error message

## Impact

- **User Experience**: Users can now split `#[lifeguard]` attributes across multiple lines without silent failures
- **Error Messages**: Custom error type conversion errors are now more explicit and easier to understand
- **API Consistency**: The `From` trait requirement is now more explicit in the generated code

## Related Files

- `lifeguard-derive/src/macros/try_into_model.rs` - Main implementation
- `lifeguard-derive/tests/test_try_into_model.rs` - Unit tests
- `lifeguard-derive/tests/ui/compile_error_try_into_model_split_attributes.rs` - UI test
- `lifeguard-derive/tests/ui/compile_error_try_into_model_custom_error_convert.rs` - Compile error test

## Verification

- [x] Bug identified and root cause analyzed
- [x] Fix implemented
- [x] Test added to verify fix
- [x] Tests run and passing
- [x] Integration tests verify fix works in real scenarios
