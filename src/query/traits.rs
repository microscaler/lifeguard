//! Core traits for entity and model definitions.
//!
//! This module provides the fundamental traits that entities must implement:
//! - `LifeEntityName`: Provides table name information
//! - `LifeModelTrait`: Main entity trait with CRUD operations
//!
//! # Examples
//!
//! ```no_run
//! use lifeguard::{LifeModelTrait, LifeEntityName, LifeExecutor};
//! use sea_query::Expr;
//!
//! # struct User;
//! # struct UserModel { id: i32, name: String };
//! # impl lifeguard::FromRow for UserModel {
//! #     fn from_row(_row: &may_postgres::Row) -> Result<Self, may_postgres::Error> { todo!() }
//! # }
//! # impl lifeguard::LifeEntityName for User {
//! #     fn table_name(&self) -> &'static str { "users" }
//! # }
//! # impl Default for User {
//! #     fn default() -> Self { User }
//! # }
//! # impl lifeguard::LifeModelTrait for User {
//! #     type Model = UserModel;
//! #     type Column = ();
//! # }
//! # let executor: &dyn LifeExecutor = todo!();
//!
//! // Use the entity to query
//! let users = User::find().all(executor)?;
//! ```

use crate::executor::LifeExecutor;

use crate::query::select::SelectQuery;

/// Trait for providing table name information.
///
///
/// Similar to SeaORM's `EntityName`, this trait provides the table name
/// and requires `Default` so entities can be instantiated for query building.
pub trait LifeEntityName: Default {
    /// Get the name of the table.
    fn table_name(&self) -> &'static str;
    
    /// Get the schema name (if any).
    /// Returns `None` if no schema is specified (default schema).
    fn schema_name(&self) -> Option<&'static str> {
        None
    }
}

/// Trait for LifeModel entities that provides CRUD operations.
///
///
/// This trait is similar to SeaORM's `EntityTrait` and provides methods for
/// querying and manipulating database records. The trait is implemented by
/// the `LifeModel` derive macro for the Entity (struct name), not the Model.
///
/// Following SeaORM's pattern:
/// - Entity (struct name) implements `LifeModelTrait`
/// - Model is an associated type: `type Model: FromRow`
/// - `SelectQuery<Entity>` requires `Entity: LifeModelTrait` (satisfied by the impl)
/// - `find()` is defined in the trait (not generated by macro) to avoid trait bound issues
///
/// # Example
///
/// ```no_run
/// use lifeguard::{LifeModelTrait, LifeExecutor};
/// use sea_query::Expr;
///
/// # struct User; // Entity
/// # struct UserModel { id: i32, name: String }; // Model
/// # impl lifeguard::FromRow for UserModel {
/// #     fn from_row(_row: &may_postgres::Row) -> Result<Self, may_postgres::Error> { todo!() }
/// # }
/// # impl lifeguard::LifeEntityName for User {
/// #     fn table_name(&self) -> &'static str { "users" }
/// # }
/// # impl Default for User {
/// #     fn default() -> Self { User }
/// # }
/// # impl lifeguard::LifeModelTrait for User {
/// #     type Model = UserModel;
/// #     type Column = ();
/// # }
/// # let executor: &dyn LifeExecutor = todo!();
///
/// // Find users with name starting with "John"
/// let users = User::find()
///     .filter(Expr::col("name").like("John%"))
///     .all(executor)?;
/// ```
pub trait LifeModelTrait: LifeEntityName {
    /// The Model type that represents database rows.
    ///
    ///
    /// Note: The `FromRow` bound is not enforced here to avoid macro expansion issues.
    /// The bound is checked at usage sites (in SelectQuery methods) where it can be verified.
    type Model;

    /// The Column enum type for this entity.
    ///
    ///
    /// This is generated by the LifeModel derive macro and provides type-safe column access.
    type Column: sea_query::IdenStatic + crate::query::column::column_trait::ColumnDefHelper;

    /// Get all column variants for this entity.
    ///
    /// Returns a static slice of all Column enum variants.
    /// This is useful for iterating through all columns, e.g., when building SELECT queries
    /// that need to check for select_as expressions.
    ///
    /// # Default Implementation
    ///
    /// Returns an empty slice. The `LifeModel` macro generates implementations
    /// that return all column variants via the `Column::all_columns()` method.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use lifeguard::LifeModelTrait;
    ///
    /// # struct User;
    /// # impl lifeguard::LifeModelTrait for User {
    /// #     type Model = ();
    /// #     type Column = ();
    /// # }
    /// let columns = User::all_columns();
    /// for column in columns {
    ///     // Process each column
    /// }
    /// ```
    fn all_columns() -> &'static [Self::Column]
    where
        Self: Sized,
    {
        // Default implementation returns empty slice
        // Macro will override this with actual implementation
        &[]
    }

    /// Start a query builder for finding records.
    ///
    ///
    /// This method is defined in the trait (not generated by macro) to avoid
    /// trait bound resolution issues during macro expansion. The macro only
    /// generates the trait implementation with associated types.
    ///
    /// # Returns
    ///
    /// Returns a query builder that can be chained with filters, ordering, pagination, etc.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use lifeguard::{LifeModelTrait, LifeExecutor};
    ///
    /// # struct User; // Entity
    /// # struct UserModel { id: i32 }; // Model
    /// # impl lifeguard::FromRow for UserModel {
    /// #     fn from_row(_row: &may_postgres::Row) -> Result<Self, may_postgres::Error> { todo!() }
    /// # }
    /// # impl lifeguard::LifeEntityName for User {
    /// #     fn table_name(&self) -> &'static str { "users" }
    /// # }
    /// # impl Default for User {
    /// #     fn default() -> Self { User }
    /// # }
    /// # impl lifeguard::LifeModelTrait for User {
    /// #     type Model = UserModel;
    /// #     type Column = ();
    /// # }
    /// # let executor: &dyn LifeExecutor = todo!();
    ///
    /// let users = User::find().all(executor)?;
    /// ```
    fn find() -> SelectQuery<Self>
    where
        Self: Sized,
    {
        SelectQuery::new()
    }

    /// Insert an ActiveModel (Record) into the database.
    ///
    ///
    /// This is a convenience method that delegates to `ActiveModelTrait::insert()`.
    /// It provides a static method on Entity for consistency with SeaORM's API.
    ///
    /// # Arguments
    ///
    /// * `active_model` - The ActiveModel (Record) to insert
    /// * `executor` - The database executor to use
    ///
    /// # Returns
    ///
    /// Returns the inserted model on success, or an error if the operation fails.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use lifeguard::{LifeModelTrait, ActiveModelTrait, LifeExecutor};
    ///
    /// # struct User; // Entity
    /// # struct UserModel { id: i32, name: String }; // Model
    /// # struct UserRecord; // Record
    /// # impl lifeguard::ActiveModelTrait for UserRecord {
    /// #     type Model = UserModel;
    /// #     fn insert<E: LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> { todo!() }
    /// #     // ... other methods
    /// # }
    /// # impl lifeguard::LifeModelTrait for User {
    /// #     type Model = UserModel;
    /// #     type Column = ();
    /// # }
    /// # let executor: &dyn LifeExecutor = todo!();
    /// # let record = UserRecord; // UserRecord::new();
    ///
    /// let model = User::insert(record, executor)?;
    /// ```
    fn insert<AM, E>(active_model: AM, executor: &E) -> Result<Self::Model, crate::active_model::ActiveModelError>
    where
        Self: Sized,
        AM: crate::active_model::ActiveModelTrait<Model = Self::Model>,
        E: LifeExecutor,
    {
        active_model.insert(executor)
    }

    /// Update an ActiveModel (Record) in the database.
    ///
    ///
    /// This is a convenience method that delegates to `ActiveModelTrait::update()`.
    /// It provides a static method on Entity for consistency with SeaORM's API.
    ///
    /// # Arguments
    ///
    /// * `active_model` - The ActiveModel (Record) to update
    /// * `executor` - The database executor to use
    ///
    /// # Returns
    ///
    /// Returns the updated model on success, or an error if the operation fails.
    ///
    /// # Note
    ///
    /// This requires a primary key to be set in the ActiveModel.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use lifeguard::{LifeModelTrait, ActiveModelTrait, LifeExecutor};
    ///
    /// # struct User; // Entity
    /// # struct UserModel { id: i32, name: String }; // Model
    /// # struct UserRecord; // Record
    /// # impl lifeguard::ActiveModelTrait for UserRecord {
    /// #     type Model = UserModel;
    /// #     fn update<E: LifeExecutor>(&self, _executor: &E) -> Result<Self::Model, lifeguard::ActiveModelError> { todo!() }
    /// #     // ... other methods
    /// # }
    /// # impl lifeguard::LifeModelTrait for User {
    /// #     type Model = UserModel;
    /// #     type Column = ();
    /// # }
    /// # let executor: &dyn LifeExecutor = todo!();
    /// # let record = UserRecord; // UserRecord::from_model(&existing_model);
    ///
    /// let model = User::update(record, executor)?;
    /// ```
    fn update<AM, E>(active_model: AM, executor: &E) -> Result<Self::Model, crate::active_model::ActiveModelError>
    where
        Self: Sized,
        AM: crate::active_model::ActiveModelTrait<Model = Self::Model>,
        E: LifeExecutor,
    {
        active_model.update(executor)
    }

    /// Delete a record from the database by primary key.
    ///
    ///
    /// This is a convenience method that delegates to `ActiveModelTrait::delete()`.
    /// It provides a static method on Entity for consistency with SeaORM's API.
    ///
    /// # Arguments
    ///
    /// * `active_model` - The ActiveModel (Record) with primary key set
    /// * `executor` - The database executor to use
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` on success, or an error if the operation fails.
    ///
    /// # Note
    ///
    /// This requires a primary key to be set in the ActiveModel.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use lifeguard::{LifeModelTrait, ActiveModelTrait, LifeExecutor};
    ///
    /// # struct User; // Entity
    /// # struct UserModel { id: i32, name: String }; // Model
    /// # struct UserRecord; // Record
    /// # impl lifeguard::ActiveModelTrait for UserRecord {
    /// #     type Model = UserModel;
    /// #     fn delete<E: LifeExecutor>(&self, _executor: &E) -> Result<(), lifeguard::ActiveModelError> { Ok(()) }
    /// #     // ... other methods
    /// # }
    /// # impl lifeguard::LifeModelTrait for User {
    /// #     type Model = UserModel;
    /// #     type Column = ();
    /// # }
    /// # let executor: &dyn LifeExecutor = todo!();
    /// # let record = UserRecord; // UserRecord::from_model(&existing_model);
    ///
    /// User::delete(record, executor)?;
    /// ```
    fn delete<AM, E>(active_model: AM, executor: &E) -> Result<(), crate::active_model::ActiveModelError>
    where
        Self: Sized,
        AM: crate::active_model::ActiveModelTrait<Model = Self::Model>,
        E: LifeExecutor,
    {
        active_model.delete(executor)
    }
}

/// Trait for types that can be created from a database row
pub trait FromRow: Sized {
    fn from_row(row: &may_postgres::Row) -> Result<Self, may_postgres::Error>;
}

// FromRow implementation for serde_json::Value
use serde_json::Value as JsonValue;
impl FromRow for JsonValue {
    fn from_row(row: &may_postgres::Row) -> Result<Self, may_postgres::Error> {
        if row.len() == 0 {
            let _: String = row.try_get::<_, String>(999)?;
            unreachable!()
        }
        let text: String = row.get(0);
        match serde_json::from_str(&text) {
            Ok(json) => Ok(json),
            Err(_e) => {
                let _: i32 = row.try_get::<_, i32>(0)?;
                unreachable!()
            }
        }
    }
}
