# lifeguard-codegen

Code generation CLI tool for Lifeguard ORM - generates Rust source files to avoid macro expansion issues.

## Overview

`lifeguard-codegen` is a command-line tool that generates Rust source files for partial models and other code structures. It generates `.rs` files with trait implementations directly (no macros), which are then compiled normally, avoiding type inference errors that can occur during macro expansion.

## Installation

The tool is part of the Lifeguard workspace. Build it with:

```bash
cargo build --bin lifeguard-codegen
```

Or install it:

```bash
cargo install --path lifeguard-codegen
```

## Usage

### Generate Partial Model

Generate a partial model struct that implements `PartialModelTrait` and `FromRow`:

```bash
lifeguard-codegen partial-model \
  --name UserPartial \
  --entity crate::users::Entity \
  --output-dir src/partial_models \
  --fields '[{"name": "id", "type": "i32"}, {"name": "name", "type": "String"}, {"name": "email", "type": "String", "column_name": "email_address"}]'
```

#### Arguments

- `--name` / `-n` - Name of the partial model struct (e.g., `UserPartial`)
- `--entity` / `-e` - Fully qualified path to the Entity type (e.g., `crate::users::Entity` or `super::UserEntity`)
- `--output-dir` / `-o` - Output directory for generated files (default: `src/partial_models`)
- `--fields` / `-f` - Fields definition as JSON array

#### Fields JSON Format

Each field in the JSON array can have:

- `name` (required) - Field name in Rust struct
- `type` (required) - Rust type (e.g., `i32`, `String`, `Option<String>`)
- `column_name` (optional) - Database column name (default: snake_case of field name)

Example:

```json
[
  {"name": "id", "type": "i32"},
  {"name": "name", "type": "String"},
  {"name": "email", "type": "String", "column_name": "email_address"},
  {"name": "bio", "type": "Option<String>"}
]
```

## Generated Code

The tool generates a Rust source file with:

1. **Struct Definition** - The partial model struct with specified fields
2. **PartialModelTrait Implementation** - Implements `lifeguard::PartialModelTrait` with:
   - `Entity` associated type
   - `selected_columns()` method returning column names
3. **FromRow Implementation** - Implements `lifeguard::FromRow` for converting `may_postgres::Row` to the struct

### Example Generated Code

For a `UserPartial` struct, the generated code looks like:

```rust
// Generated partial model for UserPartial
// This file was generated by lifeguard-codegen
// DO NOT EDIT - regenerate using: lifeguard-codegen partial-model ...

/// Partial model for UserPartial
/// Generated by lifeguard-codegen
pub struct UserPartial {
    pub id: i32,
    pub name: String,
    pub email: String,
}

impl lifeguard::PartialModelTrait for UserPartial {
    type Entity = crate::users::Entity;

    fn selected_columns() -> Vec<&'static str> {
        vec![
            "id",
            "name",
            "email_address",
        ]
    }
}

impl lifeguard::FromRow for UserPartial {
    fn from_row(row: &may_postgres::Row) -> Result<Self, may_postgres::Error> {
        Ok(Self {
            id: row.try_get::<&str, i32>("id")?,
            name: row.try_get::<&str, String>("name")?,
            email: row.try_get::<&str, String>("email_address")?,
        })
    }
}
```

## Type Support

The tool handles various Rust types, including:

- **Integers**: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`
- **Floats**: `f32`, `f64`
- **Strings**: `String`
- **Booleans**: `bool`
- **Dates/Times**: `chrono::NaiveDateTime`, `chrono::DateTime`, `chrono::NaiveDate`
- **UUIDs**: `uuid::Uuid`
- **Decimals**: `rust_decimal::Decimal`
- **JSON**: `serde_json::Value`
- **Optionals**: `Option<T>` for nullable columns

### Unsigned Integer Handling

The tool automatically handles unsigned integer types by converting them to signed types for database retrieval, then casting back to unsigned:

- `u8` → `i16` → `u8`
- `u16` → `i32` → `u16`
- `u32` → `i64` → `u32`
- `u64` → `i64` → `u64`

## Use Cases

### Avoiding Macro Expansion Issues

When using `LifeModel` derive macro, you might encounter type inference errors (E0284) during macro expansion. Generating partial models with this tool avoids these issues by:

1. Generating code directly (no macro expansion)
2. Compiling normally with full type checking
3. Providing explicit type annotations

### Selective Field Queries

Partial models are useful when you only need a subset of columns from a table:

```rust
use lifeguard::query::SelectQuery;

// Query only id and name columns
let users: Vec<UserPartial> = SelectQuery::new()
    .from(UserEntity)
    .select(UserPartial::selected_columns())
    .execute(&executor)
    .await?;
```

### Performance Optimization

Querying only needed columns reduces:
- Network transfer
- Memory usage
- Deserialization time

## Integration with Build System

You can integrate code generation into your build process:

### Cargo Build Script

Create `build.rs`:

```rust
use std::process::Command;

fn main() {
    // Generate partial models
    let output = Command::new("lifeguard-codegen")
        .arg("partial-model")
        .arg("--name")
        .arg("UserPartial")
        .arg("--entity")
        .arg("crate::users::Entity")
        .arg("--output-dir")
        .arg("src/partial_models")
        .arg("--fields")
        .arg(r#"[{"name": "id", "type": "i32"}, {"name": "name", "type": "String"}]"#)
        .output()
        .expect("Failed to generate partial model");
    
    if !output.status.success() {
        panic!("Code generation failed: {}", String::from_utf8_lossy(&output.stderr));
    }
}
```

### Makefile/Justfile

Add a target:

```makefile
generate-partial-models:
	lifeguard-codegen partial-model \
		--name UserPartial \
		--entity crate::users::Entity \
		--output-dir src/partial_models \
		--fields '[...]'
```

## License

Licensed under either of:

- Apache License, Version 2.0 ([LICENSE-APACHE](../LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
- MIT license ([LICENSE-MIT](../LICENSE-MIT) or http://opensource.org/licenses/MIT)

at your option.
