//! Lifeguard Codegen CLI Tool
//!
//! Generates Rust source files for partial models to avoid macro expansion issues.
//! This tool generates .rs files with trait implementations directly (no macros),
//! which are then compiled normally (avoiding E0284 type inference errors that occur
//! during macro expansion).

use std::fs;
use std::path::{Path, PathBuf};

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "lifeguard-codegen")]
#[command(about = "Code generation tool for Lifeguard ORM")]
#[command(version = "0.1.0")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate a partial model struct
    PartialModel {
        /// Name of the partial model struct (e.g., UserPartial)
        #[arg(short, long)]
        name: String,
        
        /// Fully qualified path to the Entity type (e.g., crate::users::Entity or super::UserEntity)
        #[arg(short, long)]
        entity: String,
        
        /// Output directory for generated files
        #[arg(short, long, default_value = "src/partial_models")]
        output_dir: PathBuf,
        
        /// Fields definition as JSON: [{"name": "id", "type": "i32"}, {"name": "name", "type": "String", "column_name": "full_name"}]
        #[arg(short, long)]
        fields: String,
    },
}

fn main() {
    let cli = Cli::parse();

    match cli.command {
        Commands::PartialModel {
            name,
            entity,
            output_dir,
            fields,
        } => {
            if let Err(e) = generate_partial_model(&name, &entity, &output_dir, &fields) {
                eprintln!("Error generating partial model: {}", e);
                std::process::exit(1);
            }
        }
    }
}

/// Generate a partial model Rust source file
fn generate_partial_model(
    name: &str,
    entity: &str,
    output_dir: &Path,
    fields_json: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    // Parse fields from JSON
    let fields: Vec<FieldDef> = serde_json::from_str(fields_json)?;
    
    // Create output directory if it doesn't exist
    fs::create_dir_all(output_dir)?;
    
    // Generate the Rust code (direct trait implementations, no macro)
    let code = generate_partial_model_code(name, entity, &fields);
    
    // Write to file
    let filename = format!("{}.rs", to_snake_case(name));
    let filepath = output_dir.join(&filename);
    
    fs::write(&filepath, code)?;
    
    println!("âœ… Generated partial model: {}", filepath.display());
    println!("   Struct: {}", name);
    println!("   Entity: {}", entity);
    println!("   Fields: {}", fields.len());
    
    Ok(())
}

#[derive(serde::Deserialize, Debug)]
struct FieldDef {
    name: String,
    #[serde(rename = "type")]
    ty: String,
    #[serde(rename = "column_name")]
    column_name: Option<String>,
}

/// Generate Rust code for a partial model
/// This generates the trait implementations directly (no macro) to avoid E0284 errors
fn generate_partial_model_code(
    struct_name: &str,
    entity_path: &str,
    fields: &[FieldDef],
) -> String {
    let mut code = String::new();
    
    // Header comment (regular comments, not module-level docs)
    code.push_str(&format!("// Generated partial model for {}\n", struct_name));
    code.push_str("// This file was generated by lifeguard-codegen\n");
    code.push_str("// DO NOT EDIT - regenerate using: lifeguard-codegen partial-model ...\n\n");
    
    // Struct definition (no macro - just the struct)
    code.push_str(&format!("/// Partial model for {}\n", struct_name));
    code.push_str("/// Generated by lifeguard-codegen\n");
    code.push_str(&format!("pub struct {} {{\n", struct_name));
    
    // Fields
    for field in fields {
        code.push_str(&format!("    pub {}: {},\n", field.name, field.ty));
    }
    
    code.push_str("}\n\n");
    
    // Generate PartialModelTrait implementation
    code.push_str(&format!("impl lifeguard::PartialModelTrait for {} {{\n", struct_name));
    code.push_str(&format!("    type Entity = {};\n\n", entity_path));
    code.push_str("    fn selected_columns() -> Vec<&'static str> {\n");
    code.push_str("        vec![\n");
    
    for field in fields {
        // Compute column name (either from attribute or snake_case conversion)
        let column_name = if let Some(ref col_name) = field.column_name {
            col_name.clone()
        } else {
            to_snake_case(&field.name)
        };
        code.push_str(&format!("            \"{}\",\n", column_name));
    }
    
    code.push_str("        ]\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");
    
    // Generate FromRow implementation
    code.push_str(&format!("impl lifeguard::FromRow for {} {{\n", struct_name));
    code.push_str("    fn from_row(row: &may_postgres::Row) -> Result<Self, may_postgres::Error> {\n");
    code.push_str("        Ok(Self {\n");
    
    for field in fields {
        // Compute column name (either from attribute or snake_case conversion)
        let column_name = if let Some(ref col_name) = field.column_name {
            col_name.clone()
        } else {
            to_snake_case(&field.name)
        };
        
        // Handle unsigned integer types (convert to signed first)
        // Note: row.get() returns the value directly (not Result), but we use try_get for error handling
        // Use exact matching (like the macro does) to avoid matching types like "u128", "u8x4", etc.
        let get_expr = match field.ty.as_str() {
            "u8" | "u16" | "u32" | "u64" => {
                let signed_type = match field.ty.as_str() {
                    "u8" => "i16",
                    "u16" => "i32",
                    "u32" | "u64" => "i64",
                    _ => unreachable!(), // This should never happen due to outer match
                };
                format!("            {}: {{\n                let val: {} = row.try_get::<&str, {}>(\"{}\")?;\n                val as {}\n            }},", 
                        field.name, signed_type, signed_type, column_name, field.ty)
            }
            _ => {
                format!("            {}: row.try_get::<&str, {}>(\"{}\")?,", field.name, field.ty, column_name)
            }
        };
        
        code.push_str(&get_expr);
        code.push_str("\n");
    }
    
    code.push_str("        })\n");
    code.push_str("    }\n");
    code.push_str("}\n");
    
    code
}

/// Convert PascalCase to snake_case
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() && i > 0 {
            result.push('_');
        }
        result.push(c.to_lowercase().next().unwrap());
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Test that exact unsigned integer types (u8, u16, u32, u64) generate conversion code
    #[test]
    fn test_unsigned_integer_exact_matches() {
        let fields = vec![
            FieldDef { name: "id".to_string(), ty: "u8".to_string(), column_name: None },
            FieldDef { name: "count".to_string(), ty: "u16".to_string(), column_name: None },
            FieldDef { name: "size".to_string(), ty: "u32".to_string(), column_name: None },
            FieldDef { name: "offset".to_string(), ty: "u64".to_string(), column_name: None },
        ];
        
        let code = generate_partial_model_code("TestModel", "crate::TestEntity", &fields);
        
        // Verify u8 generates conversion code (i16 -> u8)
        assert!(code.contains("let val: i16 = row.try_get::<&str, i16>"));
        assert!(code.contains("val as u8"));
        
        // Verify u16 generates conversion code (i32 -> u16)
        assert!(code.contains("let val: i32 = row.try_get::<&str, i32>"));
        assert!(code.contains("val as u16"));
        
        // Verify u32 generates conversion code (i64 -> u32)
        assert!(code.contains("let val: i64 = row.try_get::<&str, i64>"));
        assert!(code.contains("val as u32"));
        
        // Verify u64 generates conversion code (i64 -> u64)
        assert!(code.contains("val as u64"));
    }

    /// Test that types starting with "u" but not exact matches are NOT treated as unsigned
    #[test]
    fn test_unsigned_integer_edge_cases_not_matched() {
        let fields = vec![
            FieldDef { name: "id".to_string(), ty: "u128".to_string(), column_name: None },
            FieldDef { name: "data".to_string(), ty: "u8x4".to_string(), column_name: None },
            FieldDef { name: "custom".to_string(), ty: "u8CustomType".to_string(), column_name: None },
        ];
        
        let code = generate_partial_model_code("TestModel", "crate::TestEntity", &fields);
        
        // These should NOT generate conversion code - should use direct type
        // Verify u128 uses direct type (no conversion)
        assert!(code.contains("row.try_get::<&str, u128>"));
        assert!(!code.contains("let val: i64 = row.try_get::<&str, i64>(\"id\")?;\n                val as u128"));
        
        // Verify u8x4 uses direct type (no conversion)
        assert!(code.contains("row.try_get::<&str, u8x4>"));
        assert!(!code.contains("let val: i16 = row.try_get::<&str, i16>(\"data\")?;\n                val as u8x4"));
        
        // Verify u8CustomType uses direct type (no conversion)
        assert!(code.contains("row.try_get::<&str, u8CustomType>"));
        assert!(!code.contains("let val: i16 = row.try_get::<&str, i16>(\"custom\")?;\n                val as u8CustomType"));
    }

    /// Test that regular types (signed integers, strings, etc.) use direct type
    #[test]
    fn test_regular_types_use_direct() {
        let fields = vec![
            FieldDef { name: "id".to_string(), ty: "i32".to_string(), column_name: None },
            FieldDef { name: "name".to_string(), ty: "String".to_string(), column_name: None },
            FieldDef { name: "count".to_string(), ty: "i64".to_string(), column_name: None },
        ];
        
        let code = generate_partial_model_code("TestModel", "crate::TestEntity", &fields);
        
        // All should use direct type (no conversion)
        assert!(code.contains("row.try_get::<&str, i32>"));
        assert!(code.contains("row.try_get::<&str, String>"));
        assert!(code.contains("row.try_get::<&str, i64>"));
        
        // Should NOT contain any conversion code
        assert!(!code.contains("let val:"));
        assert!(!code.contains("val as"));
    }

    /// Test mixed types (some unsigned, some not)
    #[test]
    fn test_mixed_types() {
        let fields = vec![
            FieldDef { name: "id".to_string(), ty: "u8".to_string(), column_name: None },
            FieldDef { name: "name".to_string(), ty: "String".to_string(), column_name: None },
            FieldDef { name: "count".to_string(), ty: "u128".to_string(), column_name: None },
        ];
        
        let code = generate_partial_model_code("TestModel", "crate::TestEntity", &fields);
        
        // u8 should have conversion
        assert!(code.contains("let val: i16 = row.try_get::<&str, i16>(\"id\")?;\n                val as u8"));
        
        // String should be direct
        assert!(code.contains("row.try_get::<&str, String>(\"name\")?"));
        
        // u128 should be direct (not matched as unsigned)
        assert!(code.contains("row.try_get::<&str, u128>(\"count\")?"));
        assert!(!code.contains("let val: i64 = row.try_get::<&str, i64>(\"count\")?;\n                val as u128"));
    }
}
